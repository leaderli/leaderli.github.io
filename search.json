[{"title":"深入git","url":"/2020/06/28/%E6%B7%B1%E5%85%A5git/","content":"\n## 文件结构\n\n当使用`git init`创建一个新的仓库时，Git 会创建一个`.git`目录。目录结构如下：\n\n```shell\nHEAD\nconfig\ndescription\nhooks/\nindex\ninfo/\nobjects/\nrefs/\n```\n\n- HEAD 当前被检出分支的指针\n- config 项目特有的配置\n- description 描述文件\n- hooks 钩子脚本\n- index 保存暂存区信息，在首次`git add`后才会生成\n- info 包含一个全局性排除文件\n- objects 存储所有数据内容\n- refs 所有分支的提交对象的指针\n\n### `Working Directory`\n\n除.git 目录的其他目录和文件，不包含.gitignore 排除的目录及文件\n\n## 对象结构\n\nGit 是一个内容寻址文件系统。其核心部分时一个简单的键值对数据库。你可以想 Git 仓库插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回内容。\n\nGit 有数据对象（blob），树对象（tree），引用(refs)\n\n### blob\n\n每个文件的数据内容以二进制的形式存储在 Git 仓库中，我们可以使用命令`git hash-object -w <file>`的方式，手动向 git 数据库中插入该数据（即在`.git/objects`目录下，写入该对象），而它只会返回存储在 Git 仓库的唯一键。此命令输出一个长度为 40 的 sha1 哈希值，前 2 位字符用于命名子目录，后 38 位则用作文件名\n例如：\n\n```shell\n$ find .git/objects/ -type f\n$ echo 'test content' |git hash-object -w --stdin\nd670460b4b4aece5915caf5c68d12f560a9fe3e4\n$ find .git/objects/ -type f\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\n$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4\ntest content\n```\n\n> git 使用 sha1 时，在可区分唯一 sha1 时最少可只用前四位就可以\n\n一开始`.git/objects`下没有存储任何数据对象，当我们使用`git hash-object`命令存入一条内容时，可以观察到`.git.objects`目录下，生成了 sha1 相对应的子目录和文件名。通过`git cat-file -p <sha1>`查看数据对象时，我们可以看到之前存入的文本内容\n\n我们使用`git add <file>`时，就是 Git 内部做了`git hash-object`的命令，将`<file>`的内容存入到`.git/objects`中。\n\n```shell\n$ echo 'version 1' > 1.txt\n$ git add .\n$ find .git/objects/ -type f\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\n.git/objects/83/baae61804e65cc73a7201a7252750c76066a30\n$ git cat-file -p 83baae\n```\n\n使用`git add`后，我们可以看到`index`文件的生成\n\n```shell\n$ find .git/ -type f\n...\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\n.git/objects/83/baae61804e65cc73a7201a7252750c76066a30\n.git/index\n# 查看index内容\n$ git ls-files --stage\n100644 83baae61804e65cc73a7201a7252750c76066a30 0 1.txt\n```\n\n我们可以看到 index 保存了工作区 add 的 blob 对象的 sha1\n\nblob 对象是针对数据内容的，不区分文件\n\n例如：\n\n```shell\n$ echo 'version 1' > 2.txt\n$ git add 2.txt\n$ find .git/objects/ -type f\n# 可以看到blob对象并没有增加\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\n.git/objects/83/baae61804e65cc73a7201a7252750c76066a\n$ git ls-files --stage\n100644 83baae61804e65cc73a7201a7252750c76066a30 0 1.txt\n100644 83baae61804e65cc73a7201a7252750c76066a30 0 2.txt\n\n```\n\n### tree\n\nGit 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。 一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。\n\n当我们使用`git commit`后，我们可以看到\n\n```shell\n\n$ git commit -m 'commit 1'\n[master (root-commit) 9f1224b] commit 1\n 2 files changed, 2 insertions(+)\n create mode 100644 1.txt\n create mode 100644 2.txt\n\n# 查看.git目录\n$ find .git/ -type\n.git/refs/heads/master\n...\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\n.git/objects/83/baae61804e65cc73a7201a7252750c76066a30\n.git/objects/1d/49be59d2805f145b66c15641a11e945a5d021a\n.git/objects/9f/1224bca340fb2e4235adfa3e42297033c26ec9\n.git/index\n.git/COMMIT_EDITMSG\n...\n\n# 我们可以看到生成了两个新的对象\n# tree\n$ git cat-file -p 1d49be\n100644 blob 83baae61804e65cc73a7201a7252750c76066a30 1.txt\n100644 blob 83baae61804e65cc73a7201a7252750c76066a30 2.txt\n\n# commit commit中包含了tree对象的sha1\n$ git cat-file -p 9f1224\ntree 1d49be59d2805f145b66c15641a11e945a5d021a\nauthor leaderli <429243408@qq.com> 1593549136 +0800\ncommitter leaderli <429243408@qq.com> 1593549136 +0800\n\ncommit 1\n\n# 查看所有对象\n$ git cat-file --batch-check --batch-all-objects\n1d49be59d2805f145b66c15641a11e945a5d021a tree 66\n83baae61804e65cc73a7201a7252750c76066a30 blob 10\n9f1224bca340fb2e4235adfa3e42297033c26ec9 commit 163\nd670460b4b4aece5915caf5c68d12f560a9fe3e4 blob 13\n\n```\n\n#### commit 工作原理\n\ncommit 对象指向的 tree 对象，遍历 tree 对象查找到的所有 blob 对象，与缓存区中的所有 blob 进行 diff 对比，若有差异，则可以进行下一次 commit。\n\n### refs\n\n如果你对仓库中从一个提交（比如 9f1224）开始往前的历史感兴趣，那么可以运行 git log 9f1224 开始往前的历史感兴趣，那么可以运行这样的命令来显示历史，不过你需要记得 9f1224b 是你查看历史的起点提交。 如果我们有一个文件来保存 SHA-1 值，而该文件有一个简单的名字， 然后用这个名字指针来替代原始的 SHA-1 值的话会更加简单。\n\n在 Git 中，这种简单的名字被称为“引用（references，或简写为 refs）”。 你可以在 .git/refs 目录下找到这类含有 SHA-1 值的文件。 在目前的项目中，这个目录没有包含任何文件，但它包含了一个简单的目录结构：\n\n```shell\n$ find .git/refs -type f\n.git/refs/heads/master\n\n$ more .git/refs/heads/master\n9f1224bca340fb2e4235adfa3e42297033c26ec\n```\n\n#### HEAD 引用\n\nHEAD 文件通常是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，表示它是一个指向其他引用的指针。我们通常使用`git checkout`来更改 HEAD 的内容\n\n```shell\n$ more .git/HEAD\nref: refs/heads/master\n\n# 当我们切换分支后\n$ git checkout dev\n$ more .git/HEAD\nref: refs/heads/dev\n\n# 当我们`git checkout <commit>`时，此时HEAD未指向一个分支，git会提醒我们去创建一个新的分支，否则会在切换分支时丢失掉这个HEAD\n$ git checkout 9f1224b\nNote: checking out '9f1224b'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n\n  git checkout -b <new-branch-name>\n\nHEAD is now at 9f1224b commit 1\n\n# 我们查看下现在的HEAD内容，其指向的不是分支的引用\n$ more .git/HEAD\n9f1224bca340fb2e4235adfa3e42297033c26ec9\n```\n\n#### 标签引用\n\n标签对象（tag object） 非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。 主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。\n\n```shell\n$ git tag V1.0 9f1224b -m 'commit 1 tag v1.0'\n\n$ find .git/refs -type f\n.git/refs/heads/master\n.git/refs/tags/V1.0\n\n$ more .git/refs/tags/V1.0\n5dfd1ba5bf0614a54f43269524881d7cc3434d49\n\n$ git cat-file -p 5dfd1ba5bf0614a54f43269524881d7cc3434d49\nobject 9f1224bca340fb2e4235adfa3e42297033c26ec9\ntype commit\ntag V1.0\ntagger leaderli <429243408@qq.com> 1593582664 +0800\n\ncommit 1 tag v1.0\n\n```\n\n#### 远程引用\n\n如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 refs/remotes 目录下。\n\n### git gc\n\n当使用`git gc`或者`git push`时，git 会自动将`.git/objects/`下文件进行压缩，在`.git/objects/pack/`下生成`.idx`和`.pack`文件。\n\n## 分支\n\ngit 的 commit 是一个有向无环图，其只包含父类 commit 的 sha1，分支仅仅是一个指针其值为 commit 的 sha1\n\n查看.git 内的文件可以看到生成了.git/refs/heads/master，可以发现其指向 commit 1\n\n```shell\n$ more .git/refs/heads/master\n9f1224bca340fb2e4235adfa3e42297033c26ec9\n```\n\n我们可以通过查看.git/logs/refs/heads/master，查看分支的历史记录，这也是`git log`命令的原理\n\n```shell\n$ more .git/logs/refs/heads/master\n0000000000000000000000000000000000000000 9f1224bca340fb2e4235adfa3e42297033c26ec9 leaderli <429243408@qq.com> 1\n593549136 +0800\tcommit (initial): commit 1\n9f1224bca340fb2e4235adfa3e42297033c26ec9 014901f4a370ec3d0db58fc7a4cf9950d2111fbe leaderli <429243408@qq.com> 1\n593555980 +0800\tcommit: commit 2\n```\n\n我们新增子目录以及子文件，并添加到 stage 区\n\n```shell\n$ mkdir dir\n$ echo \"version 3\" > dir/3.txt\n$ git status\nOn branch master\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n  dir/\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n# 添加到缓存区\n\n$ git add dir/\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n  new file:   dir/3.txt\n```\n\n### git diff\n\n`git diff --cache`是比较 index 和 HEAD 的差异\n\n```shell\n# 我们查看HEAD的内容,发现HEAD指向master的commit 1\n$ more .git/HEAD\nref: refs/heads/master\n$ more .git/refs/heads/master\n9f1224bca340fb2e4235adfa3e42297033c26ec9\n\n# commit 1指向的tree对象的内容为\n$ git cat-file  -p 9f1224bca340fb2e4235adfa3e42297033c26ec9\ntree 1d49be59d2805f145b66c15641a11e945a5d021a\nauthor leaderli <429243408@qq.com> 1593549136 +0800\ncommitter leaderli <429243408@qq.com> 1593549136 +0800\n\ncommit 1\n$ git cat-file -p 1d49be59d2805f145b66c15641a11e945a5d021a\n100644 blob 83baae61804e65cc73a7201a7252750c76066a30 1.txt\n100644 blob 83baae61804e65cc73a7201a7252750c76066a30 2.txt\n\n# index\n$ git ls-files -s\n100644 83baae61804e65cc73a7201a7252750c76066a30 0 1.txt\n100644 83baae61804e65cc73a7201a7252750c76066a30 0 2.txt\n100644 7170a5278f42ea12d4b6de8ed1305af8c393e756 0 dir/3.txt\n\n# 使用diff查看差异内容\n$ git diff --cached\ndiff --git a/dir/3.txt b/dir/3.txt\nnew file mode 100644\nindex 0000000..7170a52\n--- /dev/null\n+++ b/dir/3.txt\n@@ -0,0 +1 @@\n+version 3\n\n```\n\n提交 commit 2\n\n```shell\n$ git commit -m 'commit 2'\n[master 014901f] commit 2\n 1 file changed, 1 insertion(+)\n create mode 100644 dir/3.txt\n\n# HEAD当前执行commit 2\n$ more .git/HEAD\nref: refs/heads/master\n$ more .git/refs/heads/master\n014901f4a370ec3d0db58fc7a4cf9950d2111fbe\n$ git cat-file -p 014901f4a370ec3d0db58fc7a4cf9950d2111fbe\ntree 162488e047cda08c69e932e81722f7ce191057ee\n# commit 2的父节点为commit 1\nparent 9f1224bca340fb2e4235adfa3e42297033c26ec9\nauthor leaderli <429243408@qq.com> 1593555980 +0800\ncommitter leaderli <429243408@qq.com> 1593555980 +0800\n\ncommit 2\n\n# 查看commit 2 指向的tree\n$ git cat-file -p 162488e047cda08c69e932e81722f7ce191057ee\n100644 blob 83baae61804e65cc73a7201a7252750c76066a30 1.txt\n100644 blob 83baae61804e65cc73a7201a7252750c76066a30 2.txt\n040000 tree b57d4c5b3c1f31f87d0d5e7343db0b53f8f650c2 dir\n\n$ git cat-file -p b57d4c5b3c1f31f87d0d5e7343db0b53f8f650c2\n100644 blob 7170a5278f42ea12d4b6de8ed1305af8c393e756 3.txt\n\n# HEAD执行的tree和index的一致了\n$ git diff --cached\n```\n\n从概念上讲，此时 Git 内部存储的数据有点像这样：\n![深入git_内部数据存储结构.png](./images/深入git_内部数据存储结构.png)\n\n`git diff <commit1> <commit2>`的原理都是差不多的\n\n### 切换分支\n\n切换分支本质上就是将 HEAD 的引用指向对应的分支\n\n```shell\n$ git sw -b dev\nSwitched to a new branch 'dev'\n## 引用中多了dev\n$ find .git/ -type f\n.git/refs/heads/master\n.git/refs/heads/dev\n# HEAD 指向了dev分支\n$ more .git/HEAD\nref: refs/heads/dev\n\n#dev分支指向commit2\n$ more .git/refs/heads/dev\n014901f4a370ec3d0db58fc7a4cf9950d2111fbe\n\n```\n\n## 回退\n\n### 回退工作区\n\n```shell\n# 修改2.txt\n$ echo 'version 4' > 2.txt\n# 新增4.txt\n$ echo 'version 5' > 4.txt\n\n```\n\ngit diff 是用来比较缓存区和工作区的差异的，但仅比较已在 git 版本控制下的文件，即仅比较缓存区已经有的文件\n\n```shell\n$ git diff\ndiff --git a/2.txt b/2.txt\nindex 83baae6..96ac8f8 100644\n--- a/2.txt\n+++ b/2.txt\n@@ -1 +1 @@\n-version 1\n+version 4\n\n# 使用status可以看到新增还未添加到缓存区的文件\n$ git status\nOn branch dev\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n  modified:   2.txt\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n  4.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n# 我们尝试回退工作区改动\n$ git  checkout -- 2.txt\n# 发现无差异了\n$ git diff\n# 新增还未增加到缓存区的文件，可以直接rm删除即可\n```\n\n### 拉取别的分支或 commit 的文件\n\n`git checkout <branch> <file>`或`git checkout <branch> <file>`，分支的引用最终也指向一个 commit 对象，因此这两种方法都是类似的。\n\n```shell\n$ more 1.txt\nversion 1\n$ git checkout dev\n$ echo 'dev 1' >> 1.txt\n$ git add 1.txt\n$ git commit -m 'dev commit 3'\n\n# 查看提交历史记录\n$ git log --graph --pretty=oneline --abbrev-commit\n* c49b52f (HEAD -> dev) dev commit 3\n* 014901f (master) commit 2\n* 9f1224b (tag: V1.0) commit 1\n\n# 根据commit3的sha1查找到1.txt的内容\n$ git cat-file -p  c49b52f\ntree fc533492986c55db20a5c18d39c0fb9eb3412de5\nparent 014901f4a370ec3d0db58fc7a4cf9950d2111fbe\nauthor leaderli <429243408@qq.com> 1593605963 +0800\ncommitter leaderli <429243408@qq.com> 1593605963 +0800\n\ndev commit 3\n\n$ it cat-file -p fc5334\n100644 blob 258afb705ca6ffa8f0d56818ee9381cce55a2f8b 1.txt\n100644 blob 83baae61804e65cc73a7201a7252750c76066a30 2.txt\n040000 tree b57d4c5b3c1f31f87d0d5e7343db0b53f8f650c2 dir\n\n$ git cat-file -p 258afb\nversion 1\ndev 1\n\n# 同理，我们也可以看到commit1中1.txt的内容，省略细节\n$ git cat-file -p 83baae\nversion 1\n\n# 新增改动并添加到缓存区\n$ echo 'dev 2' >> 1.txt\n$ git add 1.txt\n# 新增改动不添加到缓存区\n$ echo 'dev 3' >> 1.txt\n\n# 查看缓存区内容\n$ git ls-files --stage\n100644 b5efe718e4230081f57ee53504d377652e3507ce 0 1.txt\n100644 83baae61804e65cc73a7201a7252750c76066a30 0 2.txt\n100644 7170a5278f42ea12d4b6de8ed1305af8c393e756 0 dir/3.txt\n$ git cat-file -p b5efe7\nversion 1\ndev 1\ndev 2\n\n# 工作区内容\n$ more 1.txt\nversion 1\ndev 1\ndev 2\ndev 3\n\n# 拉取commit1的1.txt\n$ git checkout 9f1224b 1.txt\n\n# 当前工作区内容\n$ more 1.txt\nversion 1\n\n# 当前缓存区内容\n$ git ls-files --stage\n100644 83baae61804e65cc73a7201a7252750c76066a30 0 1.txt\n100644 83baae61804e65cc73a7201a7252750c76066a30 0 2.txt\n100644 7170a5278f42ea12d4b6de8ed1305af8c393e756 0 dir/3.txt\n$ git cat-file -p 83baae\nversion 1\n\n# commit3无任何变动，可以看到工作区和缓存区的1.txt文件和commit1保持一致\n```\n\n### 撤销（reset）\n\ngit reset 首先是将 HEAD 指向的引用的 commit 对象修改为新的 commit 对象，然后根据参数（ `--soft`，`--mixed(default)`，`--hard`）的不同，决定是否同步缓存区和工作区的内容。\n\n大致的方式如下图所示\n![深入git_reset细节.png](./images/深入git_reset细节.png)\n\n我们通过实例验证\n\n```shell\n$ echo 'D' > state\n$ git add state\n$ git cm 'D'\n[dev 66b4377] D\n 2 files changed, 1 insertion(+), 1 deletion(-)\n create mode 100644 state\n$ echo 'C' > state\n$ git ca 'C'\n[dev 995cdd0] C\n 1 file changed, 1 insertion(+), 1 deletion(-)\n$ echo 'B' > state\n$ git add state\n$ echo 'A' > state\n\n$ git log --graph --pretty=oneline --abbrev-commit\n* 995cdd0 (HEAD -> dev) C\n* 66b4377 D\n* c49b52f dev commit 3\n* 014901f (master) commit 2\n* 9f1224b (tag: V1.0) commit 1\n\n# soft\n$ git reset --soft  66b4377\n\n# working dir\n$ more state\nA\n# stage\n$ git ls-files --stage\n100644 83baae61804e65cc73a7201a7252750c76066a30 0 1.txt\n100644 83baae61804e65cc73a7201a7252750c76066a30 0 2.txt\n100644 7170a5278f42ea12d4b6de8ed1305af8c393e756 0 dir/3.txt\n100644 223b7836fb19fdf64ba2d3cd6173c6a283141f78 0 state\n$ git cat-file -p 223b78\nB\n# HEAD 指向的是D的commit\nmore .git/refs/heads/dev\n66b4377d2633dfd8fde71e2d231c5e3843708ad9\n\n\n# mixed\n$ git reset --mixed  66b4377\n\n# working dir\n$ more state\nA\n# stage\n$ git ls-files --stage\n100644 83baae61804e65cc73a7201a7252750c76066a30 0 1.txt\n100644 83baae61804e65cc73a7201a7252750c76066a30 0 2.txt\n100644 7170a5278f42ea12d4b6de8ed1305af8c393e756 0 dir/3.txt\n100644 178481050188cf00d7d9cd5a11e43ab8fab9294f 0 state\n$ git cat-file -p 1784810\nD\n# HEAD 指向的是D的commit\nmore .git/refs/heads/dev\n66b4377d2633dfd8fde71e2d231c5e3843708ad9\n\n\n# hard\n$ git reset --hard 66b4377\n\n# working dir\n$ more state\nD\n# stage\n$ git ls-files --stage\n100644 83baae61804e65cc73a7201a7252750c76066a30 0 1.txt\n100644 83baae61804e65cc73a7201a7252750c76066a30 0 2.txt\n100644 7170a5278f42ea12d4b6de8ed1305af8c393e756 0 dir/3.txt\n100644 178481050188cf00d7d9cd5a11e43ab8fab9294f 0 state\n$ git cat-file -p 1784810\nD\n# HEAD 指向的是D的commit\nmore .git/refs/heads/dev\n66b4377d2633dfd8fde71e2d231c5e3843708ad9\n```\n","categories":["code"],"tags":["git","深入"]},{"title":"python-tips","url":"/2020/06/27/python-tips/","content":"\n## 截取字符串或数组\n\nw = '1'\n当使用 w[1:],会得到一个空串，而不会报错\n\n## python dict 根据 value 找对应的 key\n\n```python\ndicxx = {'a':'001', 'b':'002'}\nlist(dicxx.keys())[list(dicxx.values()).index(\"001\")]\n#'a'\n```\n\n## 使用守护进程的方式后台启动\n\n```shell\n# 后台启动\n$ python background_test.py >log.txt 2>&1 &\n```\n\n## 监听文件是否有变动\n\n```python\n# --coding:utf-8--\nimport os\nimport time\n\nfilename = '.'  # 当前路径\nlast = time.localtime(os.stat(filename).st_mtime)\nwhile True:\n    new_filemt = time.localtime(os.stat(filename).st_mtime)\n    if last != new_filemt:\n        last = new_filemt\n        print('change')\n        #os.system('nginx -s reload')\n    time.sleep(1)\n\n```\n","categories":["python"],"tags":["tips"]},{"title":"常用数学符号","url":"/2020/06/27/%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/","content":"\n## 数学希腊字母表\n\n| 大写 | 小写 | 希腊语  | 英语 | 发音        |\n| :--- | :--- | ------- | ---- | ----------- |\n| Α    | α    | Alpha   | a    | al-fa       |\n| Β    | β    | Beta    | b    | be-ta       |\n| Γ    | γ    | Gamma   | g    | ga-ma       |\n| Δ    | δ    | Delta   | d    | del-ta      |\n| Ε    | ε    | Epsilon | e    | ep-si-lon   |\n| Ζ    | ζ    | Zeta    | z    | ze-ta       |\n| Η    | η    | Eta     | h    | eh-ta       |\n| Θ    | θ    | Theta   | th   | te-ta       |\n| Ι    | ι    | Iota    | i    | io-ta       |\n| Κ    | κ    | Kappa   | k    | ka-pa       |\n| Λ    | λ    | Lambda  | l    | lam-da      |\n| Μ    | μ    | Mu      | m    | m-yoo       |\n| Ν    | ν    | Nu      | n    | noo         |\n| Ξ    | ξ    | Xi      | x    | x-ee        |\n| Ο    | ο    | Omicron | o    | o-mee-c-ron |\n| Π    | π    | Pi      | p    | pa-yee      |\n| Ρ    | ρ    | Rho     | r    | row         |\n| Σ    | σ    | Sigma   | s    | sig-ma      |\n| Τ    | τ    | Tau     | t    | ta-oo       |\n| Υ    | υ    | Upsilon | u    | oo-psi-lon  |\n| Φ    | φ    | Phi     | ph   | f-ee        |\n| Χ    | χ    | Chi     | ch   | kh-ee       |\n| Ψ    | ψ    | Psi     | ps   | p-see       |\n| Ω    | ω    | Omega   | o    | o-me-ga     |\n\n## 集合符号\n\nØ 空集合\n\n## 扬抑符（circumflexus）\n\n拉丁文字的扬抑符是个山形符号 ( ˆ )、而希腊文扬抑符则可以是波浪号 ( ˜ ) 或反转的短音符 ( ̑ ).在汉语拼音，ê 用来代表独立的 /ɛ/，通常用于\"欸、诶\"等叹词。在英文，扬抑符就如其他附加符号一样用于外来语，例如 rôle。此符号在数学也有有用，称为 hat(帽子)或 roof(屋顶)。\n\n例如：\n$\\hat{\\delta}$ 读作 hat delta\n","categories":["杂七杂八"],"tags":["数学"]},{"title":"ECharts简介","url":"/2020/06/25/ECharts%E7%AE%80%E4%BB%8B/","content":"\n## 安装\n\necharts 只需引入一个 js 文件即可\n\n```bash\nwget https://raw.githubusercontent.com/apache/incubator-echarts/4.8.0/dist/echarts.min.js\n```\n\n## 教程\n\n[官方教程](https://echarts.apache.org/zh/tutorial.html)已经说的非常详细了，这里只是摘抄一些简单的部分\n\necharts 的使用者，使用 option 来描述其对图表的各种需求，包括：有什么数据、要画什么图表、图表长什么样子、含有什么组件、组件能操作什么事情等等。简而言之，option 表述了：数据、数据如何映射成图形、交互行为。详情可见[option 详细配置](https://echarts.apache.org/zh/option.html#title)\necharts.setOption(option)可重复调用，仅覆盖更新，而不是整个替换 option。因此我们可以异步加载数据\n\n```javascript\nvar myChart = echarts.init(document.getElementById(\"main\"));\n\n$.get(\"data.json\").done(function (data) {\n  myChart.setOption({\n    title: {\n      text: \"异步数据加载示例\",\n    },\n    tooltip: {},\n    legend: {\n      data: [\"销量\"],\n    },\n    xAxis: {\n      data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"],\n    },\n    yAxis: {},\n    series: [\n      {\n        name: \"销量\",\n        type: \"bar\",\n        data: [5, 20, 36, 10, 10, 20],\n      },\n    ],\n  });\n});\n```\n\n当我们需要动态更新数据时，我们不断的调用 setOption 填充最新的数据即可。\n\n### 入门示例\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>ECharts</title>\n    <!-- 引入 echarts.js -->\n    <script src=\"echarts.min.js\"></script>\n  </head>\n  <body>\n    <!-- 为ECharts准备一个具备大小（宽高）的Dom -->\n    <div id=\"main\" style=\"width: 600px;height:400px;\"></div>\n    <script type=\"text/javascript\">\n      // 基于准备好的dom，初始化echarts实例\n      var myChart = echarts.init(document.getElementById(\"main\"));\n\n      // 指定图表的配置项和数据\n      var option = {\n        title: {\n          text: \"ECharts 入门示例\",\n        },\n        tooltip: {},\n        legend: {\n          data: [\"销量\"],\n        },\n        xAxis: {\n          data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"],\n        },\n        yAxis: {},\n        series: [\n          {\n            name: \"销量\",\n            type: \"bar\",\n            data: [5, 20, 36, 10, 10, 20],\n          },\n        ],\n      };\n\n      // 使用刚指定的配置项和数据显示图表。\n      myChart.setOption(option);\n    </script>\n  </body>\n</html>\n```\n\n这样你的第一个图表就诞生了！\n![ECharts简介_echarts入门示例.png](./images/ECharts简介_echarts入门示例.png)\n\n### echarts 实例\n\n一个网页中可以创建多个 echarts 实例。每个 echarts 实例 中可以创建多个图表和坐标系等等（用 option 来描述）。准备一个 DOM 节点（作为 echarts 的渲染容器），就可以在上面创建一个 echarts 实例。每个 echarts 实例独占一个 DOM 节点。\n\n### 组件（component）\n\n在系列之上，echarts 中各种内容，被抽象为“组件”。例如，echarts 中至少有这些组件：xAxis（直角坐标系 X 轴）、yAxis（直角坐标系 Y 轴）、grid（直角坐标系底板）、angleAxis（极坐标系角度轴）、radiusAxis（极坐标系半径轴）、polar（极坐标系底板）、geo（地理坐标系）、dataZoom（数据区缩放组件）、visualMap（视觉映射组件）、tooltip（提示框组件）、toolbox（工具栏组件）、series（系列）、...\n\n我们注意到，其实系列（series）也是一种组件，可以理解为：系列是专门绘制“图”的组件。\n\n如下图，右侧的 option 中声明了各个组件（包括系列），各个组件就出现在图中。\n![ECharts简介_组件细节.png](./images/ECharts简介_组件细节.png)\n\n### 坐标系\n\n一个坐标系，可能由多个组件协作而成。我们以最常见的直角坐标系来举例。直角坐标系中，包括有 xAxis（直角坐标系 X 轴）、yAxis（直角坐标系 Y 轴）、grid（直角坐标系底板）三种组件\n\nx 轴和 y 轴基本等同，下面介绍一些常用的配置\n\n1. type 坐标轴类型。\n   可选：\n   - `value` 数值轴，适用于连续数据。\n   - `category` 类目轴，适用于离散的类目数据。为该类型时类目数据可自动从 series.data 或 dataset.source 中取，或者可通过 xAxis.data 设置类目数据。\n   - `time` 时间轴，适用于连续的时序数据，与数值轴相比时间轴带有时间的格式化，在刻度计算上也有所不同，例如会根据跨度的范围来决定使用月，星期，日还是小时范围的刻度。\n   - `log` 对数轴。适用于对数数据。\n2. min 坐标轴刻度最小值。\n   可以设置成特殊值 'dataMin'，此时取数据在该轴上的最小值作为最小刻度。\n   不设置时会自动计算最小值保证坐标轴刻度的均匀分布。\n   在类目轴中，也可以设置为类目的序数（如类目轴 data: ['类 A', '类 B', '类 C'] 中，序数 2 表示 从'类 C'开始。也可以设置为负数，如 -3）表示第四个坐标为‘类 A’。\n   当设置成 function 形式时，可以根据计算得出的数据最大最小值设定坐标轴的最小值。如：\n\n   ```javascript\n   min: function (value) {\n       return value.min - 20;\n\n   }\n   ```\n\n   其中 value 是一个包含 min 和 max 的对象，分别表示数据的最大最小值，这个函数可返回坐标轴的最小值，也可返回 null/undefined 来表示“自动计算最小值”（返回 null/undefined 从 v4.8.0 开始支持）。\n\n3. max 坐标轴刻度最大值。类似 min\n4. splitNumber 坐标轴分割段数，需要注意的是这个分割段数只是个预估值，最后实际显示的段数会在这个基础上根据分割后坐标轴刻度显示的易读程度作调整。\n\n5. minInterval 自动计算的坐标轴最小间隔大小\n6. maxInterval 自动计算的坐标轴最大间隔大小\n\n一个 echarts 实例中，有多个 grid，每个 grid 分别有 xAxis、yAxis，他们使用 xAxisIndex、yAxisIndex、gridIndex 来指定引用关系：\n![ECharts简介_多grid.png](./images/ECharts简介_多grid.png)\n\n### dataset\n\nECharts 4 开始支持了 dataset 组件用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以基于数据指定数据到视觉的映射。这在不少场景下能带来使用上的方便\n\n#### 维度（dimension）\n\n常用图表所描述的数据大部分是“二维表”结构，上述的例子中，我们都使用二维数组来容纳二维表。现在，当我们把系列（series）对应到“列”的时候，那么每一列就称为一个“维度（dimension）”，而每一行称为数据项（item）。反之，如果我们把系列（series）对应到表行，那么每一行就是“维度（dimension）”，每一列就是数据项（item）。在 series 中我们可以使用属性 seriesLayoutBy 来决定按行还是按列做映射\n\n维度可以有单独的名字，便于在图表中显示。维度名（dimension name）可以在定义在 dataset 的第一行（或者第一列）。例如上面的例子中，'score'、'amount'、'product' 就是维度名。从第二行开始，才是正式的数据。dataset.source 中第一行（列）到底包含不包含维度名，ECharts 默认会自动探测。当然也可以设置 dataset.sourceHeader: true 显示声明第一行（列）就是维度，或者 dataset.sourceHeader: false 表明第一行（列）开始就直接是数据。\n\n维度的定义，也可以使用单独的 dataset.dimensions 或者 series.dimensions 来定义，这样可以同时指定维度名，和维度的类型（dimension type）：\n大多数情况下，我们并不需要去设置维度类型，因为会自动判断。但是如果因为数据为空之类原因导致判断不足够准确时，可以手动设置维度类型。\n\n维度类型（dimension type）可以取这些值：\n\n'number': 默认，表示普通数据。\n'ordinal': 对于类目、文本这些 string 类型的数据，如果需要能在数轴上使用，须是 'ordinal' 类型。ECharts 默认会自动判断这个类型。但是自动判断也是不可能很完备的，所以使用者也可以手动强制指定。\n'time': 表示时间数据。设置成 'time' 则能支持自动解析数据成时间戳（timestamp），比如该维度的数据是 '2017-05-10'，会自动被解析。如果这个维度被用在时间数轴（axis.type 为 'time'）上，那么会被自动设置为 'time' 类型。时间类型的支持参见 data。\n'float': 如果设置成 'float'，在存储时候会使用 TypedArray，对性能优化有好处。\n\n'int': 如果设置成 'int'，在存储时候会使用 TypedArray，对性能优化有好处。\n\n#### 数据到图形的映射（encode）\n\nencode 声明的基本结构如下，其中冒号左边是坐标系、标签等特定名称，如 'x', 'y', 'tooltip' 等，冒号右边是数据中的维度名（string 格式）或者维度的序号（number 格式，从 0 开始计数），可以指定一个或多个维度（使用数组）。通常情况下，下面各种信息不需要所有的都写，按需写即可。\n\n```javascript\n// 在任何坐标系和系列中，都支持：\nencode: {\n    // 使用 “名为 product 的维度” 和 “名为 score 的维度” 的值在 tooltip 中显示\n    tooltip: ['product', 'score']\n    // 使用 “维度 1” 和 “维度 3” 的维度名连起来作为系列名。（有时候名字比较长，这可以避免在 series.name 重复输入这些名字）\n    seriesName: [1, 3],\n    // 表示使用 “维度2” 中的值作为 id。这在使用 setOption 动态更新数据时有用处，可以使新老数据用 id 对应起来，从而能够产生合适的数据更新动画。\n    itemId: 2,\n    // 指定数据项的名称使用 “维度3” 在饼图等图表中有用，可以使这个名字显示在图例（legend）中。\n    itemName: 3\n}\n\n// 直角坐标系（grid/cartesian）特有的属性：\nencode: {\n    // 把 “维度1”、“维度5”、“名为 score 的维度” 映射到 X 轴：\n    x: [1, 5, 'score'],\n    // 把“维度0”映射到 Y 轴。\n    y: 0\n}\n\n```\n\n### series\n\n为了方便组织数据，我们统一使用 dataset 管理数据\n在 echarts 里，系列（series）是指：一组数值以及他们映射成的图，一个 系列 包含的要素至少有：\n\n#### 图表类型（series.type）、\n\n- line（折线图）\n- bar（柱状图）\n- pie（饼图）\n- scatter（散点图）\n- graph（关系图）\n- tree（树图）\n- ...\n\n#### 一组数值\n\n每个图表类型所需要的数据格式是不同的，例如\n![ECharts简介_每个系列说需要的数据.png](./images/ECharts简介_每个系列说需要的数据.png)\n\n如果 series.data 没有指定，并且 dataset 存在，那么就会使用 dataset。datasetIndex 指定本系列使用那个 dataset。\n\n#### 其他的关于这些数据如何映射成图的参数\n\n每个图标类型所提供的参数是有区别的，例如当使用 dataset 取数据时\n![ECharts简介_dataset取数据.png](./images/ECharts简介_dataset取数据.png)\n\n一些其他常用参数\n\n1. xAxisIndex 表示使用那个 x 轴坐标，默认指定第一个\n2. yAxisIndex 表示使用那个 y 轴坐标，默认指定第一个\n3. data 系列中的数据内容数组。数组项通常为具体的数据项。通常来说，数据用一个二维数组表示。如下，每一列被称为一个『维度』。\n\n   ```javascript\n   series: [\n     {\n       data: [\n         // 维度0(X)   维度1(Y)   其他维度 ...\n         [3.4, 4.5, 15, 43],\n         [4.2, 2.3, 20, 91],\n         [10.8, 9.5, 30, 18],\n         [7.2, 8.8, 18, 57],\n       ],\n     },\n   ];\n   ```\n\n   在 直角坐标系 (grid) 中『维度 X』和『维度 Y』会默认对应于 xAxis 和 yAxis。\n\n4. seriesLayoutBy 默认为'column'，可指定为'row'，则 dataset 中的二维数组每一行称为一个维度，对 data 无效\n5. encode 指定相关组件使用哪个维度\n   - x 表示维度\\*映射到 x 轴。\n   - y 表示维度\\*映射到 x 轴。\n   - tooltip 表示维度\\*映射到 tooltip\n6. dimensions 给维度命名，方便 encode 中可直接引用名称，而不是角标\n\n### 事件和行为\n\n在 ECharts 中事件分为两种类型，一种是用户鼠标操作点击，或者 hover 图表的图形时触发的事件，还有一种是用户在使用可以交互的组件后触发的行为事件，例如在切换图例开关时触发的 'legendselectchanged' 事件（这里需要注意切换图例开关是不会触发'legendselected'事件的），数据区域缩放时触发的 'datazoom' 事件等等。\n\nECharts 支持常规的鼠标事件类型，包括 'click'、'dblclick'、'mousedown'、'mousemove'、'mouseup'、'mouseover'、'mouseout'、'globalout'、'contextmenu' 事件\n\n如下是一个绑定点击操作的示例。\n\n```javascript\nmyChart.on(\"click\", function (params) {\n  // 控制台打印数据的名称\n  console.log(params.name);\n});\n```\n\n所有的鼠标事件包含参数 params，这是一个包含点击图形的数据信息的对象，如下格式\n\n```javascript\n{\n    // 当前点击的图形元素所属的组件名称，\n    // 其值如 'series'、'markLine'、'markPoint'、'timeLine' 等。\n    componentType: string,\n    // 系列类型。值可能为：'line'、'bar'、'pie' 等。当 componentType 为 'series' 时有意义。\n    seriesType: string,\n    // 系列在传入的 option.series 中的 index。当 componentType 为 'series' 时有意义。\n    seriesIndex: number,\n    // 系列名称。当 componentType 为 'series' 时有意义。\n    seriesName: string,\n    // 数据名，类目名\n    name: string,\n    // 数据在传入的 data 数组中的 index\n    dataIndex: number,\n    // 传入的原始数据项\n    data: Object,\n    // sankey、graph 等图表同时含有 nodeData 和 edgeData 两种 data，\n    // dataType 的值会是 'node' 或者 'edge'，表示当前点击在 node 还是 edge 上。\n    // 其他大部分图表中只有一种 data，dataType 无意义。\n    dataType: string,\n    // 传入的数据值\n    value: number|Array\n    // 数据图形的颜色。当 componentType 为 'series' 时有意义。\n    color: string\n}\n```\n\n使用 query 只对指定的组件的图形元素的触发回调：\n\n```javascript\nchart.on(eventName, query, handler);\n```\n\nquery 可为 string 或者 Object。\n\n1. 如果为 string 表示组件类型。格式可以是 'mainType' 或者 'mainType.subType'。例如：\n\n   ```javascript\n   chart.on('click', 'series', function () {...});\n   chart.on('click', 'series.line', function () {...});\n   chart.on('click', 'dataZoom', function () {...});\n   chart.on('click', 'xAxis.category', function () {...});\n   ```\n\n   这里的 mainType 即表示组件的名称，subType 表示鼠标事件中参数 componentType 的值\n\n2. 如果为 Object，可以包含以下一个或多个属性，每个属性都是可选的：\n\n   ```javascript\n   {\n   <mainType>Index: number // 组件 index\n   <mainType>Name: string // 组件 name\n   <mainType>Id: string // 组件 id\n   dataIndex: number // 数据项 index\n   name: string // 数据项 name\n   dataType: string // 数据项 type，如关系图中的 'node', 'edge'\n   element: string // 自定义系列中的 el 的 name\n   }\n   ```\n\n   例如\n\n   ```javascript\n   chart.setOption({\n     // ...\n     series: [\n       {\n         name: \"uuu\",\n         // ...\n       },\n     ],\n   });\n   chart.on(\"mouseover\", { seriesName: \"uuu\" }, function () {\n     // series name 为 'uuu' 的系列中的图形元素被 'mouseover' 时，此方法被回调。\n   });\n   ```\n","categories":["javascript"]},{"title":"nginx入门","url":"/2020/06/19/nginx%E5%85%A5%E9%97%A8/","content":"\n## 安装\n\n基于 centos\n\n1. 安装依赖工具\n   `sudo yum install yum-utils`\n2. 配置 yum 的源\n   新建文件`/etc/yum.repos.d/nginx.repo`，并写入以下内容\n\n   ```properties\n   [nginx-stable]\n   name=nginx stable repo\n   baseurl=http://nginx.org/packages/centos/$releasever/$basearch/\n   gpgcheck=1\n   enabled=1\n   gpgkey=https://nginx.org/keys/nginx_signing.key\n   module_hotfixes=true\n\n   [nginx-mainline]\n   name=nginx mainline repo\n   baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/\n   gpgcheck=1\n   enabled=0\n   gpgkey=https://nginx.org/keys/nginx_signing.key\n   module_hotfixes=true\n   ```\n\n3. 若需要安装最新版，而非调试版本\n   `sudo yum-config-manager --enable nginx-mainline`\n4. 安装 nginx\n   `sudo yum install nginx`\n\n## 启动\n\nnginx 有一个 master 线程和多个 worker 进程，master 进程用来读取，解析配置文件以及管理 worker 进程，worker 进程才是真正处理请求的进程。worker 进程的个数可通过配置文件去配置或自动设置为 cpu 的核心数。可通过修改配置设定\n\n```nginx\nworker_processes 1;\n```\n\n使用`nginx`即可启动,一旦 nginx 启动，就可以使用如下命令去控制 nginx\n\n> nginx -s signal\n\n- stop — fast shutdown\n- quit — graceful shutdown\n- reload — reloading the configuration file\n- reopen — reopening the log files\n\n当更改配置文件后，可以使用`nginx -s reload`，使配置文件生效。\n当 master 进程接收到 reload 的信号后，它首先会校验配置文件语法是否正确然后才会接收新的配置文件，若配置文件修改成功，master 进程会启动新的 worker 进程，并向旧的 worker 进程发送停止命令，旧的 worker 进程会以旧的配置处理请求，在处理完旧的请求后便会退出。\n\n## 配置\n\n### 可用变量\n\n[官方文档可用变量](http://nginx.org/en/docs/http/ngx_http_core_module.html#variables)\n\n常用变量\n\n- `$arg_<name>` url 请求请求参数 name 的值\n- `$query_string` url 整个请求参数字符串，即`?`后面的参数,例如:`a=1&b=2`\n- `$upstream_http_<header>` 返回报文的头,header 请求头的名称\n- `$http_<header>` 请求报文的头,header 请求头的名称\n\n### 配置文件结构\n\nnginx 的配置文件名为 nginx.conf,一般位于目录/usr/local/nginx/conf, /etc/nginx, 或 /usr/local/etc/nginx.下\nnginx 的组件由配置文件中的指令构成，指令的基本格式有两种\n\n1. 简单的命令：由 name 和 parameters 以及`；`结尾\n2. 块命令： 由 name 和一个由大括号`{}包裹的命令的集合，同时也被称为 context\n3. \\#后面的视为注释\n4. 不在任何 context 内的命令则被视为在 [main context](http://nginx.org/en/docs/ngx_core_module.html)中\n\n## 监听请求\n\n我们通过配置[server](http://nginx.org/en/docs/http/ngx_http_core_module.html#server)来处理请求\n\n例如：\n\n```nginx\nserver {\n    listen      80;\n    server_name example.org www.example.org;\n    ...\n}\n\nserver {\n    listen      80;\n    server_name example.net www.example.net;\n    ...\n}\n\nserver {\n    listen      80;\n    server_name example.com www.example.com;\n    ...\n}\n```\n\n其中`port`表示监听的端口号，`server_name`表示监听的`host`（即 IP 地址或域名地址），server_name 与 host 匹配的优先级关系如下\n\n1. 完全匹配\n2. 通配符在前的，如\\*.test.com\n3. 在后的，如 www.test.\\*\n4. 正则匹配，如~^\\.www\\.test\\.com\\$\n\n如果都不匹配\n\n1. 优先选择 listen 配置项后有 default 或 default_server 的\n2. 找到匹配 listen 端口的第一个 server 块\n\n通过`curl -v`，我们可以看到 host\n\n## 处理请求\n\n在[server](http://nginx.org/en/docs/http/ngx_http_core_module.html#server)下配置[location](http://nginx.org/en/docs/http/ngx_http_core_module.html#location)\n\n1. `location = /uri` 　　　`=`开头表示精确匹配，只有完全匹配上才能生效。\n2. `location ^~ /uri` 　　`^~` 开头对 URL 路径进行前缀匹配，并且在正则之前。\n3. `location ~ pattern` 　`~`开头表示区分大小写的正则匹配。\n4. `location ~* pattern` 　`~*`开头表示不区分大小写的正则匹配。\n5. `location /uri` 　　　　不带任何修饰符，也表示前缀匹配，但是在正则匹配之后。\n6. `location /` 　　　　　通用匹配，任何未匹配到其它 location 的请求都会匹配到，相当于 switch 中的 default。\n\n### 映射静态资源\n\nroot 指向静态资源的路径\nindex 默认首页\n\n```nginx\nserver {\n   listen 8888;\n   server_name \"test\";\n   location ~ \\.(gif)$ {\n         root /home/li/tomcat/webapps/manager;\n         index index.html;\n   }\n}\n```\n\n### 增加请求头\n\n配置，这样在服务器端的 headers 中就可以看到名为 name 的指定 header，需要注意的是，当值为空时，nginx 不会发送该请求头\n\n```nginx\nserver {\n   listen 18080;\n   location / {\n      proxy_pass http://f5;\n      proxy_set_header name $arg_name;\n\n   }\n}\n```\n\n## 负载均衡\n\n### 测试用脚本\n\n一个测试用的 http 服务端程序\n\n```python\n# --coding:utf-8--\n\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom os import path\nimport sys\nfrom urllib.parse import urlparse\n\nport = 8081\nclass Handler(BaseHTTPRequestHandler):\n\n    def do_GET(self):\n        global port\n        self.send_response(200)\n        self.send_header('Content-type', 'text/plain')\n        self.send_header('port', port)\n        self.end_headers()\n        self.wfile.write(b'')\n        print(port,self.headers.get('Host'), self.path,flus\nh=True)\n\n    def do_POST(self):\n        self.do_Get()\n\n\ndef run():\n    if len(sys.argv) > 1:\n        global port\n        port = int(sys.argv[1])\n        print('port',port)\n    server_address = ('', port)\n    httpd = HTTPServer(server_address, Handler)\n    print('running server...', port)\n    httpd.serve_forever()\n\n\nif __name__ == '__main__':\n    run()\n\n```\n\n启动多个 http 服务的 shell 脚本\n\n```shell\nstart(){\n echo 'start'$1\n python http_nginx.py  $1 >> nginx.log  2>&1 &\n echo \"kill -9 $! # $1\" >> nginx.pid\n}\nstop(){\necho 'stop'\nps -ef|grep http_nginx|grep -v grep|grep -v start|awk '{print \"kill -\n9 \"$2}'|sh\n}\n\nstop\ntouch nginx.log\ntouch nginx.pid\n:>nginx.log\n:>nginx.pid\n\nargs=$@\nif [ ! -n \"$args\" ] ;then\n  args='18081 18082 18083'\nfi\nfor arg in $args\ndo\n  start $arg &\ndone\n\ntail -f nginx.log\n\n```\n\n### 负载均衡与 session 保持\n\n```nginx\nupstream f5 {\n\n   hash $arg_a;\n   server localhost:18081;\n   server localhost:18082;\n   server localhost:18083;\n}\nserver {\n   listen 18080;\n   location / {\n      proxy_pass http://f5;\n\n      }\n}\n\n```\n\n使用测试脚本不断访问\n\n```shell\nwhile [ 1 ]\ndo\ncurl localhost:18080/hello?a='123456&b=abc'\nsleep 1\ndone\n```\n\n通过观察 http 服务端的日志输出，我们可以发现所有请求都指向了同一个服务器\n\n当请求 url 不带参数`a`时，可以观察到所有请求均衡的分配在每台服务器上\n\n> 18082 f5 /hello\n> 18081 f5 /hello?a=123456&b=abc\n> 18083 f5 /hello\n> 18081 f5 /hello?a=123456&b=abc\n> 18081 f5 /hello\n> 18082 f5 /hello\n> 18081 f5 /hello?a=123456&b=abc\n> 18083 f5 /hello\n> 18081 f5 /hello?a=123456&b=abc\n\n**_当负载服务器停止服务时，nginx 会自动重新计算 hash_**\n\n## 日志\n\n我们可配置`http|log_format`来控制 nginx 的 access_log 日志的输出内容,你可以打印所有 nginx 中有关的变量值\n\n```nginx\nhttp {\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ''\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    access_log  /var/log/nginx/access.log  main;\n}\n```\n","categories":["linux"],"tags":["nginx"]},{"title":"iterm2","url":"/2020/06/19/iterm2/","content":"\n### 切换编辑模式\n\n```shell\n# Emacs mode\nbindkey -e\n\n# Vi mode\nbindkey -v\n```\n\n## 自动完成\n\niTerm2 可以自动补齐命令，输入若干字符，按 ⌘+;弹出自动补齐窗口，列出曾经使用过的命令\n\n## 分屏\n\n垂直分屏：command + d\n\n水平分屏：command + shift + d\n\n切换屏幕：command + option + 方向键 command + [ 或 command + ]\n\n根据编号切换屏幕\n![iterm2_根据编号切换.png](./images/iterm2_根据编号切换.png)\n","categories":["工具"]},{"title":"有限状态机","url":"/2020/06/15/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/","content":"\n## 概念\n\n有限状态机简称状态机，状态机表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。通俗的描述就是状态机定义了一套状态变更的流程：状态机包括一个状态集合，定义当状态机处于某一个状态的时候它所能接收的事件以及可执行的行为，执行完成后状态机所处的状态。状态机包含以下几个重要的元素：\n\n- State：状态。一个标准的状态机最少包括两个状态：初态和终态。初态是状态机初始化后所处的状态，而终态就是状态机结束时所处的状态。其他的状态都是一些流转中停留的状态。\n- Event：事件。执行某个操作的触发器或者口令\n- Action：行为。状态变更所要执行的具体行为\n- Transition：变更。一个状态接收一个事件执行了某些行为到达了一个状态的过程。它表示状态机的运转流程。\n\n## 应用场景\n\n状态机主要的应用场景就是流程控制。一个状态机定义以后，在某个状态下就只接收固定的 Event，也就是执行指定的操作，这样流程就能按照预期定义的那样流转，不会出现乱入的情况，执行了一些在某个状态下不允许执行的操作。\n\n## 示例\n\n> 编写一个程序，以每行一个单词的形式打印其输入\n\n我们使用状态机的思想来解决这个问题\n\n状态集：当前字符在单词内记做 IN，当前字符不在单词内记做 OUT，初态为 OUT\n当前状态为 IN 时：若当前字符为空白字符（空格，制表，换行符），则输出换行并改变状态为 OUT，否则输出字符并保持状态为 IN\n当前状态为 OUT 时：若当前字符为空白字符（空格，制表，换行符），则保持状态为 OUT，否则输出字符并改变状态为 IN\n","categories":["计算机基础"],"tags":["设计模式"]},{"title":"voicexml解析器实现相关","url":"/2020/06/10/voicexml%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%85%B3/","content":"\n## 概述\n\nIVR 系统的测试一般需要电话或软电话，拨号经由呼叫中心平台进入 IVR 系统进行测试，这种测试方式比较慢，且无法进行自动化测试。呼叫中心平台与 IVR 系统的交互使用[VoiceXML](https://www.w3.org/TR/voicexml21/)标准协议，通过编写一个简易的 VoiceXML 解析器，实现对 IVR 系统的模拟请求与根据返回报文自动执行。\n\n## 指令集\n\n通过模仿计算机组成原理的相关知识，我们将每个标签转化为一个由操作码，操作数（一个或多个）的基本操作指令。\n\n精简的 VoiceXML 报文示例\n\n```xml\n<vxml version=\"2.1\">\n    <var name=\"_avayaExitReason\" expr=\"''\"/>\n    <var name=\"_avayaExitInfo1\" expr=\"''\"/>\n    <var name=\"_avayaExitInfo2\" expr=\"''\"/>\n    <var name=\"_avayaExitCustomerId\" expr=\"''\"/>\n    <var name=\"_avayaExitPreferredPath\" expr=\"'1'\"/>\n    <var name=\"_avayaExitTopic\" expr=\"''\"/>\n    <var name=\"_avayaExitParentId\" expr=\"''\"/>\n    <catch event=\"error.runtime\">\n        <goto  next=\"example\"/>\n    </catch>\n    <form>\n        <block>\n            <throw event=\"error.runtime.Exception\"/>\n        </block>\n    </form>\n    <block>\n    </block>\n</vxml>\n```\n\n上述报文，我们可以定义出以下操作指令\n\n- [ \"var\" , \"_avayaExitReason\" , \"''\" ]\n- [ \"catch\" , \"error.runtime\" , 0 ]\n- [ \"goto\" , \"example\" ]\n- [ \"form\" , 0 ]\n- [ \"block\" ]\n- [ \"throw\" , \"error.runtimeException\" ]\n\nvxml 中标签从上向下顺序执行，若子标签内有其他标签，会先进入子标签内执行，即以深度优先遍历的方式生成指令集。有些标签执行需要满足条件，若`catch`，需要当前有对应的事件抛起时，才会进入标签内执行，所以我们还需要在`catch`处，计算当条件不满足时，下一条指令的位置。按照上文的 demo 报文，我们可以生成如下报文；\n\n0. `var _avayaExitReason ''`\n1. `var _avayaExitInfo1 ''`\n2. `var _avayaExitInfo2 ''`\n3. `var _avayaExitCustomerId ''`\n4. `var _avayaExitPreferredPath '1'`\n5. `var _avayaExitTopic ''`\n6. `var _avayaExitParentId ''`\n7. `catch error.runtime 9`\n8. `goto example`\n9. `form 12`\n10. `block 12`\n11. `throw error.runtime.Exception`\n12. `end`\n\n当报文比较复杂时，我们很难从生成的指令集中很好的观察流程走向，且难以观察程序的层级结构，一些特殊标签，例如 catch（捕获当前标签内抛出的事件，若没有合适的 catch 去处理，则转交父标签处理） 标签的功能难以实现。\n\n## 广度遍历优先\n\n所以我们使用广度优先遍历的方式去生成指令集，在遇到有子标签的情况，我们插入一条`Call`指令，以调用子程序的方式去解释执行子标签，同时在子标签指令集尾部，插入 `Return`指令，使其返回调用子程序处。通过这种方式产生的报文如下：\n\n0. `var _avayaExitReason ''`\n1. `var _avayaExitInfo1 ''`\n2. `var _avayaExitInfo2 ''`\n3. `var _avayaExitCustomerId ''`\n4. `var _avayaExitPreferredPath '1'`\n5. `var _avayaExitTopic ''`\n6. `var _avayaExitParentId ''`\n7. `catch error.runtime`\n8. `call 12`\n9. `form`\n10. `call 14`\n11. `end`\n12. `goto example`\n13. `return 9`\n14. `block 12`\n15. `call 17`\n16. `return 11`\n17. `throw error.runtime.Exception`\n18. `return 16`\n\n这样的报文结构清晰，容易理解，且可以使用栈来实现子程序的调用。例如：我们可以在执行 call 指令时，向下扫描所有 catch，直到 return，这样我们就可以得到当前作用域的所有 catch 事件\n\n下面是示例代码\n\n```java\nprivate void scan(List<Object[]> cmd, DOMElement tag, int callPC) {\n    List<Runnable> delayScans = new ArrayList<>();\n    List<DOMElement> elements = tag.elements();\n    for (DOMElement element : elements) {\n\n        Object[] current = new Object[]{element.getTagName()};\n        cmd.add(current);\n        List<DOMElement> child = element.elements();\n        if (child.size() > 0) {\n            Object[] call = new Object[]{\"call\", 0};\n            cmd.add(call);\n            //记录子程序入口指针位置\n            int after = cmd.size();\n            //子程序先不扫描，先遍历当前层级的标签\n            delayScans.add(() -> {\n                call[1] = cmd.size();\n                scan(cmd, element, after);\n\n            });\n        }\n\n    }\n    //当前标签遍历解释，插入一条返回call的指令\n    cmd.add(new Object[]{\"return\", callPC});\n    //继续子程序的扫描\n    delayScans.forEach(Runnable::run);\n}\n\nList<Object[]> operators = new ArrayList<>();\noperators.add(new Object[]{\"call\", 2});\noperators.add(new Object[]{\"end\",});\nscan(operators, root, 1);\n```\n\n## 中断系统\n\n为了及时处理事件或 I/O 工作，我们需要在解析器在出现抛出事件，需要打印或者输入参数时，暂时中断现行程序，转而去执行中断服务程序，那么就要求我们设定的指令执行周期尽可能小，在一条原子性指令执行结束后去判断是否需要响应中断事件。\n","categories":["ivr"],"tags":["voicexml","xml"]},{"title":"计算机组成笔记","url":"/2020/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%AC%94%E8%AE%B0/","content":"\n学习计算机组成原理，是为了了解计算机底层解决各种问题的思路，以供模仿这些思路写出更好的代码。重点关注指令执行的整个过程。\n\n## 名词解释\n\n### 位，字节，字\n\n- **_位_**\n  在计算机中,数据只用 0 和 1 两种表现形式,(这里只表示一个数据点,不是数字),一个 0 或者 1 占一个“位”。\n- **_字节_**\n  而系统中规定 8 个“位”为一个“字节”.\n- **_字长_**\n  而一个字的位数，是由机器字长决定的【系统硬件（总线、cpu 命令字位数等）】\n  1. 在 16 位的系统中（比如 8086 微机） 1 字 （word）= 2 字节（byte）= 16（bit）\n  2. 在 32 位的系统中（比如 win32） 1 字（word）= 4 字节（byte）=32（bit）\n  3. 在 64 位的系统中（比如 win64）1 字（word）= 8 字节（byte）=64（bit）\n\n## 总线\n\n总线是连接计算机多个部件的信息传输线，是各个部件共享数据的传输介质。当多个部件与总线相连时，如果出现两个或两个以上部件同时向总线发送信息，势必导致信号冲突，传输无效。因此，在某一时刻，只允许有一个部件向总线发送信息，而多个部件可以同时从总线上接收相同的信息。\n\n总线实际上是由许多传输线或通路组成，每条线可一位一位的传输二进制码，一串二进制码可在同一段时间内在一条传输线上逐一传输，也可同时在多条传输线同时传输，例如 16 条传输线组成的总线可以同时传输 16 位二进制代码。\n\n根据总线传输信息的不同，可分为三类：\n\n1. **_数据总线_**\n   数据总线用来传输各功能部件之间的数据信息，它是双向传输总线，其位数与机器字长，存储字长有关，一般为 8 位，16 位或 32 位。数据总线的位数称为数据总线宽度。如果数据总线的宽度为 8 位，指令字长为 16 位，那么 CPU 在取指阶段必须两次访问主存。\n2. **_地址总线_**\n   地址总线主要用来指出数据总线上的源数据或目的数据在主存单元的地址或者 I/O 设备的地址。例如，欲从存储器读出一个数据，则 CPU 要将此数据所在存储单元的地址送到地址线上。地址总线上的代码总是用来指明 CPU 欲访问的存储单元或者 I/O 端口的地址，由 CPU 输出，单向传输。地址线的位数与存储单元的个数有关。如地址线为 20 根，则对应的存储单元个数为$2^{20}$\n3. **_控制总线_**\n   由于数据总线，地址总线都是被挂载总线上的所有部件共享的，如何使各部件能在不同时刻占用总线使用权，需要依靠控制总线来完成。因此控制总线是用来发出各种控制信号的传输线。每根控制线的控制信号时固定的，它的传输是单向的。但对于控制总线整体来说，又可以认为是双向的。\n   常见的控制信号如下\n   - 时钟：用来同步各种操作\n   - 复位：初始化所有部件\n   - 总线请求：表示某部件需获得总线控制权\n   - 总线允许： 表示需要获得总线控制权的部件已经获得了控制权\n   - 中断请求： 表示某个部件提出中断请求\n   - 中断响应： 表示中断请求已被接收\n   - 存储器写： 将数据总线上的额数据写至存储器的指定单元地址内\n   - 存储器读： 将指定存储单元中的数据读到数据总线上\n   - I/O 读：从指定 I/O 端口将数据读到数据总线上\n   - I/O 写：将数据总线上的数据输出到指定的 I/O 端口内\n   - 传输响应： 表示数据已被接收，或已将数据送到数据总线上\n\n众多部件共享总线，在争夺总线使用权时，应按各部件的优先等级来解决。在通信时间上，则应按分时方式来处理，即以获得总线使用权的先后顺序分时占用总线，即哪一个部件获得使用权，此刻就由它传送，下一个部件获得使用权，接着下一时刻传送。这样一个接一个轮流交替传送。\n\n## 存储器\n\n存储器的层级结构\n![计算机组成笔记_2020-06-09-21-16-32.png](./images/计算机组成笔记_2020-06-09-21-16-32.png)\n缓存-主存层次主要解决 CPU 和主存速度不匹配的问题\n\n### 主存\n\n计算机为了实现能按地址访问主存，主存中还必须配置两个寄存器 MAR 和 MDR。MAR（Memory Address Register）是存储地址的寄存器，其位数对于存储单元的个数(如 MAR 为 10 位，则有$2^{10}=1024$个存储单元，记做 1K）。MDR（Memory Data Register）是存储数据的寄存器，其位数与存储字长相等。主存的工作方式是根据存储单元的地址号来实现对存储字各位的存(写入),读(取出)。\n\n当要从存储器读出某一个信息字时，首先由 CPU 将该字的地址送到 MAR，经地址总线送至主存，然后发出读命令。主存接到读命令后，得知需将该地址单元的内容读出，变完成读操作，将该单元的内容读至数据总线上，至于该信息由 MDR 送到什么地方，这已经不是主存的任务，而是有 CPU 决定的。若要想主存存入一个信息字时，首先 CPU 将该字所在主存单元的地址经 MARD 送到地址总线，并将该信息送入 MDR，然后向主存发出写命令，主存接到写命令后，便将数据线上的信息写入到对应地址线指出的主存单元中。\n\n主存各存储单元的空间位置是由单元地址号来表示的，而地址总线时用来指出存储单元地址号的，根据该地址号可读出或写入一个存储字，不同的机器存储字长也不同，为了满足字符处理的需要，常用 8 位二进制表示一个字节，因此存储字长都取 8 的倍数。\n\n### 缓存\n\n主存有$2^{n}$个可编制的字组成，每个字有唯一的 n 位地址。为了与 Cache 映射，将主存与缓存都分为若干块，每块内又包含若干个字，并使他们的快大小相同（即块内的自述相同）。这就将主存的地址分为两段：高 m 位表示主存的块地址，低 b 位表示块内地址，则$2^{m}=M$表示主存的块数。同样缓存的地址也分为两段：高 c 位表示主存的块地址，低 b 位表示块内地址，则$2^{c}=C$表示缓存块数，且 C 远小于 M。主存与缓存地址中都用 b 为表示其块内自出，即$B=2{b}$反映了块的大小，称 B 为块长。\n任何时刻都有一些主存块处于缓存块中。CPU 欲读取主存某字时，有两种可能：一种是所需要的字已在缓存 zhong ，即可直接访问 cache（CPU 与 Cache 之间通常一次传送一个字）；另外一种是所需要的字不在 cache 内，此时将该字所在准成整个字块一次调用 cache 中（cache 与主存直接时 **_字块_** 传送）。如果主存块已调用缓存块，则成该主存块与缓冲块建立了对应关系。\n\ncache 的基本结构\n![计算机组成笔记_2020-06-09-21-46-46.png](./images/计算机组成笔记_2020-06-09-21-46-46.png)\n\ncache 的模块组成\n\n1. cache 存储体以块为单位与主存交换信息，现代计算机一班提供多级缓存。\n2. 地址映射变换机制，将 CPU 送来的主存地址转换为 cache 地址\n3. 替换机制，当缓存内容已满时，使用替换算法决定那块缓存需要被替换掉\n4. 读写操作，读时优先从 cache 读取。写现在主要有两种方式：\n   - 写直达法，即写操作时既写入 cache，也写入主存\n   - 写回法，即写操作时只把数据写入 cache，但数据被替换时才写入主存\n\n## 机器指令\n\n机器语言是由一条条语句构成的，每一条语句又能准确表达某种语义。计算机就是连续执行每一机器语句而实现全自动工作的。\n\n### 指令字长\n\n指令字长取决于操作码的长度，操作数地址的长度和操作数地址的个数。通常把常用的指令（如数据传送指令，算逻辑运算指令等）设计成单子长或者短字长格式的指令。\n\n### 指令格式\n\n指令是由操作码和地址码两部分组成的，基本格式如下\n![计算机组成笔记_2020-06-09-23-09-06.png](./images/计算机组成笔记_2020-06-09-23-09-06.png)\n\n1. 操作码\n   用来指定指明该指令所要完成的操作，如加法，减法，传送，移位，转移等。通常，其位数反映了机器的操作种类，也即机器允许的指令条数，如操作码占 7 位，则该机器最多包含 $2^{7}=128$条指令。\n\n2. 地址码\n   地址码用来指出该指令的源操作数的地址(一个或两个),结果的地址以及下一条指令的地址。这里的地址可以时主存的地址，也可以是寄存器的地址，甚至可以时 I/O 设备的地址。\n\n指令格式集中体现了指令系统的功能，因此在确定指令格式时，必须从以下几个方面综合考虑\n\n1. 操作类型：包括指令数及操作的难以程度\n2. 数据类型：确定哪些数据可以参与操作\n3. 指令格式：包括指令字长，操作码位数，地址码位数，地址个数，寻址方式类型，以及指令字长和操作码是否可变等\n4. 寻址方式： 包括指令和操作数具有哪些寻址方式\n5. 寄存器个数：寄存器的多少直接影响指令的执行时间\n\n## 操作数与操作类型\n\n### 数据在存储器中的存放方式\n\n通常计算机的数据存放在存储器或寄存器中，而寄存器的位数便可反映机器字长。一般机器字长可取字节的 1、2、4、8 倍，这样便于字符处理，现代计算机机器字长发展到 32 位和 64 位。为了便于硬件实现，通常对多字节的数据在存储器的存放方式能满足 **_边界对齐_** 的要求，即所存的数据总是整数倍（半字地址是 2 的整数倍，字地址是 4 的整数倍，双字地址是 8 的整数倍），当所存数据不满足此要求时，可填充一个或多个空白字节。\n\n### 操作类型\n\n1. 数据传送：各个存储单元之间进行读写操作\n2. 算术逻辑操作：加减乘除，与或非等\n3. 移位：算术移位，逻辑移位等\n4. 转移：\n   - 无条件转移：不受任何条件的约束，可直接将程序转移到下一条需要执行指令的地址\n   - 条件转移：根据当前指令的执行结果来决定是否需要转移，若条件满足，则翻译，若条件不满足，则继续按顺序执行\n   - 调用与返回：在编写程序时，有些具有特定功能的程序段会被反复使用。为避免重复编写，可将这些程序段设定为独立子程序，当需要执行子程序时，只需要用子程序调用指令即可。\n5. 输入输出：对于 I/O 单独编制的计算机而言，通常舍友输入输出指令，它完成从外设中的寄存器读入一个数据到 CPU 的寄存器内，或将数据从 CPU 的寄存器输出到某外设的寄存器中。\n   - 陷阱指令\n6. 其他包括等待指令，停机指令，空操作指令，开中断指令，关中断指令等。\n\n### 调用子程序细节\n\n调用指令（CALL）一般与返回指令（RETURN）配合使用。CALL 用于从当前的程序位置转至子程序的入口，RETURN 用于子程序执行完成后重新返回到源程序的断点。下图示意了调用（CALL）与返回（RETURN）指令在程序执行中的流程\n![计算机组成笔记_2020-06-09-23-52-28.png](./images/计算机组成笔记_2020-06-09-23-52-28.png)\n\n需要注意以下几点\n\n1. 子程序可在多处被调用\n2. 每个 CALL 指令都对应一条 RETURN 指令\n3. CPU 必须记住返回地址，返回地址可存放在以下三处\n   - 专用寄存器内\n   - 子程序的入口地址内\n   - 栈顶内。现代计算机都设有堆栈，执行 RETURN 指令后，变可自动从栈顶取出相应的返回地址\n\n### 操作数类型\n\n指令中常用的操作数类型有\n\n1. 地址：地址实际上也是一种数据，在许多情况下需要计算操作数的地址。这时地址可以被认为是一个无符号的整数。\n2. 数字：计算机常见的数字有定点数，浮点数和十进制数。\n3. 字符：文本或字符串是一种常见的数据类型，计算机在处理信息过程中普遍才有 ASCII 码存储字符\n4. 逻辑数据： 用于进行逻辑运算的布尔类型的数据。\n\n## 寻址方式\n\n寻址方式是指在确定本条指令的数据地址以及下一条将要执行的指令地址的方法，它与硬件结构紧密相关，寻址方式分为指令寻址和数据寻址两大类。\n\n### 指令寻址\n\n1. 顺序寻址：通过程序计数器 PC（指令的在内存中的地址） 加 1，自动形成下一条指令的地址\n2. 跳跃寻址：将程序计算器 PC 跳跃到指定的指令地址\n\n### 数据寻址\n\n种类较多，在指令字中必须设一字段来表面当前属于哪一种寻址方式。指令的地址码字段通常都不代表操作数的真实地址，把他称作为形式地址记作 A，操作数的真实地址称为有效地址记作 EA，它是由寻址方式和寻址形式地址共同来确定的\n![计算机组成笔记_数据寻址方式.png](./images/计算机组成笔记_数据寻址方式.png)\n\n1. 立即寻址：特点是操作数本身设在指令字内，即形式地址 A 不是操作数的地址，而是操作数本身，又称之为立即数\n2. 直接寻址：特点是指令字中的形式地址 A 就是操作数的真实地址 EA\n3. 隐含地址：是指指令字中不明显给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中。隐含地址有利于缩短指令字长\n4. 间接寻址：是指指令的 **_形式地址_**不直接指出操作数的地址，而是指出操作数的有效地址所在的存储单元地址，也就是说有效地址是由形式地址间接提供的。间接寻址可很方便的完成子程序返回。\n5. 寄存器寻址\n6. 寄存器间接寻址\n7. 基址寻址：设有基址寄存器 BR，其操作的有效地址 EA 等于指令字中的形式地址和基址寄存器的内容相加，即 $EA = A + (BR)$。操作系统控制基址寄存器的值，在执行过程中基址寄存器的值不变，基址寻址主要用于多道程序，程序无需关注实际物理地址，只需指定使用哪一个寄存器作为基址寄存器即可。\n8. 变址寻址：其有效地址等于 EA 等于形式地址 A 与变址寄存器 IX 相加，$EA = A + (IX)$，指令在的 A 不可变，变址寄存器的内容由用户设定，在执行过程中其值可变，主要用于为程序或数据分配连续存储空间，特别适合数组等循环程序.基址寻址和变址寻址本质上是一样的，只是表现形式不同。\n9. 相对寻址：相对寻址的有效地址是将程序计数器 PC 的值（即当前指令的地址）与形式地址 A 相加而成。$ EA = (PC) +A $,相对寻址的最大特点是转移地址不固定，它可随 PC 值的变化而变。\n10. 堆栈寻址：堆栈寻址要求计算机中设有堆栈，堆栈即可用寄存器组（硬堆栈）来实现，也可利用主存的一部分空间作为堆栈(软堆栈)。以软堆栈为例，可用堆栈指针 SP（stack point）指出栈顶地址，操作数只能从栈顶地址指示的存储单元存或取。堆栈寻址也可视为一种隐含寻址。\n\n## CPU 结构\n\n根据 CPU 的功能不难设想\n\n1. 要取指令，必须有一个寄存器专用于存放当前指令的地址。\n2. 要分析指令，必须有存放当前指令和对指令操作码进行转译的部件\n3. 要执行指令，必须有一个能发出各种操作命令序列的控制部件 CU\n4. 要完成算术运算和逻辑运算，必须有存放操作数的寄存器和实现逻辑运算的部件 ALU\n5. 为了处理异常情况和特殊请求还必须有中断系统。\n\nCPU 中有一类寄存器用于控制 CPU 的操作或运算。\n\n1. MAR：存储器地址寄存器，用于存放将要被访问的存储单元的地址\n2. MDR：存储器数据寄存器，用于存放欲存入存储器的数据或最近从存储器中读出的数据。\n3. PC：程序计数器，存放现行指令的地址，通常具有计数功能。当遇到转移类指令时，PC 的值可被修改。\n4. IR：指令寄存器，存放当前欲执行的指令。\n\n## 指令周期\n\nCPU 每取出并执行一条指令所需要的全部时间成为指令周期，也即 CPU 完成一条指令的时间。指令周期包括\n\n1. 取指周期：完成取指令和分析指令的操作。PC 中存放当前指令的地址，将该地址送到 MAR 并送至地址总线，然后由控制部件 CU 向存储器发读命令，使对于 MAR 所指单元的内容（指令）经数据总线送至 MDR，再送至 IR，并且 CU 控制 PC 内容加 1，形成下一条指令的地址。\n2. 间址周期：取操作数有效地址。一旦取指周期结束，CU 便检查 IR 中的内容，以确定是否有间址操作，如果需要间址操作，则 MDR 中指示形式地址的右 N 位（记做 Ad（MDR））将被送至 MAR，又送至地址总线，此后 CU 向存储器发出读命令，以获取有效地址并存至 MDR\n3. 执行周期：完成执行指令的操作\n4. 中断周期：执行周期结束时刻，CPU 要查询是否有请求中断的事件发生，如有则进入中断周期。\n\n一个指令周期通常用若干个机器周期表示，一个机器周期又包含若干个时钟周期\n![cpu时钟周期_2020-06-07-15-57-33.png](./images/cpu时钟周期_2020-06-07-15-57-33.png)\n\n### 时钟周期\n\n同步 CPU，使用时钟发生器不断产生稳定间隔的电压脉冲，CPU 中所有的组件将随着这个时钟来同步进行运算动作。\n![cpu时钟周期_2020-06-07-15-23-23.png](./images/cpu时钟周期_2020-06-07-15-23-23.png)\n如图，时钟发生器发出的脉冲信号做出周期变化的最短时间称之为震荡周期，也称为 CPU 时钟周期。它是计算机中最基本的、最小的时间单位。每一次脉冲（即一个震荡周期）到来，芯片内的晶体管就改变一次状态，让整个芯片完成一定任务。一个震荡周期内，晶体管只会改变一次状态。由此，更小的时钟周期就意味着更高的工作频率。\n一秒内，震荡周期的个数称为时钟频率，俗称主频。\n\n### 时钟周期数\n\n指运行单个程序所包含的所有的指令总共所需要的时钟周期数\n\n## 中断系统\n\n在实时处理系统中，必须及时处理某个事件或现象。此时计算机暂时中断现行程序，转而去处理中断服务程序，以解决各种情况。在多道程序运行时，可以通过分配给每道程序一个固定的时间片，利用时钟定时发中断进行程序切换。在多处理器系统中，各处理器之间的信息交流和任务切换也可以通过中断来实现。\n\n### 引起中断的各种因素\n\n1. 人为设置的中断，一般称作自愿中断\n2. 程序性事故，如定点溢出，浮点溢出，操作码不能识别等。\n3. 硬件故障\n4. I/O 设备请求\n5. 外部事件\n\n将引起中断的各个因素称为中断源，中断分为量大类：一类为不可屏蔽中断，这类中断不能禁止响应，如电源掉电；另一类为可屏蔽中断，对可屏蔽中断源的请求，CPU 可根据该中断源是否被屏蔽来确定是否给与响应。\n\n### 中断请求标记\n\n为了判断哪个中断源发出请求，在中断系统中必须设置中断请求标记触发器，简称，记做 INTR，当其状态为 1 时，表示中断请求触发器。\n![计算机组成笔记_中断请求触发器.png](./images/计算机组成笔记_中断请求触发器.png)\n\n### 中断判优逻辑\n\n任何一个中断系统，在任一时刻，只能响应一个中断源的请求。但许多中断源提出请求都是随机的，当某一个时刻有多个中断源提出请求时，中断系统必须按照优先顺序予以响应。\n\n### 中断服务程序入口地址的寻找\n\n一般情况下使用无条件转移指令，将 PC 指向当前中断服务对应的中断服务程序入口地址\n\n### 响应中断的条件\n\n中断触发器的状态为 1，且允许中断触发器状态为 1\n\n### 响应中断的时间\n\n指令周期的执行周期后进入中断周期，统一向所有中断源发出中断信号，只有此时，CPU 才能获知哪个中断源有请求。\n\n### 中断隐指令\n\nCPU 响应中断后，即进入中断周期。在中断周期内，CPU 要自动完成一系列操作，具体如下\n\n1. 保护程序断点：将当前程序计数器 PC 的内容（程序断点）保存到存储器中。\n2. 寻找中断服务程序的入口地址\n3. CPU 进入中断周期，意味着 CPU 响应了某个中断源的请求，为了确保 CPU 响应后所需要做的一系列操作不至于受到新的中断请求干扰，在中断周期内必须自动关中断，以禁止 CPU 再次响应新的中断请求。\n","categories":["计算机组成原理"]},{"title":"java-工具类","url":"/2020/06/04/java-%E5%B7%A5%E5%85%B7%E7%B1%BB/","content":"\n### EventBus\n\n`maven`\n\n```xml\n<dependency>\n    <groupId>com.google.guava</groupId>\n    <artifactId>guava</artifactId>\n    <version>21.0</version>\n</dependency>\n```\n\n`post`事件，注册的 listener 中注解了`@Subscribe`的方法会被执行，该方法的参数的类型需要与`event`类型一致，若没有类型一致的`@Subscribe`，则由参数类型`DeadEvent`的`listener`统一处理\n\n```java\npublic class EventBusTest {\n    @Test\n    public void test() {\n        EventBus eventBus = new EventBus();\n        EventListener eventListener = new EventListener();\n        eventBus.register(eventListener);\n        eventBus.post(\"hello\");\n        eventBus.post(123);\n    }\n    public static class EventListener {\n        @Subscribe\n        public void stringEvent(String event) {\n            System.out.println(\"event = \" + event);\n        }\n        @Subscribe\n        public void handleDeadEvent(DeadEvent deadEvent) {\n            System.out.println(\"deadEvent = \" + deadEvent);\n        }\n    }\n}\n\n```\n\n### `junit` 断言异常\n\n```java\npublic class Student {\n    public boolean canVote(int age) {\n        if (i<=0) throw new IllegalArgumentException(\"age should be +ve\");\n        if (i<18) return false;\n        else return true;\n    }\n}\npublic class TestStudent{\n\n    @Rule\n    public ExpectedException thrown= ExpectedException.none();\n\n    @Test\n    public void canVote_throws_IllegalArgumentException_for_zero_age() {\n        Student student = new Student();\n        thrown.expect(IllegalArgumentException.class);\n        thrown.expectMessage(\"age should be +ve\");\n        student.canVote(0);\n    }\n}\n```\n\n### `poi`\n\n在生成`excel`时，当为单元格填充内容为数字时，生成的 excel 的数字单元格左上角提示绿色小三角。可在填充单元格值时使用`Double`类型\n\n```java\nXSSFCell cell = row.createCell(cellNum);\ncell.setCellType(Cell.CELL_TYPE_STRING);\nif(value.matches(\"\\\\d+\")){\n    cell.setCellValue(Double.valueOf(value));\n}else{\n    cell.setCellValue(value);\n}\n```\n","categories":["java"],"tags":["tips"]},{"title":"java-配置相关","url":"/2020/06/04/java-%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/","content":"\n### 1. `加载资源文件`\n\n一般加载资源文件可以使用如下方法\n\n```java\nClassLoader.getSystemResourceAsStream(\"xxx.properties\")\nSomeClass.class.getResourceAsStream(\"xxx.properties\")\n```\n\n但是注意，第一种方法是有缺陷的，因为不同的类加载器会造成读取不到文件的情况，典型的就是`tomcat`的类加载读取不到应用路径下的文件\n\n### 2. 查看 java 启动变量\n\n```java\nSystem.getenv();//系统级别环境变量，可以在~/.bash_profile中配置\nSystem.getProperties();//java环境变量，一般可以用-Dkey=value来指定\nSystem.setProperty(key,value) //临时指定java环境变量\n```\n\n### 3. InetAddress.getLocalHost() java.net.UnknownHostException 异常\n\n问题原因是在系统的 /etc/Hostname 中配置了“zw_65_43” 作为主机名，而在/etc/hosts 文件中没有 相应的“zw_65_43”。简单的解决办法是\n\n对应关系配好就可以，甚至删除/etc/Hostname 这个文件也可以。\n\n深层的原因： 在大多数 Linux 操作系统中，都是以/etc/hosts 中的配置查找主机名的，但是 Detian based system 用/etc/Hostname 文件中的配置做主机名。\n结论：\n\n1. 设置本机名称：hostname mName xxx 最好不是写 IP 地址的形式，若写则必须是本机的完全 IP 形式(不要只写一半)\n2. 在/etc/hosts 里加一行 本机 IP mName\n3. 用 InetAddress.getLocalHost().getHostAddress()测试一下结果是否是与本机 IP 一致\n\n也可以在`shell`中执行`echo $HOSTNAME`查看主机名，通过`ping $HOSTNAME`查看是否问题已经解决了\n\n### 4. logback 日志\n\nlogback 日志在开始阶段会输出一些自身的日志，通过配置`NopStatusListener`即可以清除\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n\n    <!-- Stop output INFO at start -->\n    <statusListener class=\"ch.qos.logback.core.status.NopStatusListener\" />\n\n    <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <layout class=\"ch.qos.logback.classic.PatternLayout\">\n            <Pattern>\n                %d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n\n            </Pattern>\n        </layout>\n    </appender>\n\n    <root level=\"error\">\n        <appender-ref ref=\"STDOUT\"/>\n    </root>\n\n</configuration>\n```\n\n### 5. `tomcat`使用`java`启动变量作为端口\n\ntomcat 默认会加载`bin`目录下新建`setenv.sh`作为启动环境，若无则新建即可\n\n```shell\n#!/bin/sh\n#JAVA-OPTIONS\n\nJAVA_OPTS=\"$JAVA_OPTS -Dtomcat.port=9999\"\n```\n\n`tomcat`的端口配置文件`conf/server.xml`中，将默认端口替换为如下\n\n```xml\n <Service name=\"Catalina\">\n\n<Connector port=\"{tomcat.port}\" protocol=\"HTTP/1.1\"\n    ...\n```\n\n### 6. 控制台`console`乱码\n\n`java`启动参数添加 `-Dfile.encoding=utf-8`\n","categories":["java"],"tags":["tips"]},{"title":"shell-tips","url":"/2020/06/04/shell-tips/","content":"\n## curl\n\n### 显示请求详情\n\n```shell\ncurl -v http://example.com\n```\n\n示例\n\n```shell\n~$ curl -v http://centos7:8888\n* Rebuilt URL to: http://centos7:8888/\n*   Trying 10.211.55.5...\n* Connected to centos7 (10.211.55.5) port 8888 (#0)\n> GET / HTTP/1.1\n> Host: centos7:8888\n> User-Agent: curl/7.43.0\n> Accept: */*\n>\n< HTTP/1.1 502 Bad Gateway\n< Server: nginx/1.19.0\n< Date: Fri, 19 Jun 2020 13:33:46 GMT\n< Content-Type: text/html\n< Content-Length: 157\n< Connection: keep-alive\n<\n<html>\n<head><title>502 Bad Gateway</title></head>\n<body>\n<center><h1>502 Bad Gateway</h1></center>\n<hr><center>nginx/1.19.0</center>\n</body>\n</html>\n* Connection #0 to host centos7 left intact\n\n```\n\n### 重定向\n\n当使用`curl`或者在 java 中请求一个远程接口时，当服务器将请求转发即`redirect`时，将无法得到返回报文。\n服务器的返回头中，会有 redirect 的目标地址。\n若使用 curl，我们可以使用`curl -iL --max-redirs 1 http://example.com`,将返回头打印出来\n\n> HTTP/1.1 301 Moved Permanently\n> Date: Thu, 18 Apr 2019 02:39:59 GMT\n> Transfer-Encoding: chunked\n> Connection: keep-alive\n> Location: https://example.com/about\n\n返回头中的`Location`，即重定向的地址。我们再次请求重定向的地址，即可得到想要的结果\n\n### 获取 http 返回码\n\n```shell\nresponse=$(curl --write-out %{http_code} --silent --output /dev/null servername)\necho $response\n\n```\n\n## 死循环\n\n无线循环并睡眠 1 秒\n\n```bash\n\n#!/bin/bash\nwhile [ 1 ]\ndo\n      sleep 1s\ndone\n\n```\n\n## 后台进程\n\n`nohup`可以用来将脚本在后台运行，默认会将脚本的输出信息打印到`nohup.out`中\n\n若需要不输出日志信息可以使用\n\n```shell\nnohup ./program >/dev/null 2>&1 &\n```\n\n## ls\n\n按文件大小顺序显示\n\n`ls -LS`\n\n## 快速删除大文件\n\n```shell\ncat /dev/null > access.log\n```\n\n## nl\n\n将输出的每一行加上行号。例如：`'cat 1.txt | nl'`，输出`1.txt`的文件并加上行号\n\n## `rm`\n\n在使用`cd dir && rm -rf file`时需要注意，当`dir`不存在时，`rm`会直接删除当前目录的文件，因此`rm`后跟文件绝对路径\n\n## `ssh免密及执行远程命令`\n\n操作机上生成秘钥`ssh-keygen -t rsa`,将会生成一对秘钥，将公钥内容追加到服务器的`~/.ssh/authorized_keys`中，\n可通过**远程命令**`ssh user@example.com 'cat id_rsa.pub >> ~/.ssh/authorized_keys'`去执行,可以简单的使用`ssh-copy-id user@example.com`,这种方式\n采用的是默认的`22`端口，拷贝的公钥是默认的`id_rsa.pub`\n\n确保服务器的文件及目录权限\n\n1. 设置 authorized_keys 权限  \n   `chmod 600 authorized_keys`\n2. 设置.ssh 目录权限  \n   `chmod 700 -R .ssh`\n3. 设置用户目录权限  \n   `chmod go-w ~`\n\n后续再执行`ssh`操作，或者`scp`等操作，则不需要再输入密码\n\n通过系统日志文件我们可以查看无法登陆远程服务器的原因  \n`tail /var/log/secure -n 20`\n\n## `XARGS`\n\n传递参数\n\n```shell\nls *.jar|xargs -I {} jadx {} -d src\n```\n\n## `top`\n\n使用`top`命令查看进程占用情况，可配合`grep`来实现查看想要的信息\n`top|grep java`\n\n## `svn`\n\n通过 `svn info`判断服务器和本地的版本号是否相同，可使用`grep`和`awk`组合\n\n## WGET\n\n用`wget`递归下载\n\n`wget -r -np --reject=html www.download.example`\n或者可以把`reject`换做 `--accept`=`iso,c,h`，表示只接受以此结尾的文件，分隔符为逗号`（comma-separated）`\n\n## `AWK`\n\n默认情况下`awk`以空格进行分割字符串，`-F`，可以指定分割符  \n`‘{print $1}’`，输出第几个分割字符\n\n截取除第一位之后的所有元素\n\n```shell\necho  1 2 3 4 5|awk '{first = $1; $1 = \"\"; print $0 }'\n```\n\n示例：\n\n```shell\nmore 1.txt|awk -F ',' '{print $2}'\n```\n\n使用条件判断筛选数据\n\n```shell\nawk 'length($2) ==12 && $2 > 20190101 && $2 <= 20191212 {print $0}'\n\n\n```\n\n## `sort`\n\n对输出内容进行排序，默认情况下`sort`仅比较`ASCII`字符。可使用 `sort -n`指定用数字大小来排序。\n类似`awk`，可以指定使用第几个单词进行排序。例如使用第二个单词`sort -k 2`\n\n## `du`\n\n命令查看当前目录下所有文件夹的大小 `-d` 指深度，后面加一个数值\n\n```shell\ndu -d 1 -h\n```\n\n## `history`\n\n设置历史记录不重复\n\n```bash\nexport HISTIGNORE='ls:bg:fg:history'\nshopt -s histappend # append new history items to .bash_history\nexport HISTCONTROL=ignoreboth:erasedups\nexport HISTFILESIZE=10000       # increase history file size (default is 500)\nexport HISTSIZE=${HISTFILESIZE} # increase history size (default is 500)\n# ensure synchronization between Bash memory and history file\n#export PROMPT_COMMAND=\"history -a; history -n; ${PROMPT_COMMAND}\"\nshopt -s cmdhist\n# Append new history lines, clear the history list, re-read the history list, print prompt.\nexport PROMPT_COMMAND=\"history -n; history -w; history -c; history -r;history -a; $PROMPT_COMMAND\"\n```\n\n## `uniq`\n\n去重`uniq`,`uniq`默认仅会比较相邻的字符串\n\n会统计重复的次数\n\n```bash\nuniq -c\n```\n\n## 显示所有系统变量\n\n```shell\nenv\n```\n\n## 显示内存占用较多的进程\n\n```shell\nps -aux --sort=-rss|head 10\n```\n\n## type\n\n查看命令的详情\n\n- -a 列出包含别名(alias)在内的指定命令名的命令\n- -p 显示完整的文件名称\n- -t 显示文件类型，其文件类型主要有两种，一种是 builtin，为 bash 的内置命令；另一种是 file，为外部命令\n\n## 计算 shell 执行时间\n\n`time [command]`\n\n## 读取文件内容到变量\n\n```shell\ncontent=`cat file.txt`\n```\n","categories":["linux"]},{"title":"java-stream","url":"/2020/06/04/java-stream/","content":"\n### `groupingBy`\n\n```java\n List<String> items =\n            Arrays.asList(\"apple\", \"apple\", \"banana\",\n                \"apple\", \"orange\", \"banana\", \"papaya\");\nMap<String, Long> result =\n    items.stream().collect(\n        Collectors.groupingBy(\n            Function.identity(), Collectors.counting()\n        )\n    );\nSystem.out.println(\"result = \" + result);\nMap<Object, Set<String>> collect = items.stream().collect(Collectors.groupingBy(String::length, Collectors.mapping(e -> e,\n    Collectors.toSet())));\n\nSystem.out.println(\"collect = \" + collect);\n```\n\n### `join`\n\n```java\nString join = items.stream().collect(Collectors.joining(\",\"));\n\n```\n\n### `reduce`\n\n递归执行所有元素\n\n```java\nStream<Integer> stream = Stream.of(1, 2, 3);\nint count = stream.reduce(Integer::sum).orElse(0);\nSystem.out.println(\"count \" + count);\n```\n\n依次与初始值`identity`进行运算\n\n```java\nStream<Integer> stream = Stream.of(2, 0, 3);\nint identity = 6；\nshort value = stream.reduce(identity, (a, b) -> a * b).shortValue();\nSystem.out.println(\"value = \" + value);\n```\n\n相当于\n\n```java\nT result = identity;\nfor (T element : this stream)\n    result = accumulator.apply(result, element)\nreturn result;\n```\n\n依次与初始值`identity`进行运算，运行返回其他类型\n\n```java\nStream<Integer> stream = Stream.of(2, 2, 3);\nString reduce = stream.reduce(\"\", (a, b) -> a + b, (u, u2) -> \"\");\nSystem.out.println(\"reduce = \" + reduce);\n```\n\n模拟 join\n\n```java\n List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);\nString join= numbers.stream().map(String::valueOf).reduce((total, element) -> total + element+\"\").get();\nSystem.out.println(\"join= \" + join);\n```\n\n### 流快速删除,`Collection`提供了方法\n\n```java\nList<String> list = new ArrayList<>();\nlist.removeIf(Predicate<? super E> filter)\n```\n","categories":["java"]},{"title":"java-字符串","url":"/2020/06/04/java-%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"\n### 切割字符串\n\n```java\nString value = \"Notice:4001\";\nStringTokenizer st = new StringTokenizer(value, \":\");\nif(st.hasMoreElements()){\n  System.out.println(st.nextToken());\n}\n```\n\n### `String` 替换 正则匹配组\n\n```java\nString s = \"HelloWorldMyNameIsCarl\".replaceAll(\"(.)([A-Z])\", \"$1_$2\");\nString s = \"1.1\".replaceAll(\"(\\\\.\\\\d)$\", \"$10\");//$1表示前面正则表达式组1所捕获到的字符\n```\n\n### java 字符串占位符\n\n```java\nString msg = \"hello{0},hello{1}\";\nString format = MessageFormat.format(msg, new ArrayList<>(), 100);\nSystem.out.println(\"format = \" + format);\n\n```\n\n可以使用 Apache Common 工具类\n\n```java\nimport org.apache.commons.lang.text.StrSubstitutor;\n...\n\nString template = \"Welcome to {theWorld}. My name is {myName}.\";\n\nMap<String, String> values = new HashMap<>();\nvalues.put(\"theWorld\", \"Stackoverflow\");\nvalues.put(\"myName\", \"Thanos\");\n\nString message = StrSubstitutor.replace(template, values, \"{\", \"}\");\n\nSystem.out.println(message)\n```\n\n输出结果\n\n> format = hello[],hello100\n\n### html 特殊字符转译\n\n```java\nimport org.apache.commons.lang3.StringEscapeUtils;\n...\nStringEscapeUtils.unescapeHtml4（str）\n```\n\n### URL 中文转议\n\n```java\nURLEncoder.encode(\"中文\", StandardCharsets.UTF_8.name())\nURLDecoder.decode(\"%E4%B8%AD%E6%96%87\", StandardCharsets.UTF_8.name())\n```\n\n### 规范输出数字\n\n当数字位数不够时，自动在前段补 0\n\n```java\nString.format(\"%03d\",num)\n```\n","categories":["java"]},{"title":"kafka简述","url":"/2020/06/03/kafka%E7%AE%80%E8%BF%B0/","content":"\nkafka 是一个分布式数据流处理系统。\n\n- kafka 以集群的方式运行在一台或多台服务器上\n- kafka 集群用 topic 来分类存储数据流\n- 每个数据都包含 key,value,timestamp\n\n## partition\n\ntopic 是发布消息的一个通道，topic 可被多个客户端订阅，topic 可向多个客户端发送订阅信息。对于每一个 topic，\nkafka 包含一个被 partition 的日志记录如下\n![kafka简述_2020-06-03-22-18-02.png](./images/kafka简述_2020-06-03-22-18-02.png)\n\n### partition 的规则\n\n- 如果没有指定 key 值并且可用 partition 个数大于 0 时，在就可用 partition 中做轮询决定消息分配到哪个 partition\n- 如果没有指定 key 值并且没有可用 partition 时，在所有 partition 中轮询决定小心分配到哪个 partition\n- 如果指定 key，对 key 值做 hash 分配到指定的 partion\n\n在 java 中，我们可以指定 partition 规则来确保消息全部发送至一个 partition\n\n```java\npublic class MyPartion implements Partitioner {\n\n    public int partition(String s, Object o, byte[] bytes, Object o1, byte[] bytes1, Cluster cluster) {\n        return 1;\n    }\n\n    public void close() {\n\n    }\n\n    public void configure(Map<String, ?> map) {\n\n    }\n}\n```\n\n```java\npublic class PartionProducer {\n\n    public static void main(String[] args) {\n\n        Properties properties = new Properties();\n        properties.put(\"bootstrap.servers\", \"106.15.37.147:9092\");\n        properties.put(\"acks\", \"all\");\n        properties.put(\"retries\", \"3\");\n        properties.put(\"batch.size\", \"16384\");\n        properties.put(\"linger.ms\", 1);\n        properties.put(\"buffer.memory\", 33554432);\n        //key和value的序列化\n        properties.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n        properties.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n\n        //添加自定义partition器\n        properties.put(\"partitioner.class\", \"com.congge.partion.MyPartion\");\n\n        //构造生产者对象\n        KafkaProducer<String, String> producer = new KafkaProducer<String, String>(properties);\n        //发送消息\n        for (int i = 0; i < 10; i++) {\n            producer.send(new ProducerRecord<String, String>(\"second\", \"congge-self \", \"val = \" + i)\n                    , new ProducerCallBackV3());\n        }\n        //关闭连接资源\n        producer.close();\n\n    }\n}\n\n/**\n * 生产者回调消息\n */\nclass ProducerCallBackV3 implements Callback {\n\n    public void onCompletion(RecordMetadata metadata, Exception e) {\n        if (e == null) {\n            System.out.println(\"offset : \" + metadata.offset());\n            System.out.println(\"partition : \" + metadata.partition());\n            System.out.println(\"topic : \" + metadata.topic());\n            System.out.println(\"===============================\");\n        }\n    }\n\n}\n```\n\n### partition 详情\n\npartition 是一个有序日志，在 partition 上每个 consumer 有唯一 offset 表示当前消费的位置。partition 日志在一段时间内是持久保存在服务器上的，不管 consumer 是否消费，可通过配置数据的保留策略设置消息的过期时间。\n![kafka简述_2020-06-03-22-41-41.png](./images/kafka简述_2020-06-03-22-41-41.png)\n通过操作 offset，我们可以读取还未过期的历史数据，也可以跳过当前数据读取已经写入 kafka 的未来数据\n\n## 消费者\n\n在 kafka 中 consumer 隶属于 consumer group.\n\n- topic 中的一个 partition 只能被同一个 group 的一个 consumer 消费。即发布到该 topic 的记录会根据 partition 的分区规则推送到指定的 consumer 去消费，而不是所有 consumer 都会受到消息。若订阅该 topic 的同一个组的 consumer 数量大于 partition 数量时，将会有 consumer 空闲\n- topic 中的一个 partition 可以被其他 group 的一个 consumer 消费。即发布到该 topic 的记录会广播给所有订阅该 topic 的 group 中的一个 consumer 去消费\n\n例如\n![kafka简述_2020-06-03-22-49-47.png](./images/kafka简述_2020-06-03-22-49-47.png)\n","categories":["code"],"tags":["kafka","中间件"]},{"title":"代码规范检测表","url":"/2020/06/03/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%A3%80%E6%B5%8B%E8%A1%A8/","content":"\n## 命名\n\n- 易于理解\n- 清晰的表达意思\n- 即时更新\n\n## 测试\n\n- 编写必要的 junit 测试\n\n## 结构\n\n- 层次分明\n- 清晰优于简洁\n\n## 断言\n\n- 警示\n- 申明\n\n## 方法\n\n- 参数尽可能少\n- 通过已有参数间接查询\n- 分离修改和查询\n- 方法内赋值变量使用临时变量\n- 方法使用的变量作用域越近越好\n\n## 其他\n\n- 常量值应该统一管理，而不是分散在各地\n- 返回集合和类的深拷贝\n","categories":["code"]},{"title":"英文变量名","url":"/2020/05/28/%E8%8B%B1%E6%96%87%E5%8F%98%E9%87%8F%E5%90%8D/","content":"\n| 英文            | 中文         |\n| :-------------- | :----------- |\n| CaseSensitive   | 大小写敏感   |\n| CaseInSensitive | 大小不写敏感 |\n","categories":["english"]},{"title":"dom4j","url":"/2020/05/28/dom4j/","content":"\n## SAXReader\n\n`feature`属性，禁止校验`dtd`文件\n\n使用 dom4j 解析 xml\n\n```java\nimport com.sun.org.apache.xerces.internal.impl.Constants;\n\n/**\n * 在读取文件时，去掉dtd的验证，可以缩短运行时间\n */\npublic static SAXReader getSAXReader(){\n    SAXReader saxReader = new SAXReader(DOMDocumentFactory.getInstance(),false);\n     try {\n         saxReader.setFeature(Constants.XERCES_FEATURE_PREFIX + Constants.LOAD_EXTERNAL_DTD_FEATURE, false);  //设置不需要校验头文件\n     } catch (Exception e) {\n         e.printStackTrace();\n     }\n     return saxReader;\n }\n```\n\n读取`String`为`DOMDocument`\n\n```java\nString xml = \"...xml...\";\nDOMDocument document = (DOMDocument) getSAXReader().read(new StringReader(xml));\n```\n\n## DOMElement\n\n顺序读取文本内容和子元素\n\n```java\nDOMElement root = doc.getRootElement();\nfor(Object element : root.content()){\n    if( o instanceof DOMElement){\n        System.out.println(((DOMElement)o).asXML())\n    }\n    if( o instanceof DOMText){\n        System.out.println(((DOMText)o).getText().trim())\n    }\n}\n```\n\n## XPATH\n\n`dom4j`直接获取值\n\n```java\ndoc.selectObject(\"substring(/root/name/text(),2)\");\n\n//选择所有有id属性元素(List<DOMAttribute>)\ndoc.selectObject(\"/root/@id\")\n//获取第一个匹配标签的id属性的值\ndoc.selectObject(\"string(/root/@id)\")\n```\n\n### 获取`tomcat`运行端口\n\n```java\n//通过classpath定位tomcat配置文件conf/server.xml，使用xpath去解析\nFile serverXml = new File(\"/Users/li/java/apache-tomcat-7.0.70/conf/server.xml\");\nDocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();\ndomFactory.setNamespaceAware(true); // never forget this!\nDocumentBuilder builder = domFactory.newDocumentBuilder();\nDocument doc = builder.parse(serverXml);\nXPathFactory factory = XPathFactory.newInstance();\nXPath xpath = factory.newXPath();\nXPathExpression expr = xpath.compile(\"/Server/Service[@name='Catalina']/Connector[starts-with(@protocol,'HTTP')]/@port[1]\");\nString result = (String) expr.evaluate(doc, XPathConstants.STRING);\nport = result != null && result.length() > 0 ? Integer.valueOf(result) : null;\n```\n","categories":["java"],"tags":["dom4j"]},{"title":"redis-持久化","url":"/2020/05/26/redis-%E6%8C%81%E4%B9%85%E5%8C%96/","content":"\n## RDB\n\nRDB 是 redis 在指定时间内生成的数据集的时间点快照，可使用`SAVE`命令手动生成备份文件\n\n**_优点:_**\n\n- 一个时间点的压缩过的快照文件，非常适用于备份\n- 适用于作为容灾处理，可以存储在其他数据中心\n- 仅需子进程去生成快照，不阻塞 redis 主线程\n- 启动时恢复数据比 AOF 快\n\n**_缺点:_**\n\n- RDB 不利于记录短时间内的数据更新操作\n- RDB 最多可能会丢失备份间隔时间内的数据\n- 当数据过大时，生成快照耗费时间过多\n\n## AOF\n\nAOF 是一个记录了 redis 所有写操作的日志，它可以在服务器启动时重新执行这些写命令来还原数据库。\nAOF 文件中记录的写命令使用 redis 协议来保存数据，新命令会被追加到文件的结尾。redis 还可以对 AOF 文件进行重写，优化 AOF 文件的体积\n\n**_优点:_**\n\n- 可靠性高，AOF 可供选择的策略`no fsync at all`, `fsync every second`, `fsync at every query`，默认情况下使用的是 `fsync every second`。同步的频率越高，占用 CPU 越多，同步效果越好\n- AOF 日志一个追加文件\n- AOF 可通过重写优化其体积\n- AOF 文件格式易于理解，方便转换\n\n**_缺点:_**\n\n- AOF 文件一般大于 RDB\n- AOF 消耗性能大\n\n## 配置\n\n```conf\n# RDB 每60秒，至少1000个key被修改过\nsave 60 1000\n\n# AOF\nappendonly yes\n# AOF策略\n#1 no\n#2 everysec\n#3 always\nappendfsync  everysec\n```\n\n可以使用`redis-check-aof`修复 aof 文件\n可以使用`redis-check-rdb`修复 rdb 文件\n","categories":["redis"]},{"title":"shell-变量","url":"/2020/05/26/shell-%E5%8F%98%E9%87%8F/","content":"\n## 1. 变量引用\n\n一般情况下使用 `$variable`来引用变量值，它是`${variable}`的一种缩写\n\n- 引用变量定义默认值\n\n  ```shell\n  #当变量为空时，name 就为 hello\n  name=${variable:-hello}\n  ```\n\n- 引用变量替换\n\n  ```shell\n  #将variable中的hello替换为空\n  name=${variable/hello/}\n  #将variable中的满足正则表达式`^hello`替换为空\n  name=${variable//^hello/}\n  ```\n\n### 1.1. 基于位置的参数\n\n命令可以作为参数传入 shell 脚本中\n\n```shell\necho $1\necho $2\n$1 $2\n```\n\n- \\$0 表示`shell`脚本本身\n- \\$[n] 表示`shell`第几个参数，\\$10 不能获取第十个参数，获取第十个参数需要`${10}`。当 n>=10 时，需要使用\\${n}来获取参数。\n- \\$@ 表示所有参数\n- \\${@:n} 表示除 n 前的所有参数，例如`${@:2}`表示除了第一个参数之外的所有参数\n- \\$? 显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误\n- \\$\\$ 脚本运行的当前进程 ID 号\n- \\$! 后台运行的最后一个进程的 ID 号\n- `*` 表示当前目录所有文件，相当于 ls\n- \\${{ '{#' }}name} 变量的长度\n\n### 1.2. 字符串截取\n\n`${varible#*string}`从左往右，删除最短的一个以 string 结尾的子串，即截取第一个 string 子串之后的字符串  \n`${varible##*string}`从左往右，删除最长的一个以 string 结尾的子串，即截取最后一个 string 子串之后的字符串  \n`${varible%string*}`从右往左，删除最短的一个以 string 开头的子串，即截取最后一个 string 子串之前的字符串  \n`${varible%%string*}`从右往左，删除最长的一个以 string 开头的子串，即截取第一个 string 子串之前的字符串\n\n```bash\nTEST=123abc456abc789\necho ${TEST#*abc}  #删掉 123abc 剩下 456abc789\necho ${TEST##*abc} #删掉 123abc456abc 剩下\"789\necho ${TEST%abc*}  #删掉 abc789 剩下 123abc456\necho ${TEST%%abc*} #删掉 abc456abc789 剩下 123\n```\n\n固定位置截取\n\n`${varible:start:len}`:截取变量 varible 从位置 start 开始长度为 len 的子串。第一个字符的位置为 0。\n\n```bash\nTEST=123abc456abc789\necho ${TEST:0:3} #123\necho ${TEST:3:3} #abc\"\n```\n\n## 2. 引号\n\n1. 单引号`''`,被称作弱引用，在`'`内的字符串会被直接使用，不会被替换。\n\n   ```shell\n   echo ''\\'''\n   #输出结果\n   # '\n   ```\n\n2. 双引号`\"\"`,被称做强引用，在`\"`的字符串的变量引用会被直接替换为实际的值\n\n3. 反引号``, 反引号括起来的字串被 Shell 解释为命令，在执行时，Shell 首先执行该命令，并以它的标准输出结果取代整个反引号（包括两个反引号）部分\n\n## 3. 容错断言\n\n如果一个或多个必要的环境变量没被设置的话, 就打印错误信息.下面是两种方式\n\n```shell\n: ${HOSTNAME?} ${USER?} ${MAIL?}\n```\n\n## 4. 设置静态变量\n\n```shell\nreadonly MY_PATH=/usr/bin\n```\n\n## 5. 字符串切割为数组\n\n### 5.1. 利用 shell 中 变量 的字符串替换\n\n用 string 来替换 parameter 变量中所有匹配的 pattern\n\n示例：\n\n```shell\n#!/bin/bash\n\nstring=\"hello,shell,split,test\"\narray=(${string//,/ })\n\n# 迭代数组\nfor var in ${array[@]}\ndo\n   echo $var\ndone\n\n```\n\n### 5.2. 设置分隔符，通过 IFS 变量\n\nShell 脚本中有个变量叫 IFS(Internal Field Seprator) ，内部域分隔符，shell 根据 IFS 的值，默认是 space, tab, newline 来拆解读入的变量，然后对特殊字符进行处理，最后重新组合赋值给该变量。\n\n```shell\n#!/bin/bash\n\nstring=\"hello,shell,split,test\"\n\n#对IFS变量 进行替换处理\nOLD_IFS=\"$IFS\"\nIFS=\",\"\narray=($string)\nIFS=\"$OLD_IFS\"\n\nfor var in ${array[@]}\ndo\n   echo $var\ndone\n```\n\n## 6. 变量使用`*`\n\n在编写 shell 脚本的过程中，有的时候难免会用到一些变量值被定义为(`*`)的变量，但是当我们试图引用这个变量的时候 bash 有默认会把（`*`）替换成当前目录下的所有文件名的列表，如下：\n\n```shell\n[root@vm_102 ~]# a=*\n[root@vm_102 ~]# echo $a\nanaconda-ks.cfg install.log install.log.syslog\n[root@vm_102 ~]# ls\nanaconda-ks.cfg  install.log  install.log.syslog\n```\n\n这个时候我们可以考虑一个问题：这里的（`*`）是在哪一步被替换成当前目录下面的文件列表的呢：是在第一步，变量赋值的时候就被替换的呢还是说，在 echo 变量值的时候被替换的呢？\n事实是这样子的：\n1、当变量复制的时候，bash 会直接将(`*`)赋值给变量 a；\n2、但是在第二步引用变量的时候，bash 默认会把(`*`)替换成当前目录下的所有文件的列表，大家可以这么实验一下：\n\n```shell\n[root@vm_102 ~]# echo *\nanaconda-ks.cfg install.log install.log.syslog\n```\n","categories":["linux"],"tags":["bash","shell"]},{"title":"redis-主从复制","url":"/2020/05/26/redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","content":"\n## 基础概念\n\nredis 提供了基础的主从复制功能，它允许一个从节点实例完整拷贝主节点实例。当主从连接断开后，从节点会自动重连主节点\n\n- 主从节点连接后，主节点想从节点发送一连串的流指令，以用来拷贝主节点所有的写命令\n- 当从节点因故障断开连接后重连后，从节点尝试执行部分同步，即仅同步执行在断开连接时间内的写命令流\n- 当部分同步不可用时，从节点会请求一个全量同步，这需要主从点生成一个数据的快照，并将其发送给从节点，发送后主节点才可继续执行其他命令\n\nredis 默认采用异步方式同步数据，耗费时间少性能高，可以使用`wait`命令，使其使用同步方式同步数据。`wait`仅确认待同步的数据，不保证同步过程的强一致性。\n\n- redis 使用异步方式同步数据\n- 主节点可以有多个从节点\n- 从节点可以有子从节点，类似瀑布模式\n- 主节点采用非阻塞的方式进行传递数据的，可同时支持查询数据\n- 从节点采用非阻塞的方式接受数据，可同时支持查询旧数据\n\n当关闭主节点的持久化策略时，当主节点宕机重启丢失所有数据时，会将空的数据库同步到所有从节点，造成所有节点的数据丢失。所以这时，节点的自动重启功能需要被禁止。\n\n**_从节点不具有写权限_**\n\n## 配置从节点\n\n只需要将下述配置放到从节点的配置文件中即可\n\n```conf\n# xxx的从节点\nslaveof 192.168.1.1 6379\n# 是否为只读模式，默认情况下为yes\nslave-read-only  yes\n```\n\n## 主从复制的细节\n\n每一个主节点都有个一个 replication ID ，和一个用于记录写命令数据的复制缓存区，每个 byte 的缓冲数据都有一个偏移量，偏移量是一直增长的。\n![redis-主从复制_2020-05-26-17-16-39.png](./images/redis-主从复制_2020-05-26-17-16-39.png)\n\n1. 当从节点连接到主节点时，他使用 psync 命令来发送它们记录的 replication ID 和迄今为止处理的写命令的偏移量。\n2. 若从节点匹配主节点 replication ID ，并且的复制缓存区中，有从节点上送的偏移量记录，那么从节点将同步偏移量之后的所有命令发送到从节点更新数据。\n3. 若从节点上送的 replication ID 不匹配，或者主节点的复制缓存区没有相关偏移量的写命令，那么就会进行全量复制\n4. 主节点使用 BGSAVE 命令，将当前数据生成 rdb 文件，然后将文件发送给从节点\n5. 从节点收到 rdb 数据后，将其加载到内存中，同时丢失旧数据\n","categories":["redis"]},{"title":"linux-自定义补全","url":"/2020/05/24/linux-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A5%E5%85%A8/","content":"\n在 linux 中，通常我们可以使用`<tab><tab>`来进行补全，但是我们自己写的脚本却没有自动补全的功能。我们通过 linux 内置的 complete 命令来设定自定义补全。\n\n一般情况下我们定义一个配置文件专门用于自定义配置文件\n\n```bash\n#/usr/bin/env bash\ncomplete -W \"now tomorrow never\" dothis\n```\n\n要使其生效，我们需要`source config.file`,我们可以将这个命令追加到`.bash_profile`中\n\n## 用法\n\n1. `complete -W [wordlist] dothis`\n\n   例如:\n   complete -W \"now tomorrow never\" dothis\n\n   > \\$ dothis `<tab><tab>`\n   > never now tomorrow\n\n2. `complete -d dothis`\n   补全目录\n3. `complete -e dothis`\n   补全文件\n4. `complete -F function dothis`\n   根据函数 function 的中定义的值去显示，该值是实时生效的\n\n   例如：\n\n   ```bash\n   #/usr/bin/env bash\n   list(){\n   COMPREPLY=(`cat .list`)\n   }\n   complete -F list dothis\n   ```\n\n   当我们修改`.list`文件的内容时，补全也跟着变动\n","categories":["linux"]},{"title":"redis-分区","url":"/2020/05/22/redis-%E5%88%86%E5%8C%BA/","content":"\n分区是指将将数据分别存储在不同 redis 节点，每个节点仅存储所有 key 的一部分。\n\n## 使用分区的优势\n\n- 可存储大量数据，不受单台服务器的物理内存限制\n- 分流\n\n## 缺点\n\n- 涉及多个 key 的操作，若 key 在不同的节点上，则无法执行\n- 分区是基于 key 的，若一个 key 中大量数据，它是无法分配到不同的节点\n- 分区处理数据相对比较复杂，特别是处理 RDB/AOF 文件时\n- 调整容量比较复杂，容量调整时需要实时平衡各个节点的数据\n\n## 分区方式\n\nredis 使用 hash 函数将 key 转换为一个数字，然后根据节点数量进行模运算，根据余数将其分配到指定的节点。\n\n- hash 分配具有一致性，即同一个 key 计算出的 hash 值是固定的\n- 客户端分区 有调用端选择正确的节点读写数据\n- 代理服务分区 使用一个中间服务器，来转发请求\n- 请求路由 随机请求一个服务器，由服务器确认数据在哪个节点，当数据请求到错误的节点时，自动转发请求到正确的节点\n\n## 重分配\n\n当需要新增或者移除节点时，redis 需要将 key 重新进行分配到剩余节点上。redis\n","categories":["redis"]},{"title":"redis-清除策略","url":"/2020/05/22/redis-%E6%B8%85%E9%99%A4%E7%AD%96%E7%95%A5/","content":"\n当 redis 内存使用达到最大限制时，当新的数据需要添加时会根据配置的过期策略（maxmemory_policy）表现出不同的行为\n\n- noeviction 直接返回错误\n- allkeys-lru 从所有 key 中选择一些最长时间未使用的 key 进行删除\n- volatile-lru: 从设置了过期时间的 key 中选择一些最长时间未使用的 key 进行删除\n- allkeys-random 从所有 key 中随机删除\n- volatile-random 从设置了过期时间的 key 中随机删除\n- volatile-ttl 从设置了过期时间的 key 中选择存活时间最短的 key 进行删除\n- allkeys-lfu 从所有 key 中选择一个最少使用的 key 进行删除\n- volatile-lfu 从设置了过期时间的 key 中选择一个最少使用的 key 进行删除\n\n## LRU\n\nredis 并没有实现理论上的 LRU 算法，而是抽取一小部分的 key，将其中最久未使用的一个 key 进行过期\n可以通过配置`maxmemory-samples`指定抽样的个数，默认是 5，抽样个数越大，则收集的越精确，但是占用 cpu 时间越多。当抽样个数达到 10 时，已经非常接近理论上的 LRU。\nredis 内部维护一个双向链表，根据最近访问时间来进行排序\n\n## lFU\n\nredis 莫里斯计数法来统计一个 key 的访问量。它的特点是访问量数值小的时候是增长的快，访问量数值大的时候增长的慢。我们可以通过`lfu-log-factor 10`来控制其增长速度。下面是不同参数时，访问量增长的速度增长，根据我们的 key 实际访问量，我们可以定义一个合适的值以方便更好的区分 key 的最近访问频率，以便淘汰最少访问次数的 key\n![redis-清除策略_2020-05-22-17-08-10.png](./images/redis-清除策略_2020-05-22-17-08-10.png)\n\nredis 每分钟会计算 key 是否被访问过，若没有则将 key 的最近访问次数减去一个系数，这个系数根据配置`lfu-decay-time 1`来控制\n","categories":["redis"]},{"title":"redis事务","url":"/2020/05/22/redis%E4%BA%8B%E5%8A%A1/","content":"\n## 使用 script\n\nredis script 是原子性的，天然就支持事务，redis 事务可以做的操作，一定可以使用 script 实现，且更高效简单。\n\n## multi\n\n建立一个命令队列，将后续命令顺序存在在临时队列中而不是执行，直到碰到 exec 或者 discard\n如果后续命令语法错误，将会直接触发 discard\nmulti 命令后，redis 是可以执行其他客户端命令的\n\n## discard\n\n将 multi 缓存的命令队列丢弃\n\n## watch\n\n```shell\nwatch [keys ...]\n```\n\n监听一个或多个 key，将当前 key 的值存储起来\n\n## unwatch\n\n清空 watch 监听的 key\n\n## exec\n\n- 执行前判断是否有 watch 监听的 key，如有判断当前监听的 key 的值是否变动，若变动则不执行 exec\n- 一旦开始执行 multi 命令队列，redis 核心程序顺序执行此命令队列，此操作时原子性的，不存在其他客户端命令在其中间执行\n- 处于 redis 执行效率，命令队列执行过程中，如果命令执行失败或报错，仅将错误信息返回，并不会影响其他命令的执行\n- 不支持回滚\n- 清空 multi 队列\n- 清空 watch 监听的 key\n","categories":["redis"]},{"title":"redis-过期时间","url":"/2020/05/20/redis-%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/","content":"\n## 概述\n\nredis 可对 key 设定过期时间，当达到指定时间后，将会自动将 key 删除\n\n- expire 几秒后失效\n- pexpire 几毫秒后失效\n- expireat 指定秒失效\n- pexpireat 指定毫秒失效\n- ttl 查询剩余秒数\n- pttl 查询剩余毫秒数\n- persist 移出过期时间\n- 过期时间设置可被`del`,`set`,`getset`和其他写命令给重置\n- `rename`会将原 key 的过期时间同步过新 key 上\n\n## 过期时间\n\nkey 的过期时间使用的是 Unix 时间戳，不同服务器的时间差异可能导致 key 提前或延迟过期。多个节点同步数据时，可能各个节点的数据是否已经失效时不同的。\n\nkey 的过期时间作为一个属性，存储在 key 的中\n\n## 过期策略\n\n被动删除，当客户端请求已经失效的 key 时，此时 redis 会直接删除该 key。但是有些 key 可能一直不被访问，所以 redis 还提供了定期删除的策略。redis 每次测试一小部分 key 是否过期，然后执行删除。\n\n- 一般情况下一秒执行 10 此定时任务\n- 随机测试 20 个 key，删除所有已经过期的\n- 当 25%的 key 都是过期的，会重新执行此任务\n\n## 同步过期命令\n\n当 key 过期时，redis 会同步一个`del`命令到从节点，或者 AOF 文件。\n","categories":["redis"]},{"title":"redis发布订阅","url":"/2020/05/19/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/","content":"\nredis 提供发布订阅功能，客户端可订阅一个或多个 channel，也可以取消订阅。使用`redis-cli`进入订阅模式，只能使用`ctrl-c`取消订阅\n\n## 发布订阅\n\n### 订阅\n\n```shell\n subscribe [channel1] [channel2]\n```\n\n### 取消订阅\n\n```shell\n unsubscribe [channel1] [channel2]\n```\n\n### 发布消息\n\n```shell\npublish [channel] [message]\n```\n\n发布消息后，发布的客户端返回的是当前订阅 channel 的个数。订阅方会受到包含 channel 和 message\n\n### 模式订阅\n\npsubscribe 和 punsubscribe 基本与 subscribe，unsubscribe 用法一样，只是它支持使用通配符。例如\n\n```shell\npsubscribe news.*\npunsubscribe news.*\n```\n\n## 事件订阅\n\nredis 支持订阅操作数据的事件，事件订阅使用普通的订阅发布机制，不具备可靠性，当发布订阅客户端断开连接时，这段时间的订阅信息会丢失。\n\n事件订阅影响 redis 性能，默认情况下是关闭的，可以通过配置文件打开，一般建议使用`CONFIG SET`临时设置\n![redis发布订阅_2020-05-25-15-16-11.png](./images/redis发布订阅_2020-05-25-15-16-11.png)\n输入的参数中至少要有一个 K 或者 E，否则的话，不管其余的参数是什么，都不会有任何通知被分发。(大小写不敏感)\n\n| 字符 | 发送的通知                                                      |\n| :--- | :-------------------------------------------------------------- |\n| K    | 键空间通知，所有通知以  `__keyspace@<db>__`  为前缀，针对 Key   |\n| E    | 键事件通知，所有通知以  `__keyevent@<db>__`  为前缀，针对 event |\n| g    | DEL 、 EXPIRE 、 RENAME  等类型无关的通用命令的通知             |\n| \\$   | 字符串命令的通知                                                |\n| l    | 列表命令的通知                                                  |\n| s    | 集合命令的通知                                                  |\n| h    | 哈希命令的通知                                                  |\n| z    | 有序集合命令的通知                                              |\n| x    | 过期事件：每当有过期键被删除时发送                              |\n| e    | 驱逐(evict)事件：每当有键因为  maxmemory  政策而被删除时发送    |\n| A    | 参数  g\\$lshzxe  的别名，相当于是 All                           |\n\n1. `notify-keyspace-events \"Ex\"` 表示对过期事件进行通知发送\n2. `notify-keyspace-events \"Kx\"`表示想监控某个 key 的失效事件\n3. `notify-keyspace-events \"AKx\"`将参数设为字符串 AKE 表示发送所有类型的通知。\n\n例如：\n\n```shell\n# 临时设置监控事件通知\nconfig set notify-keyspace-events \"KEx\"\n\n# 模式订阅\nPSUBSCRIBE __key*\n# 过期事件测试， 10秒后出触发失效事件\nsetex name 10 tx\n\n# 订阅方收到消息\n1) \"pmessage\"\n2) \"__key*\"\n3) \"__keyspace@0__:name\"\n4) \"expired\"\n1) \"pmessage\"\n2) \"__key*\"\n3) \"__keyevent@0__:expired\"\n4) \"name\"\n\n```\n\n我们可以看到`K`与`E`的区别主要在于触发的`channel`和`message`的不同\n**_ 集群模式下，需要在所有节点上都开启事件通知，又因为监听事件主要是基于 key 的事件，因此需要在正确的节点上订阅消息_**\n","categories":["redis"]},{"title":"redis-script","url":"/2020/05/19/redis-script/","content":"\n## 简介\n\nredis 内置 lua 解释器，支持解析执行 lua script。可以通过 eval 和 evalsha 命令来使用\n\n`eval script numkey keys[key ...] argv[argv ...]`\n\n- 第一个参数是 script，这个 script 无需定义一个 function(也不应该)，它可以直接被 redis 执行的上下文\n- 第二个参数是`KEYS`参数的数量\n- 剩余的参数既是`KEYS`和`ARGV`的参数\n\n例如\n\n```lua\n> eval \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\" 2 key1 key2 first second\n1) \"key1\"\n2) \"key2\"\n3) \"first\"\n4) \"second\"\n```\n\n## 调用 redis\n\n我们可以使用以下两个方法在 lua 调用 redis 命令\n\n- redis.call()\n- redis.pcall()\n\n这两个命令基本类似，唯一的区别在于当执行出错时，redis.call()会直接抛出异常，而 redis.pcall()仅将错误信息组织成报文返回\n\n示例\n\n```shell\n# 0 表示script中无参数\neval \"return redis.call('set','foo','bar')\" 0\n```\n\nlua 中所有关于 redis 命令的操作在执行前需要分析哪个 key 会被操作，所以明确指定哪些 key 会被操作,确定 lua 将会被发送到哪个节点去执行。lua 操作的 keys 需要确保在同一个节点上，可以通过`hash槽`的方式确保其在同一个节点上。\n\n## 原子性\n\nlua script 的所有操作时原子性的\n\n## evalsha\n\neval 命令每次执行 script 时会将 script 本身发送至服务器，redis 为了避免带宽消耗，提供了 evalsha 命令。它使用 script 的`sha1`值来替代 script 本身，若服务器有该 script 的缓存，则直接执行，否则返回失败，并提示你使用 eval 命令。\n\n例如\n\n```shell\n> set foo bar\nOK\n> eval \"return redis.call('get','foo')\" 0\n\"bar\"\n> evalsha 6b1bf486c81ceb7edf3c093f4c48582e38c0e791 0\n\"bar\"\n> evalsha ffffffffffffffffffffffffffffffffffffffff 0\n(error) `NOSCRIPT` No matching script. Please use [EVAL](/commands/eval).\n\n```\n\n每个 eval 执行的 script 都会被永久缓存在 redis 服务器中，可使用`script`命令来操作缓存\n\n1. SCRIPT FLUSH 清空所有缓存的 lua script\n2. SCRIPT EXISTS sha1 sha2 ... shaN 查看对应`sha1`的 lua script 是否存在\n3. SCRIPT LOAD script 手动加载 lua script\n4. SCRIPT KILL 用来打断一个长时间执行但未达到最大 script 执行时限的 lua script\n\n## lua 脚本需要注意的地方\n\nredis5 之后，当 lua 脚本执行成功后，redis 将写命令同步到从节点或者 aof 文件中，而不是同步 script\n所以在之前的版本 lua 脚本需要按照以下标准\n\n- 不使用系统时间或者其他外部的变量\n- 禁止使用 redis 的 `randomkey`,`srandmember`,`time`命令\n- lua 使用`smembers`会先排序\n- 禁止使用 lua 的`math.random`和`math.randomseed`方法\n- 禁止赋值全局变量\n\n## 批量\n\n```lua\neval \"for i,v in pairs(argv) do\n redis.call('set',KEYS[i],ARGV[i])\nend\"  numkeys [KEYS...] [ARGV...]\n```\n\n## 在集群模式下执行`lua`时报错\n\n> lua script attempted to access a non local key in a cluster node\n\nredis 在执行 lua 时，将会对上送的`kEYS`进行计算，计算其是否属于同一个节点，如果属于同一节点，那么就会将 lua 请求转发到该节点去执行。若你在 lua 中手动写死 key，而不是通过参数上送的话，那么 redis 就可能随机选定一个节点去执行，实际执行过程中，就有一定几率发现当前节点是不正确的。\n这是因为 redis 仅允许在单个节点执行 lua ，所以需要确保 key 在同一个节点上，为了确保 key 在同一个节点，我们可以使用`hash tag`，即用`{}`将 key 的一部分包裹起来，比如说`{dbconfig}_c1`,`{dbconfig}_c2`,这样在计算`hash槽`时只会计算`{}`内，从而确保 key 在同一个节点。\n","categories":["redis"]},{"title":"redis集群","url":"/2020/05/19/redis%E9%9B%86%E7%BE%A4/","content":"\n## 端口\n\nredis 节点通常占用两个端口，一个服务端口，一个数据端口，服务端口默认为`6379`,数据端口则为服务端口`+10000`,确保这两个端口的防火墙为打开状态。\n\n## 启动集群\n\n1. 建立多个节点的配置文件目录\n\n   ```shell\n   mkdir cluster-test\n   cd cluster-test\n   mkdir 7000 7001 7002 7003 7004 7005\n   ```\n\n2. 每个节点目录下新增`redis.conf`配置文件，以下为`7000`节点最小配置\n\n   ```conf\n   port 7000\n   cluster-enabled yes\n   cluster-config-file nodes-7000.conf\n   cluster-node-timeout 5000\n   appendonly yes\n   daemonize yes\n   ```\n\n3. 在 cluster-test 目录编写启动脚本\n\n   ```shell\n    #!/bin/bash\n    /usr/bin/redis-server 7000/redis.conf\n    /usr/bin/redis-server 7001/redis.conf\n    /usr/bin/redis-server 7002/redis.conf\n    /usr/bin/redis-server 7003/redis.conf\n    /usr/bin/redis-server 7004/redis.conf\n    /usr/bin/redis-server 7005/redis.conf\n   ```\n\n   启动后我们可以通过`ps -ef|grep redis`看到所有 redis 节点都启动了\n\n4. 对于使用了`redis 5`以上版本，可以使用如下命令来分配`hash槽`\n\n   ```shell\n   #--cluster-replicas 1 使用一个节点作为从节点，那么这里至少需要6个节点，若不指定cluster-replicas则可以只使用三个节点\n   redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1\n\n   ```\n\n   执行后可以得到输出\n\n   > [OK] All 16384 slots covered\n\n   同时可以看到各个节点的相关运行时配置文件`node.conf`\n   我们有 3 个节点的 7000 端口的`node.conf`文件,我们可以看到`hash槽`的分布\n\n   ```configuration\n   73a213f442c0299596d464a1b00b26c0eb433a63 127.0.0.1:7002@17002 master - 0 1589883608796 3 connected 10923-16383\n   3c0f18ab3bcafd94486aab2264833d1a583a0b18 127.0.0.1:7001@17001 master - 0 1589883609703 2 connected 5461-10922\n   1ebfb6ca239c3780fd76f599c0caace80391806b 127.0.0.1:7000@17000 myself,master - 0 0 1 connected 0-5460\n   vars currentEpoch 3 lastVoteEpoch 0\n   ```\n\n5. `redis.conf`配置`bind ip`，可以限定不能使用`127.0.0.1`去访问\n\n## 分区\n\n是指将将数据分别存储在不同 redis 节点，每个节点仅存储所有 key 的一部分。\n\n### 优势\n\n- 可存储大量数据，不受单台服务器的物理内存限制\n- 分流\n\n### 缺点\n\n- 涉及多个 key 的操作，若 key 在不同的节点上，则无法执行\n- 分区是基于 key 的，若一个 key 中大量数据，它是无法分配到不同的节点\n- 分区处理数据相对比较复杂，特别是处理 RDB/AOF 文件时\n- 调整容量比较复杂，容量调整时需要实时平衡各个节点的数据\n- 为了保证 redis 执行效率，redis 各个节点的数据使用异步的方式同步数据，因此 redis 不保证强一致性。若需要确保某个`key`的数据等待同步完返回，则可使用`wait`指令\n\n### 分区方式\n\nredis 使用 hash 函数将 key 转换为一个数字，然后根据节点数量进行模运算，根据余数将其分配到指定的节点。\n\n- hash 分配具有一致性，即同一个 key 计算出的 hash 值是固定的\n- 客户端分区 有调用端选择正确的节点读写数据\n- 代理服务分区 使用一个中间服务器，来转发请求\n- 请求路由 随机请求一个服务器，由服务器确认数据在哪个节点，当数据请求到错误的节点时，自动转发请求到正确的节点\n\nredis 通过计算 key 的`hash槽`来将数据分配到指定的节点，每个节点占据固定长度的`hash槽`,这个就方便新增或者删除节点\n\n```shell\n#查看hash槽在节点上的分布\ncluster slots\n\n# 查看key的hash槽\ncluster keyslot [key]\n```\n\n### hash tag\n\n当我们希望一些 key 分配到同一个节点时，我们可以使用`hash tag`,redis 仅会对 key 中的`hash tag`进行 hash 函数运算，`hash tag`是指第一个'{'到第一个'}'之间，不考虑嵌套关系，若第一个'{'和第一个'}'之间为空，则放弃`hash tag`\n例如\n\n> {user}100 -> user\n> {user}{100}1 -> user\n> {user{}10}0 -> user{\n> {}{user}100 -> {}{user}100\n\n## 重分配\n\n当需要新增或者移除节点时，redis 需要将 key 重新进行分配到剩余节点上。\n","categories":["redis"]},{"title":"redis管道","url":"/2020/05/19/redis%E7%AE%A1%E9%81%93/","content":"\nredis 使用 cs 服务架构，执行一条命令的过程如下\n\n1. 客户端发送一个请求到服务器\n2. 服务器通过 socket 读取命令，通常以阻塞的方式读取\n3. 服务器通过`read()`指令将命令从内存加载到内核执行\n4. 核心执行命令将执行结果写回内存\n5. 将执行结果返回客户端\n\nredis 执行命令的速度是较快的，当执行大量命令时，那么大部分时间将花费在请求返回，读取写回上。\nredis 提供了管道命令，可以批量执行命令，依次执行，然后等执行完成后将执行结果打包返回给客户端。\n\n当然也可以使用{% post_link redis脚本 %}去执行大量命令，来达到批量执行的目的。\n","categories":["redis"],"tags":["pipeline"]},{"title":"tomcat入门","url":"/2020/05/15/tomcat%E5%85%A5%E9%97%A8/","content":"\n## 类加载机制\n\n### 概述\n\n在 java 中，classloader 以 tree 的形式组织起来。通常情况下，当 classloader 加载一个特定的类或资源时，它会将请求委托给父类加载器去加载，若父类加载器中找不到该类，它才会尝试自己去加载。\n![tomcat入门_2020-05-15-02-22-01.png](./images/tomcat入门_2020-05-15-02-22-01.png)\n\n- Bootstrap jvm 提供的类加载器，一般是指`($JAVA_HOME/jre/lib/ext)`下的 jar 包\n- System tomcat 的核心类加载器，就`$CATALINA_HOME/bin`目录下的`bootstrap.jar`,`tomcat-juli.jar`和`commons-daemon.jar`\n- Common tomcat 的共享类加载器 包，在`$CATALINA_BASE/lib`目录下的 jar 包\n- WebappX 应用内部的类加载器，它加载应用`/WEB-INF/classes`和`/WEB-INF/lib`目录下的 class\n\n### 类加载顺序\n\ntomcat 的类加载模型违背了 jvm 的双亲委派模式，除了 Bootstrap 类加载器加载的类，它首先会尝试使用`WebappX`来加载类。\n通常情况下 tomcat 的类加载顺序如下所述\n\n- Bootstrap classes of your JVM\n- /WEB-INF/classes of your web application\n- /WEB-INF/lib/\\*.jar of your web application\n- System class loader classes (described above)\n- Common class loader classes (described above)\n\n若 tomcat 或者应用中在 context 中配置了`<Loader delegate=\"true\"/>`,那么他的类加载顺序就会变成如下\n\n- Bootstrap classes of your JVM\n- System class loader classes (described above)\n- Common class loader classes (described above)\n- /WEB-INF/classes of your web application\n- /WEB-INF/lib/\\*.jar of your web application\n\n### 扩展类加载器\n\n当在 tomcat 目录下的`conf/catalina.properties.`中配置`·server.loader`或`shared.loader`,它就会启用`Server`或`Shared`类加载器\n![tomcat入门_2020-05-15-02-44-19.png](./images/tomcat入门_2020-05-15-02-44-19.png)\n\n- Server 是供 tomcat 使用的，对于应用是不可见的\n- Shared 所有 tomcat 应用共享的 jar 包，类似`Common`的类加载器\n\n## 日志\n\n1. tomcat 内部使用`tomcat-juli.jar`作为日志组件，其使用配置为`$CATALINA_HOME/conf/logging.properties`\n2. 应用可以使用自定义日志组件。不同的 web 应用使用的日志组件是独立的，因为其 WebappX 类加载器是独立的，但是若日志组件在 Common 共享类加载器，或者 Share 类类加载器，那么他们使用的日志组件则是共享的\n","categories":["java"],"tags":["tomcat"]},{"title":"linux文件系统","url":"/2020/05/13/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","content":"\n## 链接\n\n软链接，全称是软链接文件，英文叫作 symbolic link。这类文件其实非常类似于 Windows 里的快捷方式，这个软链接文件（假设叫 VA）的内容，其实是另外一个文件（假设叫 B）的路径和名称，当打开 A 文件时，实际上系统会根据其内容找到并打开 B 文件。\n\n```shell\nln -n [source] [link]\n```\n\n而硬链接，全称叫作硬链接文件，英文名称是 hard link。这类文件比较特殊，这类文件（假设叫 A）会拥有自己的 inode 节点和名称，其 inode 会指向文件内容所在的数据块。与此同时，该文件内容所在的数据块的引用计数会加 1。当此数据块的引用计数大于等于 2 时，则表示有多个文件同时指向了这一数据块。一个文件修改，多个文件都会生效。当删除其中某个文件时，对另一个文件不会有影响，仅仅是数据块的引用计数减 1。当引用计数为 0 时，则系统才会清除此数据块。\n\n```shell\n#软链接\nln  -s [source] [link]\n```\n\n**_软链接可以指向目录，而硬链接不可以_**\n\n## df\n\n查看文件系统以及它们的相关信息\n\n## cp\n\n复制文件\n\n- -v 显示复制的详情\n\n## tar\n\n```shell\n#压缩\ntar -zcvf myfile.tgz file1 file2\n# 解压\ntar -xvf file.tar\n```\n\n## rsync\n\n同步命令，可用于备份应用。该命令做数据的同步备份，会对比数据源目录和数据备份目录的数据，并把不同的数据同步到备份目录。其也可以同步到其他服务器，用法类似 scp\n\n- -v 显示同步详情\n- -p 显示同步百分比\n- --delete 默认情况下 source 中被删除的文件不会同步到 target 中，需要加上该参数才会同步删除命令\n- --exclude 不同步符合[pattern]的文件，[pattern]表达式要匹配的相对路径下的文件名称，包含路径\n  例如\n\n  ```shell\n  rsync -avp   --exclude='dir/*' /etc/ /data/etc/\n  ```\n\n- --include 要配置`--exclude`一起使用，表示不执行符合[pattern]的`--exclude`\n  例如\n\n  ```shell\n  # 表示不同步/etc/log下的文件，除了/etc/log/important相关文件\n  rsync -avp  --include='/etc/*' --include='/etc/log/important*' --exclude='/etc/log/*' /etc/ /data/etc/\n  ```\n","categories":["linux"]},{"title":"linux常用命令","url":"/2020/05/13/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"\n### wall\n\n向系统的全部在线用户发送信息 `wall [n] [messege]`\n\n### write\n\n向其他用户发送信息`write [options] <user> [ttyname]\n\n### 命令可以作为参数传入 shell 脚本中\n\n```shell\necho $1\necho $2\n$1 $2 #直接执行\n```\n\n### 快速删除大文件\n\n```shell\ncat /dev/null > access.log\n```\n\n### 清空文件内容\n\n```shell\n:> file.log\n```\n\n### 快速备份\n\n逗号用来分割旧新文件后缀名\n\n```shell\ncp httpd.conf{,.bak}\ncp  demo.{txt,sh}\n```\n\n### xargs 引用参数\n\n```shell\nls *.jar|xargs -I {} echo {}\n\n```\n\n## awk\n\n`awk`可以用来快速切割文本，默认使用空格分隔符。`'{}'`中对每行都进行操作\n`$0`表示当前行，`$1`表示切割的数组的第一个元素，`'{print $1}'`表示打印第一个元素\n\n`-F ’-‘` 增加切割符\n\n## 查看内存信息\n\n```shell\ncat /proc/meminfo | grep MemTotal\n```\n\n## `apt-get`国内镜像\n\n修改配置文件\n`vim /etc/apt/sources.list`\n\n```shell\ndeb http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse\ndeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse\ndeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse\ndeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse\ndeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse\ndeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse\ndeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse\ndeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse\ndeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse\ndeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse\n\n```\n\n然后执行`apt-get update`\n\n## 查看`java`安装目录\n\n```shell\nhan@ubuntu:/etc$ whereis java\njava: /usr/bin/java /usr/share/java /usr/lib/jvm/java-8-openjdk-amd64/bin/java /usr/share/man/man1/java.1.gz\nhan@ubuntu:/etc$ ls -lrt /usr/bin/java\nlrwxrwxrwx 1 root root 22 4月   2 15:54 /usr/bin/java -> /etc/alternatives/java\nhan@ubuntu:/etc$ ls -lrt /etc/alternatives/java\nlrwxrwxrwx 1 root root 46 4月   2 15:54 /etc/alternatives/java -> /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java\n```\n\n## 离线安装 git\n\n```shell\nrpm2cpio git-1.7.9.6-1.e16.rfx.x86_64.rpm|cpio -idmv\n```\n\n然后在`~/.bash_profile`中配置一个`alias`即可，或者在`PATH`更新`git`的`/usr/bin`路径\n\n## 定时任务\n\n为当前用户创建 cron 服务\n\n1. 键入 crontab -e 编辑 crontab 服务文件\n\n   例如 文件内容如下：\n\n   ```css\n    */2 * * * * /bin/sh  /home/admin/jiaoben/buy/deleteFile.sh\n    :wq #保存文件并并退出\n   ```\n\n   /bin/sh /home/admin/jiaoben/buy/deleteFile.sh 这一字段可以设定你要执行的脚本，这里要注意一下 bin/sh 是指运行 脚本的命令 后面一段时指脚本存放的路径\n\n2. 查看该用户下的 crontab 服务是否创建成功， 用 crontab -l 命令\n\n3. 启动 crontab 服务\n\n   一般启动服务用 /sbin/service crond start 若是根用户的 cron 服务可以用 sudo service crond start， 这里还是要注意 下 不同版本 Linux 系统启动的服务的命令也不同 ，像我的虚拟机里只需用 sudo service cron restart 即可，若是在根用下直接键入 service cron start 就能启动服务\n\n4. 查看服务是否已经运行用 ps -ax | grep cron\n\n5. crontab 命令\n\n   ```css\n   cron服务提供crontab命令来设定cron服务的，以下是这个命令的一些参数与说明:\n\n   crontab -u //设定某个用户的cron服务，一般root用户在执行这个命令的时候需要此参数\n   crontab -l //列出某个用户cron服务的详细内容\n   crontab -r //删除某个用户的cron服务\n   crontab -e //编辑某个用户的cron服务\n   比如说root查看自己的cron设置:crontab -u root -l\n   再例如，root想删除fred的cron设置:crontab -u fred -r\n   在编辑cron服务时，编辑的内容有一些格式和约定，输入:crontab -u root -e\n   进入vi编辑模式，编辑的内容一定要符合下面的格式:*/1 * * * * ls >> /tmp/ls.txt\n   任务调度的crond常驻命令\n   crond 是linux用来定期执行程序的命令。当安装完成操作系统之后，默认便会启动此任务调度命令。crond命令每分锺会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。\n\n   ```\n\n6. cron 文件语法\n\n   ```css\n   分     小时    日       月      星期     命令\n   0-59   0-23   1-31   1-12     0-6     command     (取值范围,0表示周日一般一行对应一个任务)\n\n   记住几个特殊符号的含义:\n   “*”代表取值范围内的数字,\n   “/”代表”每”,\n   “-”代表从某个数字到某个数字,\n   “,”分开几个离散的数字\n   ```\n\n## 合并上下行\n\n```shell\nsed 'N;s/\\n/ /' file.txt\n```\n\n## 清屏\n\nclear 或者使用`ctrl + l`\n\n## 查看当前是否 root\n\n```shell\n# 0既是root\necho $UID\n```\n\n## 合并多行\n\n```shell\nls -1 | paste -sd \",\" -\n```\n\n## 显示当前 IP 的 hostname\n\n```shell\necho $HOSTNAME\n\n#显示当前ip\nhostname -i\n```\n\n## 比较文件差异\n\n```shell\n# -y 左右对比\n# --suppress-common-lines 忽略相同\ndiff -y alpha1.txt alpha2.txt --suppress-common-lines\n```\n\n## 显示 ASCII 表\n\n```shell\nman ascii\n```\n","categories":["linux"]},{"title":"linux搜索","url":"/2020/05/12/linux%E6%90%9C%E7%B4%A2/","content":"\n## 搜索命令\n\n- `man -k` 搜索命令，通常用于在只记得部分命令关键词的场合。在 man 的帮助手册中，将帮助文档分为了 9 个类别，对于有的关键字可能存在多个类别，我们就需要指定特定的类别来查看，一般 bash 命令在 1 类别中。如`printf`的三类别，可以使用`man 3 printf`来查看\n- `whatis` 命令的简要说明，`whatis -w 'loca*'`可以使用正则表达式来搜索应用\n- `info` 命令详细的介绍\n- `which` 命令安装目录\n\n## 搜索文件\n\n1. \b`locate <name>`使用索引去查找文件，如果文件更新，需要定期执行更新命令(`updatedb`)来更新索引库.\n2. `find` 实时查找命令\n   命令语法`find [path] [expression]`\n\n   - -cmin -n : 在过去 n 分钟内被修改过\n     例如 `find . -cmin -10`\n   - -ctime -n : 在过去 n 天内被修改过的文件\n   - 根据文件名搜索，\\*是通配符\n     `find . -name h*`\n     若忽略大小写可以使用`-iname`\n     可使用正则表达式来搜索文件名，将搜索条件引号包含\n     `find . -name '[regex]'`\n     或者使用\n     `find . -regex '[regex]'`\n     需要注意的是，正则表达式匹配的是搜索的全名，而不是文件名。例如\n\n     > ~\\$ find . -regex '.\\*\\.txt' -maxdepth 1\n     > ./1.txt\n\n     若使用`^1.*`是搜索不出这个文件的\n\n   - -maxdepth n ： 搜索指定的深度\n   - -type ：搜索指定类型的文件\n\n     > d: 目录\n     > c: 字型装置文件\n     > b: 区块装置文件\n     > p: 具名贮列\n     > f: 一般文件\n     > l: 符号连结\n     > s: socket\n\n   - -not 反向搜索\n     例如: `find . -not -name 'he'`\n\n## grep\n\ngrep 支持不同的匹配模式，比如默认的 BRE 模式，增强型的 ERE 模式，还有更强悍的 PRE 模式。普通情况下使用默认的 BRE(basic regular expression) 模式就可以了，这种方式的特点是支持的正则表达式语法有限。如果需要更进一步的正则表达式语法支持，可以使用 ERE(extended regular expression) 模式。如果要使用复杂的正则表达式语法，可以使用 PRE 模式，它支持 Perl 语言的正则表达式语法。\n\n语法格式：\ngrep [OPTIONS] PATTERN [FILE...]\n\n> -i 忽略大小写\n> -o 只输出匹配到的部分(而不是整个行)\n> -v 反向选择，即输出没有没有匹配的行\n> -c 计算找到的符号行的次数\n> -n 顺便输出行号\n> -w 表示匹配全词\n> -l 仅显示文件名\n> --exclude-dir=[PATTERN] 排除一些目录(注意，这里设置的也是正则表达式),还可以同时指定多个表达式,例如`grep -r --exclude-dir={.git,xgit} 'email' .`\n> --include 仅搜索某些文件，可使用正则表达式，同时可以指定多个表达式 `grep -rn 'stream' . --include='*.cpp'`\n> -R, -r, --recursive 会递归指定指定目录(可使用通配符)下的所有文件\n> -A n 可以输出匹配行后的 n 行\n> -B n 可以输出匹配行前的 n 行\n> -C n 可以输出匹配行前后的 n 行\n> -f FILE 如果正则表达式太长，或者是需要指定多个正则表达式，可以把它们放在文件中。如果指定了多个正则表达式(每行一个)，任何一个匹配到的结果都会被输出：\n> --binary-files=without-match 不搜索二进制文件\n\n![linux搜索_基础的正则表达式规则.png](./images/linux搜索_基础的正则表达式规则.png)\n\n```shell\negerp \\d{5} *.log\n```\n","categories":["linux"]},{"title":"linux一切皆文件","url":"/2020/05/11/linux%E6%9F%A5%E7%9C%8B/","content":"\n## 概述\n\n`linux`一切都是基于文本的，许多操作文本的命令都可以对其他各种命令其作用，比如说`grep`,可以作用于`top`\n\n## uname\n\n显示系统信息\n\n- -a 显示系统概要信息\n\n## date\n\n以指定格式查看时间\n\n```shell\ndt=`date +'%Y-%m-%d'`\n```\n\n## cat\n\n将文件内容连接后传输到标准输出，tac 和 cat 用法一致，但是从最后一行读取\n\n- -A ： 显示回车尾行等特殊字符\n- -n(number) ：从第一行开始对文件输出的所有行进行编号\n- -b ：忽略空白行的编号\n\n显示目录并给每个文件加上一个编号\n\n```shell\nls |cat -n\n```\n\n## ls\n\n`ls -h`\n使用“-h”参数时，会根据文件的大小选择显示的单位是`K`、`M`还是`G`\n\n设定`ls`的文件日期显示格式\n\n编辑全局配置文件：/etc/profile，使所有用户均显示该格式：\n\n```shell\n#vi  /etc/profile\nexport TIME_STYLE=\"+%Y-%m-%d %H:%M:%S\"\n```\n\n## last\n\n显示登录系统的用户信息\n\n- -a： 在最后一行显示主机名\n\n## head\n\nhead 命令输出文件开头部分，默认情况下显示文件的头 10 行。如果指定多个文件，每个文件前都有一个标题，给出文件名。如果没有指定文件，或当文件为-时，读取标准输入。\n\n- -c,--bytes=[-]K 显示文件前 K 字节。如果 K 前有-，则表示显示除最后 K 字节外的所有内容\n- -n,--lines=[-]K 显示前 K 行。如果 K 前有-，则表示显示除最后 K 行外的所有行\n\ntail 命令与 head 用法一直，但输出文件尾部部分\n\n## free\n\n显示系统内存状态\n\n- -s n：每 n 秒刷新一次查看内存使用状态\n- -h ：根据内存的大小选择显示的单位是`K`、`M`还是`G`\n\n## lsof\n\nlsof（list open files）是一个查看当前系统文件的工具。在 linux 环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。\n\nlsof 打开的文件可以是：\n\n1. 普通文件\n2. 目录\n3. 网络文件系统的文件\n4. 字符或设备文件\n5. (函数)共享库\n6. 管道，命名管道\n7. 符号链接\n8. 网络文件（例如：NFS file、网络 socket，unix 域名 socket）\n9. 还有其它类型的文件，等等\n\n### 命令参数\n\n- -a 列出打开文件存在的进程\n- -c<进程名> 列出指定进程所打开的文件\n- -g 列出 GID 号进程详情\n- -d<文件号> 列出占用该文件号的进程\n- +d<目录> 列出目录下被打开的文件\n- +D<目录> 递归列出目录下被打开的文件\n- -n<目录> 列出使用 NFS 的文件\n- -i<条件> 列出符合条件的进程。（4、6、协议、:端口、 @ip ）\n- -p<进程号> 列出指定进程号所打开的文件\n- -u 列出 UID 号进程详情\n- -h 显示帮助信息\n- -v 显示版本信息\n\n### 无参数输出\n\n`lsof`\n![linux一切皆文件_2020-05-11-23-35-44.png](./images/linux一切皆文件_2020-05-11-23-35-44.png)\n\nlsof 输出各列信息的意义如下：\n\n- COMMAND：进程的名称\n- PID：进程标识符\n- PPID：父进程标识符（需要指定-R 参数）\n- USER：进程所有者\n- PGID：进程所属组\n- FD：文件描述符，应用程序通过文件描述符识别该文件。如 cwd、txt 等:\n\n  ```shell\n  （1）cwd：表示 current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改\n  （2）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序\n  （3）lnn：library references (AIX);\n  （4）er：FD information error (see NAME column);\n  （5）jld：jail directory (FreeBSD);\n  （6）ltx：shared library text (code and data);\n  （7）mxx ：hex memory-mapped type number xx.\n  （8）m86：DOS Merge mapped file;\n  （9）mem：memory-mapped file;\n  （10）mmap：memory-mapped device;\n  （11）pd：parent directory;\n  （12）rtd：root directory;\n  （13）tr：kernel trace file (OpenBSD);\n  （14）v86 VP/ix mapped file;\n  （15）0：表示标准输入\n  （16）1：表示标准输出\n  （17）2：表示标准错误\n  一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u 等\n  （1）u：表示该文件被打开并处于读取/写入模式\n  （2）r：表示该文件被打开并处于只读模式\n  （3）w：表示该文件被打开并处于\n  （4）空格：表示该文件的状态模式为 unknow，且没有锁定\n  （5）-：表示该文件的状态模式为 unknow，且被锁定\n  同时在文件状态模式后面，还跟着相关的锁\n  （1）N：for a Solaris NFS lock of unknown type;\n  （2）r：for read lock on part of the file;\n  （3）R：for a read lock on the entire file;\n  （4）w：for a write lock on part of the file;（文件的部分写锁）\n  （5）W：for a write lock on the entire file;（整个文件的写锁）\n  （6）u：for a read and write lock of any length;\n  （7）U：for a lock of unknown type;\n  （8）x：for an SCO OpenServer Xenix lock on part of the file;\n  （9）X：for an SCO OpenServer Xenix lock on the entire file;\n  （10）space：if there is no lock.\n  ```\n\n- TYPE：文件类型，如 DIR、REG 等，常见的文件类型:\n\n  ```shell\n  （1）DIR：表示目录\n  （2）CHR：表示字符类型\n  （3）BLK：块设备类型\n  （4）UNIX： UNIX 域套接字\n  （5）FIFO：先进先出 (FIFO) 队列\n  （6）IPv4：网际协议 (IP) 套接字\n  ```\n\n- DEVICE：指定磁盘的名称\n- SIZE：文件的大小\n- NODE：索引节点（文件在磁盘上的标识）\n- NAME：打开文件的确切名称\n\n### 常用命令\n\n1. 查找某个文件相关的进程\n\n   ```shell\n   lsof /bin/bash\n   ```\n\n2. 列出某个用户打开的文件信息,-u 选项，u 是 user 的缩写\n\n   ```shell\n   $lsof -u username\n   ```\n\n3. 列出某个程序进程所打开的文件信息,-c 选项将会列出所有以 mysql 这个进程开头的程序的文件，其实你也可以写成 lsof | grep mysql, 但是第一种方法明显比第二种方法要少打几个字符；\n\n   ```shell\n   lsof -c mysql\n   ```\n\n4. 列出某个用户以及某个进程所打开的文件信息\n\n   ```shell\n   lsof  -u test -c mysql\n   ```\n\n5. 通过某个进程号显示该进程打开的文件\n\n   ```shell\n   lsof -p 11968\n   ```\n\n6. 命令查看当前目录下所有文件夹的大小 -d 指深度，后面加一个数值\n\n   ```shell\n   du -d 1 -h\n   ```\n","categories":["linux"]},{"title":"linux进程管理","url":"/2020/05/11/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","content":"\n## 后台运行\n\nshell 中执行命令若以`&`结尾，则程序会在后台执行，当用户退出时该后台程序会停止运行。若需要程序永久运行可以使用`nohup`\n可使用`jobs`查看正在运行的作业，然后可以使用`fg %n`(n 为作业编号)将后台任务返回前台\n\nCtrl+c 是强制中断程序的执行。\nCtrl+z 的是将任务中断,但是此任务并没有结束,他仍然在进程中他只是维持挂起的状态。\n\nCtrl+z 的程序也可以使用`fg`将其返回前台\n\n`jobs -l`显示`pid`\n\n## 查询进程\n\n1. 查询正在运行的进程信息\n\n   ```shell\n   ps -ef\n   ```\n\n2. 查询归属于用户 colin115 的进程\n\n   ```shell\n   ps -ef | grep colin115\n   ps -lu colin115\n   ```\n\n3. 查询进程 ID（适合只记得部分进程字段）\n\n   ```shell\n   pgrep <name>\n\n   ```\n\n4. 以完整的格式显示所有的进程\n\n   ```shell\n   ps -ajx\n   ```\n\n5. 显示进程内存占用\n\n   ```shell\n   ps -aux\n   ```\n\n6. 查看端口占用的进程状态：\n\n   ```shell\n   lsof -i:3306\n   ```\n\n7. 查看用户 username 的进程所打开的文件\n\n   ```shell\n   lsof -u username\n   ```\n\n8. 查询 init 进程当前打开的文件\n\n   ```shell\n   lsof -c init\n   ```\n\n9. 查询指定的进程 ID(23295)打开的文件：\n\n   ```shell\n   lsof -p 23295\n   ```\n\n10. 查询指定目录下被进程开启的文件（使用+D 递归目录）：\n\n    ```shell\n    lsof +d mydir1/\n    ```\n\n## 杀进程\n\nkill 命令可向进程发送指定的信号（默认发送的信号是 SIGTERM）。`kill -l`：显示信号的信息，我们常用的`kill -9`就是`SIGKILL`信号\n\n## 分析进程\n\n### pstack\n\n此命令可显示每个进程的栈跟踪，`pstack <pid>`,这个命令在排查进程问题时非常有用，比如我们发现一个服务一直处于 work 状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在；可以在一段时间内，多执行几次 pstack，若发现代码栈总是停在同一个位置，那个位置就需要重点关注，很可能就是出问题的地方；\n\n## 常用命令\n\n### 快速杀进程\n\n```shell\nps -ef|grep java|grep -v grep|awk '{print \"kill -9 \"$2}'|sh\n```\n","categories":["linux"],"tags":["linux","进程"]},{"title":"linux环境变量","url":"/2020/05/11/linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","content":"\n## 配置文件加载\n\n### login shell\n\n`login shell`是需要用户输入账号和密码进入`shell`，进行一个完整的登录流程。这种登录方式加载配置文件的方式如下\n\n1. 加载全局配置文件`/etc/profile`\n2. 加载用户配置文件，~/.bash_profile 或 ~/.bash_login 或~/.profile。上述三个文件只会读取一个，优先级依次降低\n   login shell 是说在取得 bash 时需要完整的登陆流程。什么时候取得 bash 呢？当然就是用户登陆的时候。当你在 tty1~tty6 登陆，需要输入账号和密码，此时取得的 bash 就是 login shell。\n\n### non-login shell\n\n`non-login shell` 就是取得 bash 不需要重复登录，就像你在桌面视图中用`ctrl+alt+T`启动的 shell 输入窗口就是`non-login shell`。还有就是你在 shell 窗口直接 su 切换的用户，都属于`non-login shell`。\n`non-login shell` 只会读取~/.bashrc 这个文件\n\n> 当使用`su <user>`切换用户的时，是以`non-login shell`的方式取得 bash 的，所以你的环境变量 PATH 等是不会改变的，如果你需要读取`/etc/profile`的话， 你需要用`su - <user>`的方式登录。`su -`就是`su -l`即`su --login`的意思\n> 配置文件修改后需要使用`source`命令让它立即生效，例如`source ~/.bashrc`\n\n## 相关配置\n\n### 设定文件日期显示格式\n\n1、编辑全局配置文件：/etc/profile，使所有用户均显示该格式：\n\n```shell\n#vi  /etc/profile\nexport TIME_STYLE=\"+%Y-%m-%d %H:%M:%S\"\n```\n\n### `PATH`\n\n当程序在`PATH`的目录中且具有执行权限的时候，就可以在任意地方直接运行\n","categories":["linux"],"tags":["linux","环境变量"]},{"title":"node入门","url":"/2020/05/08/node%E5%85%A5%E9%97%A8/","content":"\n## `npm`\n\nNPM 是随同 NodeJS 一起安装的包管理工具, `nodejs`的包管理器，用于 node 插件管理，包括安装，卸载，管理依赖等\n\n### 用 npm 命令安装模块\n\nnpm 安装 Node.js 模块语法格式如下：\n\n```shell\nnpm install <Module Name>\n```\n\nnpm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g 而已，比如\n\n```shell\nnpm install express          # 本地安装\nnpm install express -g   # 全局安装\n\n```\n\n#### 本地安装\n\n1. 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。\n2. 可以通过 require() 来引入本地安装的包。\n3. 可通过`npm list`查看项目安装的模块\n\n#### 全局安装\n\n1. 将安装包放在 /usr/local 下或者你 node 的安装目录。\n2. 可以直接在命令行里使用。\n3. 可通过`npm root -g`查看所有全局安装的模块的目录：\n4. 可通过`npm list -g`查看全局安装的模块\n\n### 使用 package.json\n\npackage.json 位于模块的目录下，用于定义包的属性\n\n`npm init` 初始化，生成`package.json`\n\n#### Package.json 属性说明\n\n> name - 包名。\n> version - 包的版本号。\n> description - 包的描述。\n> scripts 使用`npm run command`实际执行其配置的值。例如`{\"dev\": \"node build/dev-server.js\"}`\n> homepage - 包的官网 url 。\n> author - 包的作者姓名。\n> contributors - 包的其他贡献者姓名。\n> dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。\n> repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。\n> main - main 字段指定了程序的主入口文件，require('moduleName') 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。\n> keywords - 关键字\n\n安装软件时可以将模块的依赖写入`package.json`的节点下\n\n1. `-S` `-s` `--save` 将安装包信息加入到`dependencies`\n2. `-D` `-d` `--save --dev` 将安装包信息加入`devDependencies`\n\n## 事件驱动\n\nNode.js 基本上所有的事件机制都是用设计模式中观察者模式实现。\nNode.js 单线程类似进入一个 while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.\n![node入门_2020-05-09-17-16-32.png](./images/node入门_2020-05-09-17-16-32.png)\n\nNode.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：\n\n```javascript\n// 引入 events 模块\nvar events = require(\"events\");\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();\n```\n\n以下程序绑定事件处理程序：\n\n```javascript\n// 绑定事件及事件的处理程序\neventEmitter.on(\"eventName\", eventHandler);\n```\n\n我们可以通过程序触发事件：\n\n```javascript\n// 触发事件\neventEmitter.emit(\"eventName\");\n```\n\n## Stream(流)\n\nStream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对 http 服务器发起请求的 request 对象就是一个 Stream，还有 stdout（标准输出）。\nNode.js，Stream 有四种流类型：\n\n- Readable - 可读操作。\n- Writable - 可写操作。\n- Duplex - 可读可写操作.\n- Transform - 操作被写入数据，然后读出结果。\n\n所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：\n\n- data - 当有数据可读时触发。\n- end - 没有更多的数据可读时触发。\n- error - 在接收和写入过程中发生错误时触发。\n- finish - 所有数据已被写入到底层系统时触发。\n\n### 从流中读取数据\n\n创建 input.txt 文件，内容如下：\n\n> 菜鸟教程官网地址：www.runoob.com\n> 创建 main.js 文件, 代码如下：\n\n```javascript\nvar fs = require(\"fs\");\nvar data = \"\";\n\n// 创建可读流\nvar readerStream = fs.createReadStream(\"input.txt\");\n\n// 设置编码为 utf8。\nreaderStream.setEncoding(\"UTF8\");\n\n// 处理流事件 --> data, end, and error\nreaderStream.on(\"data\", function (chunk) {\n  data += chunk;\n});\n\nreaderStream.on(\"end\", function () {\n  console.log(data);\n});\n\nreaderStream.on(\"error\", function (err) {\n  console.log(err.stack);\n});\n\nconsole.log(\"程序执行完毕\");\n```\n\n以上代码执行结果如下：\n\n> 程序执行完毕\n> 菜鸟教程官网地址：www.runoob.com\n\n### 写入流\n\n创建 main.js 文件, 代码如下：\n\n```javascript\nvar fs = require(\"fs\");\nvar data = \"菜鸟教程官网地址：www.runoob.com\";\n\n// 创建一个可以写入的流，写入到文件 output.txt 中\nvar writerStream = fs.createWriteStream(\"output.txt\");\n\n// 使用 utf8 编码写入数据\nwriterStream.write(data, \"UTF8\");\n\n// 标记文件末尾\nwriterStream.end();\n\n// 处理流事件 --> data, end, and error\nwriterStream.on(\"finish\", function () {\n  console.log(\"写入完成。\");\n});\n\nwriterStream.on(\"error\", function (err) {\n  console.log(err.stack);\n});\n\nconsole.log(\"程序执行完毕\");\n```\n\n以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：\n\n> node main.js\n> 程序执行完毕\n> 写入完成。\n\n查看 output.txt 文件的内容：\n\n> cat output.txt\n> 菜鸟教程官网地址：www.runoob.com\n\n### 管道流\n\n管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。\n\n设置 input.txt 文件内容如下：\n\n> 菜鸟教程官网地址：www.runoob.com\n> 管道流操作实例\n\n创建 main.js 文件, 代码如下：\n\n```javascript\nvar fs = require(\"fs\");\n\n// 创建一个可读流\nvar readerStream = fs.createReadStream(\"input.txt\");\n\n// 创建一个可写流\nvar writerStream = fs.createWriteStream(\"output.txt\");\n\n// 管道读写操作\n// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中\nreaderStream.pipe(writerStream);\n\nconsole.log(\"程序执行完毕\");\n```\n\n代码执行结果如下：\n\n> node main.js\n> 程序执行完毕\n\n查看 output.txt 文件的内容：\n\n> cat output.txt\n> 菜鸟教程官网地址：www.runoob.com\n\n### 管道流操作实例\n\n链式流\n链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。\n接下来我们就是用管道和链式来压缩和解压文件。\n创建 compress.js 文件, 代码如下：\n\n```javascript\nvar fs = require(\"fs\");\nvar zlib = require('zlib');\n\n// 压缩 input.txt 文件为 input.txt.gz\nfs.createReadStream('input.txt')\n  .pipe(zlib.createGzip())\n  .pipe(fs.createWriteStream('input.txt.gz'));\n\nconsole.log(\"文件压缩完成。\");\n代码执行结果如下：\n$ node compress.js\n文件压缩完成。\n执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。\n接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：\nvar fs = require(\"fs\");\nvar zlib = require('zlib');\n\n// 解压 input.txt.gz 文件为 input.txt\nfs.createReadStream('input.txt.gz')\n  .pipe(zlib.createGunzip())\n  .pipe(fs.createWriteStream('input.txt'));\n\nconsole.log(\"文件解压完成。\");\n```\n\n代码执行结果如下：\n\n> node decompress.js\n> 文件解压完成。\n\n## 模块系统\n\n模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展。Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。\n\n### require\n\n引入其他模块\n\n```javascript\nvar http = require(\"http\");\nhttp\n  .createServer(function (request, response) {\n    // 发送 HTTP 头部\n    // HTTP 状态值: 200 : OK\n    // 内容类型: text/plain\n    response.writeHead(200, { \"Content-Type\": \"text/plain\" });\n\n    // 发送响应数据 \"Hello World\"\n    response.end(\"Hello World\\n\");\n  })\n  .listen(8888);\n\n// 终端打印如下信息\nconsole.log(\"Server running at http://127.0.0.1:8888/\");\n```\n\n引入 json 文件\n\n```javascript\nvar data = require(\"./data.json\");\n```\n\n### exports\n\n创建 hello.js 文件，代码如下：\n\n```javascript\nexports.world = function () {\n  console.log(\"Hello World\");\n};\n```\n\n则我们可以在代码中引用该模块的方法\n\n```javascript\nvar hello = require(\"./hello\");\nhello.world();\n```\n\n在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require('./hello') 加载这个模块，然后就可以直接访问 hello.js 中 exports 对象的成员函数了。\n有时候我们只是想把一个对象封装到模块中，格式如下：\n\n```javascript\nmodule.exports = function () {\n  // ...\n};\n```\n\n模块接口的唯一变化是使用 module.exports = Hello 代替了 exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports\n\n### 模块的加载过程\n\n由于 Node.js 中存在 4 类模块（原生模块和 3 种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：\n![node入门_2020-05-12-20-57-08.png](./images/node入门_2020-05-12-20-57-08.png)\n\n#### 从文件模块缓存中加载\n\n尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块。\n\n#### 从原生模块加载\n\n原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在原生模块列表中。以 http 模块为例，尽管在目录下存在一个 http/http.js/http.node/http.json 文件，require(\"http\") 都不会从这些文件中加载，而是从原生模块中加载。\n原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。\n\n#### 从文件加载\n\n当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 require 方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。\nrequire 方法接受以下几种参数的传递：\n\n- http、fs、path 等，原生模块。\n- ./mod 或../mod，相对路径的文件模块。\n- /pathtomodule/mod，绝对路径的文件模块。\n- mod，非原生模块的文件模块。\n  在路径 Y 下执行 require(X) 语句执行顺序：\n\n```shell\n1. 如果 X 是内置模块\n   a. 返回内置模块\n   b. 停止执行\n2. 如果 X 以 '/' 开头\n   a. 设置 Y 为文件根路径\n3. 如果 X 以 './' 或 '/' or '../' 开头\n   a. LOAD_AS_FILE(Y + X)\n   b. LOAD_AS_DIRECTORY(Y + X)\n4. LOAD_NODE_MODULES(X, dirname(Y))\n5. 抛出异常 \"not found\"\n\nLOAD_AS_FILE(X)\n1. 如果 X 是一个文件, 将 X 作为 JavaScript 文本载入并停止执行。\n2. 如果 X.js 是一个文件, 将 X.js 作为 JavaScript 文本载入并停止执行。\n3. 如果 X.json 是一个文件, 解析 X.json 为 JavaScript 对象并停止执行。\n4. 如果 X.node 是一个文件, 将 X.node 作为二进制插件载入并停止执行。\n\nLOAD_INDEX(X)\n1. 如果 X/index.js 是一个文件,  将 X/index.js 作为 JavaScript 文本载入并停止执行。\n2. 如果 X/index.json 是一个文件, 解析 X/index.json 为 JavaScript 对象并停止执行。\n3. 如果 X/index.node 是一个文件,  将 X/index.node 作为二进制插件载入并停止执行。\n\nLOAD_AS_DIRECTORY(X)\n1. 如果 X/package.json 是一个文件,\n   a. 解析 X/package.json, 并查找 \"main\" 字段。\n   b. let M = X + (json main 字段)\n   c. LOAD_AS_FILE(M)\n   d. LOAD_INDEX(M)\n2. LOAD_INDEX(X)\n\nLOAD_NODE_MODULES(X, START)\n1. let DIRS=NODE_MODULES_PATHS(START)\n2. for each DIR in DIRS:\n   a. LOAD_AS_FILE(DIR/X)\n   b. LOAD_AS_DIRECTORY(DIR/X)\n\nNODE_MODULES_PATHS(START)\n1. let PARTS = path split(START)\n2. let I = count of PARTS - 1\n3. let DIRS = []\n4. while I >= 0,\n   a. if PARTS[I] = \"node_modules\" CONTINUE\n   b. DIR = path join(PARTS[0 .. I] + \"node_modules\")\n   c. DIRS = DIRS + DIR\n   d. let I = I - 1\n5. return DIRS\n```\n\n## 路由\n\n路由简单来说是一个请求的 uri 地址与相对应的 function 的映射表\n\n```javascript\nvar http = require(\"http\");\nvar url = require(\"url\");\n\nfunction start(route) {\n  function onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    // true 返回dict\n    var paramertes = url.parse(request.url, true).query;\n    console.log(\"Request for \" + pathname + \" received.\");\n\n    route(pathname);\n\n    response.writeHead(200, { \"Content-Type\": \"text/plain\" });\n    response.write(\"Hello World\");\n    response.end();\n  }\n\n  http.createServer(onRequest).listen(8888);\n  console.log(\"Server has started.\");\n}\n\nexports.start = start;\n```\n\n路由中可以根据`pathname`调用对应的函数去处理\n\n```javascript\nfunction route(pathname) {\n  console.log(\"About to route a request for \" + pathname);\n}\n\nexports.route = route;\n```\n\n```javascript\nvar server = require(\"./server\");\nvar router = require(\"./router\");\n\nserver.start(router.route);\n```\n","categories":["前端"],"tags":["node"]},{"title":"java多线程","url":"/2020/04/25/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","content":"\n## 线程状态\n\n### 新建(NEW)\n\n新创建了一个线程对象。实现 Runnable 接口和继承 Thread 可以得到一个线程类，new 一个实例出来，线程就进入初始状态。\n\n### 可运行(RUNNABLE)\n\n线程对象创建后，由其他线程(比如 main 线程)调用了 start 方法，该状态的线程位于可运行线程池中，等待被线程调度选中，获取 CPU 的使用权。\n\n    1. 可运行状态只说你有资格运行，CPU 调度程序没有挑选到，永远处于可运行状态。\n    2. 调用线程的 start 方法，此线程进入可运行状态。\n    3. 当前线程的 sleep()方法，其他线程 join 方法结束，此线程进入可运行状态。\n    4. 锁池的线程获取到对象锁，此线程进入可运行状态。\n    5. 当前线程时间片用完了，或者调用线程的 yield 方法，当前线程进入可运行状态。\n\n### 运行(RUNNING)\n\n可运行状态的线程获取了 CPU 时间片(timeslice)，执行程序代码。线程调度程序从可运行线程池中挑选一个线程作为作为当前线程所处的状态，这也是线程进入运行状态的唯一方法。\n\n### 阻塞(BLOCKED)\n\n阻塞状态是指线程由于某种原因放弃了 CPU 使用权，也即让出了 CPU 时间片，暂时停止运行。直到线程再次进入可运行(RUNNABLE)状态，才有机会再次获得 CPU 时间片转到运行(RUNNING)状态。阻塞的情况分三种：\n\n    1. 等待阻塞:运行(RUNNING)状态的线程执行 wait()方法，JVM 会把该线程放入等待队列(waitting queue)中，同时释放对象的同步锁。\n    2. 同步阻塞:运行(RUNNING)状态的线程在获取对象的同步锁时，若该线程的同步锁被别的线程占用，则 JVM 会把该线程放入锁池(LOCK POOL)中。\n    3. 其他阻塞:运行(RUNNING)状态的线程执行 sleep 或 join 方法，JVM 会把该线程设置为阻塞(BLOCKED)状态，当 sleep 超时，join 等待线程终止或超时，该线程重新转入可运行(RUNNABLE)状态。\n\n### 死亡(DEAD)\n\n线程 run 方法结束，main 方法结束，或者异常原因退出了 run 方法，则该线程结束生命周期，死亡的线程不可再次复生。在一个死去的线程上调用 start 方法，会抛出 java.lang.IllegalThreadStateException 异常。\n\n线程状态图\n![线程状态及切换_2020-04-25-13-31-15.png](./images/线程状态及切换_2020-04-25-13-31-15.png)\n\n## 线程锁竞争过程\n\n### 概述\n\n线程锁竞争过程如图\n![java多线程_2020-04-25-13-37-56.png](./images/java多线程_2020-04-25-13-37-56.png)\n\n1. 当前线程想调用 A 的同步方法时，发现对象 A 被别的线程占有，此时当前线程会进入锁池状态。锁池里面存放的都是想争夺对象 A 的线程。\n2. 当线程 1 被另外一个线程唤醒时，会进入锁池争夺对象 A 的锁。\n3. 锁池是在同步的环境下才有的概念，一个对象对应一个锁池。\n\n### 多线程的几个方法的比较\n\n1. Thread.sleep(long millis),一定是当前线程调用次方法，当前线程进入阻塞状态，但不释放对象锁，millis 时间到后，自动进入可运行状态。作用：给其它线程执行机会的最佳方式。\n2. Thread.yield(),一定是当前线程调用次方法，当前线程放弃 CPU 时间片，由运行状态变成可运行状态。yield 不会导致阻塞，也无法保证下一次 CPU 不去挑选该线程执行。\n3. t.join(long millis),当前线程==(正在 CPU 时间片执行的线程==)里调用其它线程的 join 方法，当前线程进入阻塞状态，但不会释放对象锁，当其它线程执行结束，或 millis 时间到，当前线程进入可运行状态。\n4. obj.wait(),当前线程调用对象的 wait 方法，当前对象释放对象锁，进入等待队列(阻塞状态)。等待其它线程调用 notify 或 notifyAll，或者 wait(long timeout)timeout 时间到自动释放唤醒，进入锁池争夺对象锁。\n5. obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll 会唤醒在此对象监视器上等待的所有线程。\n\n### 关于中断\n\n1. 它不会像 stop 方法一样中断一个正在运行的线程。线程会不时的监测中断标识，以判断程序是否应该被中断(中断标识值是否为 true)。中断只会影响 wait sleep join 状态的线程，被中断后会抛出 java.lang.IllegalThreadStateException 异常。\n2. synchronized 在获取锁的过程中是不能被中断的。\n3. 中断是一种状态，interrupt()方法只是讲讲这个状态设置为 true，所以说正常执行的代码如果不去检测中断标识，是不会被终止运行的。而 wait 等阻塞方法，会去检测并抛出异常。如果正常运行的代码添加 while(!interrupted()),则同样可以在中断后离开代码体。\n\n### Java wait() notify()方法使用实例讲解\n\n    1. wait()、notify()和 notifyAll()方法是本地方法，并且为 final 方法，无法被重写。\n    2. 调用某个对象的 wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的 monitor（即锁，或者叫管程）\n    3. 调用某个对象的 notify()方法能够唤醒一个正在等待这个对象的 monitor 的线程，如果有多个线程都在等待这个对象的 monitor，则只能唤醒其中一个线程；\n    4. 调用 notifyAll()方法能够唤醒所有正在等待这个对象的 monitor 的线程；\n\n​ 在 java 中，是没有类似于 PV 操作、进程互斥等相关的方法的。JAVA 的进程同步是通过 synchronized()来实现的，需要说明的是，Java 的 synchronized()方法类似于操作系统概念中的互斥内存块，在 Java 中的 Object 类对象中，都是带有一个内存锁的，在有线程获取该内存锁后，其它线程无法访问该内存，从而实现 Java 中简单的同步、互斥操作。明白这个原理，就能理解为什么 synchronized(this)与 synchronized(static XXX)的区别了，synchronized 就是针对内存区块申请内存锁，this 关键字代表类的一个对象，所以其内存锁是针对相同对象的互斥操作，而 static 成员属于类专有，其内存空间为该类所有成员共有，这就导致 synchronized()对 static 成员加锁，相当于对类加锁，也就是在该类的所有成员间实现互斥，在同一时间只有一个线程可访问该类的实例。如果需要在线程间相互唤醒就需要借助 Object 类的 wait()方法及 nofity()方法。\n\n说了这么一堆，可能似懂非懂，那么接下来用一个例子来说明问题，用多线程实现连续的 1,2,1,2,1,2,1,2,1,2 输出。\n\n    ```java\n\n    class NumberPrint implements Runnable{\n        private int number;\n        public byte res[];\n        public static int count = 5;\n        public NumberPrint(int number, byte a[]){\n            this.number = number;\n            res = a;\n        }\n        public void run(){\n            synchronized (res){\n                while(count-- > 0){\n                    try {\n                        res.notify();//唤醒等待res资源的线程，把锁交给线程（该同步锁执行完毕自动释放锁）\n                        System.out.println(\" \"+number);\n\n                        res.wait();//释放CPU控制权，释放res的锁，本线程阻塞，等待被唤醒。\n                        System.out.println(\"------线程\"+Thread.currentThread().getName()+\"获得锁，wait()后的代码继续运行：\"+number);\n                    } catch (InterruptedException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                    }\n                }//end of while\n                return;\n            }//synchronized\n\n        }\n    }\n    public class WaitNotify {\n        public static void main(String args[]){\n            final byte a[] = {0};//以该对象为共享资源\n            new Thread(new NumberPrint((1),a),\"1\").start();\n            new Thread(new NumberPrint((2),a),\"2\").start();\n        }\n    }\n\n    ```\n\n输出结果：\n\n> 1\n> 2\n> ------线程 1 获得锁，wait()后的代码继续运行：1\n> 1\n> ------线程 2 获得锁，wait()后的代码继续运行：2\n> 2\n> ------线程 1 获得锁，wait()后的代码继续运行：1\n> 1\n> ------线程 2 获得锁，wait()后的代码继续运行：2\n\n下面解释为什么会出现这样的结果：\n\n首先 1、2 号线程启动，这里假设 1 号线程先运行 run 方法获得资源（实际上是不确定的），获得对象 a 的锁，进入 while 循环（用于控制输出几轮）：\n\n1、此时对象调用它的唤醒方法 notify()，意思是这个同步块执行完后它要释放锁，把锁交给等待 a 资源的线程；\n\n2、输出 1；\n\n3、该对象执行等待方法，意思是此时此刻起拥有这个对象锁的线程（也就是这里的 1 号线程）释放 CPU 控制权，释放锁，并且线程进入阻塞状态，后面的代码暂时不执行，因未执行完同步块，所以 1 也没起作用；\n\n4、在这之前的某时刻线程 2 运行 run 方法，但苦于没有获得 a 对象的锁，所以无法继续运行，但 3 步骤之后，它获得了 a 的锁，此时执行 a 的唤醒方法 notify(),同理，意思是这个同步块执行完后它要释放锁，把锁交给等待 a 资源的线程；\n\n5、输出 2；\n\n6、执行 a 的等待方法，意思是此时此刻起拥有这个对象锁的线程（也就是这里的 2 号线程）释放 CPU 控制权，释放锁，并且线程进入阻塞状态，后面的代码暂时不执行，因未执行完同步块，所以 2 号线程的 4 步骤的唤醒方法也没起作用；\n\n7、此时 1 号线程执行到 3 步骤，发现对象锁没有被使用，所以继续执行 3 步骤中 wait 方法后面的代码，于是输出：------线程 1 获得锁，wait()后的代码继续运行：1；\n\n8、此时 while 循环满足条件，继续执行，所以，再执行 1 号线程的唤醒方法，意思是这个同步块执行完后它要释放锁；\n\n9、输出 1；\n\n10、执行等待方法，线程 1 阻塞，释放资源锁；\n\n11、此时线程 2 又获得了锁，执行到步骤 6，继续执行 wait 方法后面的代码，所以输出：------线程 2 获得锁，wait()后的代码继续运行：2；\n\n12、继续执行 while 循环，输出 2；\n\n··· ···\n\n通过上述步骤，相信大家已经明白这两个方法的使用了，但该程序还存在一个问题，当 while 循环不满足条件时，肯定会有线程还在等待资源，所以主线程一直不会终止。当然这个程序的目的仅仅为了给大家演示这两个方法怎么用。\n\n总结：\n\n​ wait()方法与 notify()必须要与 synchronized(resource)一起使用。也就是 wait 与 notify 针对已经获取了 resource 锁的线程进行操作，从语法角度来说就是 Obj.wait(),Obj.notify 必须在 synchronized(Obj){...}语句块内。从功能上来说 wait()线程在获取对象锁后，主动释放 CPU 控制权，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的 notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的 notify()就是对对象锁的释放操作。【因此，我们可以发现，wait 和 notify 方法均可释放对象的锁，但 wait 同时释放 CPU 控制权，即它后面的代码停止执行，线程进入阻塞状态，而 notify 方法不立刻释放 CPU 控制权，而是在相应的 synchronized(){}语句块执行结束，再自动释放锁。】释放锁后，JVM 会在等待 resoure 的线程中选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与 Object.wait()二者都可以暂停当前线程，释放 CPU 控制权，主要的区别在于 Object.wait()在释放 CPU 同时，释放了对象锁的控制，而在同步块中的 Thread.sleep()方法并不释放锁，仅释放 CPU 控制权。\n\n## volatile\n\n多线程的内存模型，main memory(主存)，working memory(线程栈)，在处理数据时，线程会把值从主存 load 到本地栈，完成操作后，再 save 回去。(volatile 关键字的作用就是在一个 CPU 时间片内，针对变量的操作都触发一次完整的 load 和 save)。针对多线程使用的变量如果不是 volatile 或 final 修饰的，可能发生不可预料的后果(某个线程修改了变量，但之后的线程 load 到的是变量修改前的数据)。其实本质上来说，同一实例的同一属性只会有一个副本，但多线程会缓存值，volatile 的作用就是不去缓存值。在线程安全的情况下，用 volatile 会牺牲性能。\n![java多线程_2020-04-25-13-50-12.png](./images/java多线程_2020-04-25-13-50-12.png)\n\nvolatile 底层实现最终是加了内存屏障\n![java多线程_2020-04-25-13-55-07.png](./images/java多线程_2020-04-25-13-55-07.png)\n\n    1. 保证写 volatile 变量强制把 CPU 写缓存区的数据刷新到内存\n    2. 读 volatile 变量时，使缓存失效，强制从内存中读取数据。\n    3. 由于内存屏障的作用，volatile 变量还能阻止重排序。\n\n## 指令重排\n\n现代处理器都会采用指令乱序执行(Out of Order Execution ，简称 OOE)的方法，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据的等待，通过乱序执行的技术，处理器可以大大提高执行效率\n\n### AS-IF-SERIAL\n\n所有的动作(aciton)都可以为了优化而被重新排序，但是必须保证它们重新排序后的执行结果和程序代码本身应有的结果一致。Java 编译器，运行时和处理器都会保证单线程运行下的 as-if-serial 语义。为了保证这一语义，重排序不会发生在有数据依赖的操作中。\n\n    ```java\n    int a = 1;\n    int b = 1;\n    int c = a + b;\n    ```\n\n将上面的代码编译成 java 字节码或生成机器指令，可视为以下几步动作(实际可能会忽略或添加某些步骤)\n\n> 对 a 赋值 1\n> 对 b 赋值 1\n> 取 a 值\n> 取 b 值\n> 取到的两值相加后赋值给 c\n\n在上面 5 个操作，操作 1 可能和操作 2、操作 4 重排序，操作 2 可能和操作 1、操作 3 重排序，操作 3 可能和操作 2、操作 4 重排序，操作 4 可能和操作 1、操作 3 重排序。但操作 1 不能和操作 3、操作 5 重排序，操作 2 不能和操作 4、操作 5 重排序。因为它们存在数据依赖性，一旦重排序， as-if-serial 语义无法得到保证。\n\n### 内存屏障\n\n由于现代的处理器系统都是多处理器，而每一个处理器都有自己的缓存，并且这些缓存并不是实时和内存发生信息交换，这样就可能出现一个 CPU 的缓存数据和另一个 CPU 缓存数据不一致的问题。而这样在多线程开发中，就有可能造成一些异常问题。\n\n而操作系统底层为了解决这样的问题，提供了一些内存屏障解决这些问题，目前有四种内存屏障\n\n1. LoadLoad 内存屏障:对于这样的语句 Load1 LoadLoad Load2 ，在 Load2 及后续操作要读取的数据被访问前，保证 Load1 要读取的数据加载完成。\n2. StoreStore 内存屏障:对于这样的语句 Store1 StoreStore Store2，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其它处理器可见。\n3. LoadStore 内存屏障:对于这样的语句 Load1 LoadStore Store2，在 Store2 及后续写入操作执行前，保证 Load1 要读取的数据加载完成。\n4. StoreLoad 内存屏障:对于这样的语句 Store1 StoreLoad Load2，在 Load2 及后续操作要读取的数据被访问前，保证 Store1 的写入操作对其它处理器可见。\n\n### 使用\n\n1. 通过 synchronized 关键词包含的代码区域，当线程进入该区域读取变量信息时，保证读取到的是最新的值。这是因为在同步区内的写入操作，在离开同步区时就将当前线程的数据刷新到内存中，而对数据的读取也不能从缓存中读取，只能从内存中读取，这样就保证了数据读取的有效性，这就插入了 StoreStore 内存屏障。\n2. 使用了 volatile 关键字修饰的变量，在进行写入操作时，会插入 StoreLoad 内存屏障。\n3. Unsafe.putOrderedObject 类似这样的方法,会插入 StoreStore 内存屏障\n4. Unsafe.putVolatiObject 则是插入了 StoreLoad 屏障\n","categories":["java"],"tags":["多线程"]},{"title":"尾调用优化","url":"/2020/04/23/%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96/","content":"\n## 尾调用优化\n\n尾调用之所以与其他调用不同，就在于它的特殊的调用位置。\n\n我们知道，函数调用会在内存形成一个\"调用记录\"，又称\"调用帧\"（call frame），保存调用位置和内部变量等信息。如果在函数 A 的内部调用函数 B，那么在 A 的调用记录上方，还会形成一个 B 的调用记录。等到 B 运行结束，将结果返回到 A，B 的调用记录才会消失。如果函数 B 内部还调用函数 C，那就还有一个 C 的调用记录栈，以此类推。所有的调用记录，就形成一个[\"调用栈\"](http://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88)（call stack）。\n![尾调用优化_2020-04-23-17-20-39.png](./images/尾调用优化_2020-04-23-17-20-39.png)\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。\n\n```javascript\nfunction f() {\n  let m = 1;\n  let n = 2;\n  return g(m + n);\n}\nf();\n\n// 等同于\nfunction f() {\n  return g(3);\n}\nf();\n\n// 等同于\ng(3);\n```\n\n上面代码中，如果函数 g 不是尾调用，函数 f 就需要保存内部变量 m 和 n 的值、g 的调用位置等信息。但由于调用 g 之后，函数 f 就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。\n\n这就叫做\"尾调用优化\"（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是\"尾调用优化\"的意义。\n\n## 尾递归\n\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生\"栈溢出\"错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生\"栈溢出\"错误。\n\n```javascript\nfunction factorial(n) {\n  if (n === 1) return 1;\n  return n * factorial(n - 1);\n}\n\nfactorial(5); // 120\n```\n\n上面代码是一个阶乘函数，计算 n 的阶乘，最多需要保存 n 个调用记录，复杂度 O(n) 。\n如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。\n\n```javascript\nfunction factorial(n, total) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5, 1); // 120\n```\n\n由此可见，\"尾调用优化\"对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署\"尾调用优化\"。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。\n![尾调用优化_2020-04-23-17-21-00.png](./images/尾调用优化_2020-04-23-17-21-00.png)\n\n## 递归函数的改写\n\n尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算 5 的阶乘，需要传入两个参数 5 和 1？\n\n两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。\n\n```javascript\nfunction tailFactorial(n, total) {\n  if (n === 1) return total;\n  return tailFactorial(n - 1, n * total);\n}\n\nfunction factorial(n) {\n  return tailFactorial(n, 1);\n}\n\nfactorial(5); // 120\n```\n","categories":["tips"],"tags":["tips"]},{"title":"快捷键","url":"/2020/04/23/%E5%BF%AB%E6%8D%B7%E9%94%AE/","content":"\n## safari\n\n1. ⌃1 #显示或隐藏收藏夹\n2. ⌃3 #切换 ipad 视图\n3. ⇧⌘D #添加当前页面到阅读列表\n4. ⌘/ #显示所有标签页\n5. ⌃f #全屏\n\n## iTerm2\n\n### 切换编辑模式\n\n```shell\n# Emacs mode\nbindkey -e\n\n# Vi mode\nbindkey -v\n```\n\n### 自动完成\n\niTerm2 可以自动补齐命令，输入若干字符，按 ⌘+;弹出自动补齐窗口，列出曾经使用过的命令\n\n### 分屏\n\n垂直分屏：command + d\n\n水平分屏：command + shift + d\n\n切换屏幕：command + option + 方向键 command + [ 或 command + ]\n\n## chrome\n\n### 截图\n\n1. F12\n2. cmmand+shift+p\n3. 输入“capture”\n4. 选择以下任意\n\n   > 1）“ capture full size screenshot”【整个网页】\n   > 2）“capture node screenshot”【节点网页】\n   > 3）“capture screenshot”【当前屏幕】\n","categories":["tips"],"tags":["快捷键"]},{"title":"db2","url":"/2020/04/23/db2/","content":"\n### 导出表结构\n\n```shell\ndb2look -d dbname -e -a -x -i username -w password -o ddlfile.sql\n#该语句会导出所有表结构\n```\n\n### 执行 sql 文件\n\n```shell\n    db2 –tvf script1.sql –z script1.log  #需转化为unix格式文本\n```\n\n在上面的命令中，\n\n-t 表示语句使用默认的语句终结符——分号；\n　　-v 表示使用冗长模式，这样 DB2 会显示每一条正在执行命令的信息；\n　　-f 表示其后就是脚本文件；\n　　-z 表示其后的信息记录文件用于记录屏幕的输出，方便以后的分析（这是可选的，但我们建议使用该选项）。\n　　当使用了-t 选项而没有标明语句终结符，则分号（；）会默认为语句的终结符。有时可能会出现使用另外的终结符的情况，例如用 SQL PL 编写的的脚本使用其它的符号而不是默认的分号，因为分号在 SQL PL 是用于定义数据库对象过程中的语句结束。\n","categories":["db"],"tags":["db2"]},{"title":"mysql","url":"/2020/04/23/mysql/","content":"\n设定字段为一个枚举\n\n```mysql\ncreate table test (\n  sex enum (\"男\",\"女\")\n)\n```\n\n表字段可以设置默认值，当未插入数据时用默认值\n\n```mysql\nCREATE TABLE tb_emp1(\n  id int(11) AUTO_INCREMENT,\n  name VARCHAR(25),\n  deptId INT(11) DEFAULT 1234,\n  salary FLOAT,\n  PRIMARY KEY (id)\n);\n```\n\nmysql 如何得到一条记录在所有记录的第几行\n\n```mysql\n#mysql本身是没有行号的。要想得到查询语句返回的列中包含一列表示该行记录在整个结果集中的行号可以通过自定义set一个变量，然后每条记录+1的方式，返回这个变量的值。\n\nSET @t = 0;\nSELECT * FROM (SELECT (@t:=@t+1) as id,s FROM t1) AS A WHERE a.id=2 OR a.id=5;\n\n```\n\n从 dump 文件恢复数据\n\n```mysql\nmysqldump -uroot -pPassword [database name] > [dump file]\n```\n\n更改编码\n\n```mysql\nstatus;#查看编码\nalter database db_name CHARACTER SET utf8;\n```\n\n==数据库直接操作时养成习惯不管干啥都先敲个 begin; 确认没问题了再 commit;==\n\n查看数据库信息\n\n```mysql\nshow variables;\nshow variables like 'character%';\n```\n","categories":["db"],"tags":["tips","mysql"]},{"title":"java类加载机制","url":"/2020/04/23/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","content":"\n## Java 类加载器\n\n每个 Java 文件都存储着需要执行的程序逻辑，这些 java 文件经过 Java 编译器编译成 class 文件，class 文件中保存着 JVM 虚拟机指令，当需要某个类时，虚拟机将会加载它的 class 文件，并创建对应的 class 对象，将 class 文件加载到虚拟机的内存，这个过程称为类加载。这里我们需要了解一下类加载的过程，如下：\n![java类加载机制_2020-04-23-10-53-16.png](./images/java类加载机制_2020-04-23-10-53-16.png)\n\n1. 加载：类加载过程的一个阶段：通过一个类的全限定名查找此类字节文件，并利用字节码文件创建一个 Class 对象\n\n2. 验证：目的在于确保 Class 文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证、元数据验证、字节码验证、符号引用验证。\n\n3. 准备：为类变量(即 static 修饰的字段变量)分配内存并且设置该类变量的初始值(如 static int i ＝ 5;这里只讲 i 初始化为 0，至于 5 的值将在初始化时赋值)，这里不包含使用 final 修饰的 static，因为 final 在编译的时候就会分配了，注意这里不会为视力变量分配初始化值，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。\n\n4. 解析：主要讲常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对便移量或者一个间接定位到目标的句柄。有类或者接口的解析，字段解析，类方法解析，接口方法解析(这里设计到字节码变量的引用，如需详细了解，可参考《深入 Java 虚拟机》)\n\n5. 初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的 static 变量将会在这个阶段赋值，成员变量也将被初始化)\n\n这便是类加载的 5 个过程，而类加载的任务是根据一个类的全限定名来读取此类的二进制字节流到 JVM 中，然后转换为一个与目标类对应的 java.lang.Class 对象实例，在虚拟机中提供了 3 种类加载器，启动类加载器(Bootstrap)、扩展类加载器(Extension)、系统类加载器(System 也称应用类加载器)\n\n通过一段示例代码，我们可以看出来 java 初始化的一些过程\n\n```java\n\npublic class Father {\n    {\n        func();\n    }\n    public void func(){\n        try {\n            String name = (String) Son.class.getField(\"name\").get(this);\n            System.out.println(\"name = \" + name);\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (NoSuchFieldException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n\n\npublic class Son extends Father{\n\n    public String name = \"son\";\n\n    public static void main(String[] args) {\n        Son son = new Son();\n        son.func();\n    }\n}\n```\n\n其执行结果如下\n\n> name = null\n> name = son\n\n我们通过分析`Son`的字节码中关于构造器的片段\n\n```java\n  public com.leaderli.algrohtms.Son();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method com/leaderli/algrohtms/Father.\"<init>\":()V\n         4: aload_0\n         5: ldc           #2                  // String son\n         7: putfield      #3                  // Field name:Ljava/lang/String;\n        10: return\n      LineNumberTable:\n        line 3: 0\n        line 5: 4\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      11     0  this   Lcom/leaderli/algrohtms/Son;\n\n```\n\n`Son`类我们没有显示的写构造器，但是 java 会给我生成一个默认的构造器。我们可以得出，`Son`的构造器一开始就会调用`Father`的构造器方法，而此时成员变量`name`还没有完成初始化过程，因此在`Father`类中`name`的值为零值，即`null`。在父类构造器完成后，则会开始对成员变量的值进行赋值。\n\n### 启动类加载器(Bootstrap)\n\n启动类加载器主要加载的是 JVM 自身需要的类，这个类加载使用 C++语言实现的，是虚拟机自身的一部分，它负责讲`<JAVA_HOME>/lib`路径下的核心类库或`-Xbootclasspath`参数指定的路径下的 jar 包加载到内存中，注意由于虚拟机是按照文件名识别加载 jar 包的，如 rt.jar,如果文件名不被虚拟机识别，即使把 jar 包丢到 lib 目录下也是没有作用的。(出于安全考虑,Bootstrap 启动类加载器只加载包名为 java,javax,sun 等开头的类)\n\n### 扩展类加载器(Extension)\n\n扩展类加载器是指 Sun 公司实现的`sun.misc.Launcher$ExtClassLoader`类，由 Java 语言实现的，是 Launcher 的静态内部类，它负责加载`<JAVA_HOME>/lib/ext`目录下或者由系统变量`-Djava.ext.dir`指定路径中的类库，开发者可以直接使用标准扩展类加载器。\n\n```java\n//ExtClassLoader类中获取路径的代码\nprivate static File[] getExtDirs() {\n     //加载<JAVA_HOME>/lib/ext目录中的类库\n     String s = System.getProperty(\"java.ext.dirs\");\n     File[] dirs;\n     if (s != null) {\n         StringTokenizer st =\n             new StringTokenizer(s, File.pathSeparator);\n         int count = st.countTokens();\n         dirs = new File[count];\n         for (int i = 0; i < count; i++) {\n             dirs[i] = new File(st.nextToken());\n         }\n     } else {\n         dirs = new File[0];\n     }\n     return dirs;\n}\n```\n\n###系统(System)类加载器\n\n也称应用程序加载器是指 Sun 公司实现的`sun.misc.Launcher$AppClassLoader`。它负责加载系统类路径`java -classpath`或`-D java.class.path`指定路径下的类库，也就是我们经常用到的 cclasspath 路径，开发者可以直接使用系统类加载器，一般情况下该该类加载是程序中默认的类加载器，通过`ClassLoader#getSystemClassLoader()`方法可以获取到该类加载器。\n\n在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，需要注意的是，Java 虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象，而且加载某个类的 class 文件时，Java 虚拟机采用的是双亲委派模式即把请求交由父类处理，它是一种任务委派模式，下面我们进一步了解它。\n\n## 理解双亲委派模式\n\n### 双亲委派模式工作原理\n\n双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当由自己的父类加载器，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码，类加载器的关系如下：\n![java类加载机制_2020-04-23-10-52-52.png](./images/java类加载机制_2020-04-23-10-52-52.png)\n\n双亲委派模式是在 Java 1.2 后引入的，其工作原理是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。\n\n### 双亲委派模式优势\n\n采用双亲委派模式的优势是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系，可以避免类的重复加载，当父类已经加载了该类时，就没有必要子类加载器再加载一次。其次是考虑到安全因素，Java 核心 api 在定义类型时不会被随意替换，假设通过网络传递一个名为`java.lang.Integer`的类，通过双亲委派模式传递到启动类加载器，而启动类加载器载核心 Java API 发现这个名字的类，发现该类已被加载，就不会重新加载网络传递过来的`java.lang.Integer`，而直接返回已加载过的`Integer.class`，这样便可以防止核心 API 被随意篡改。\n\n下面我们从代码层面了解几个 Java 中定义的类加载器及其双亲委派模式的实现，他们的类图关系如下\n![java类加载机制_2020-04-23-10-54-17.png](./images/java类加载机制_2020-04-23-10-54-17.png)\n\n从图可以看出顶层的类加载器时 ClassLoader 类，它是一个抽象类，其后所有的类加载器都继承自 ClassLoader(不包括启动类加载器)，这里我们主要介绍 ClassLoader 中几个比较重要的方法。\n\n- `loadClass(String)`\n\n  该方法加载指定名称(包括包名)的二进制类型，该方法载 JDK 1.2 之后不再建议用户重写但用户可以直接调用该方法，`loadClass()`方法是`ClassLoader`类自己实现的，该方法中的逻辑就是双亲委派模式的实现，其源码如下，`loadClass(String name, boolean resolve)`是一个重载方法，resolve 参数代表是否生存 class 对象的同时解析相关操作。\n\n  ```java\n  protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException{\n    synchronized (getClassLoadingLock(name)){\n      //先从缓存查找该class对象，找到就不用重新加载\n      Class<?> c = findLoadedClass(name);\n      if(c == null){\n        long t0 = System.nanoTime();\n        try{\n          if(parent !=null){\n            //如果找不到，则委托给父类加载器加载\n            c = parent.loadClass(name,false);\n          }else{\n            //如果没有父类，则委托给启动加载器去加载\n            c = findBootstrapClassOrNull(name);\n          }catch(ClassNotFoundException e){\n            ...\n          }\n\n          if(c == null){\n            //如果没有找到，则通过自定义实现的findClass去查找并加载\n            c  = findClass(name);\n          }\n        }\n\n        if(resolve){//是否需要载加载时进行解析\n          resolveClass(c);\n        }\n        return c;\n      }\n    }\n  }\n  ```\n\n  正如 `loadClass`方法所展示的，当类加载请求到来时，先从缓存中查找该类对象，如果存在直接返回，如果不存在则交给该类加载器的父类加载器，若没有父类加载器则交给顶层启动类加载器去加载，若最后没有找到，则使用`findClass()`方法去加载。从`loadClass`实现也可以知道如果不想重新定义加载类的规则，也没有复杂的逻辑，只想在运行时加载自定指定的类，那么我们可以直接使用`this.getClass().getClassLoder.loadClass(\"className\")`,这样就可以调用`ClassLoader`的 loadClass 方法获取到 class 对象。\n\n- `findCLass(String)`\n\n  载 JDK1.2 之前，在自定义类加载时，总会去继承 ClassLoader 类并重写 loadClass 方法，从而实现自定义的类加载器，但是在 JDK1.2 之后已不再建议用户去覆盖`loadCLass()`方法，而是建议把自定义的类加载逻辑写在`findClass()`方法中，从前面的分析可知，`findClass()`方法是`loadClass()`方法中被调用的，当`loadClass()`方法中父类加载器加载失败后，则会调用自己的`findClass()`方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委派模式。需要注意的是`ClassLoader`类中并没有实现`findClass()`方法的具体逻辑，取而代之的是抛出`ClassNotFoundException`一场，同时应该知道的是｀`findClass`方法通常是和`defineClass`方法一起使用的，`ClassLoader`类中`findCLass`方法源码如下\n\n  ```java\n  //直接抛出异常\n  protected Class<?> findClass(String name) throws ClassNotFoundException {\n          throw new ClassNotFoundException(name);\n  }\n  ```\n\n- `defineClass(byte[] b, int off ,int len)`\n\n  `defineClass()`方法是用来将 byte 字节流解析成 JVM 能够识别的 Class 对象(`CLassLoader`中已实现该方法逻辑)，通过这个 方法不仅能够通过 class 文件实例化 class 对象，也可以通过其他方法实例化 class 对象，如果通过网络接受一个类的字节码，然后转换为 byte 字节流创建对应的 Class 对象，`defineClass()`方法通常与`findClass()`方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖`ClassLoader`的`findClass()`方法并编写加载规则，取得要加载类的字节码后转化为流，然后调用`defineClass()`方法生成类的 Class 对象，简单例子如下：\n\n  ```java\n  protected Class<?> findClass(String name) throws ClassNotFoundException {\n        // 获取类的字节数组\n        byte[] classData = getClassData(name);\n        if (classData == null) {\n            throw new ClassNotFoundException();\n        } else {\n            //使用defineClass生成class对象\n            return defineClass(name, classData, 0, classData.length);\n        }\n    }\n  ```\n\n  需要注意的是，如果直接调用`defineClass()`方法生成类的 Class 对象，这个类的 Class 对象并没有解析(也可以理解为链接阶段，毕竟解析是链接的最后一步)，其解析操作需要等待初始化阶段进行。\n\n- `resolveClass(Class<?> c)`\n\n  使用该方法可以使类的 Class 对象创建完成也同时被解析。前面我们说的链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。\n\n  上述 4 个方法是`ClassLoader`类中的比较重要的方法，也是我们可能会经常用到的方法。接着看`SercureClassLoader`扩展了`ClassLoader`，新增了几个与使用相关的代码源(对代码源的位置及证书的验证)和权限定义类验证(主要是指对 class 源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类`URLClassLoader`有所关联，前面说过，`ClassLoader`是一个抽象类，很多方法是空的没有实现，并新增了`URLClassPath`类协助取得 Class 字节码流等功能，在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接集成`URLClassLoader`类，这样就可以避免自己去编写`findClass()`方法及获取字节码流的方式，使自定义类加载器编写更加简洁，下面是`URLClassLoader`的类图\n  ![java类加载机制_2020-04-23-10-54-38.png](./images/java类加载机制_2020-04-23-10-54-38.png)\n","categories":["java"],"tags":["jvm"]},{"title":"java字节码","url":"/2020/04/23/java%E5%AD%97%E8%8A%82%E7%A0%81/","content":"\n## 基础概念\n\n`JVM`是一个基于栈的架构，每一个线程都有一个用来存储帧集`(frames)`的`JVM` 栈，每次方法被调用的时候(包含`main`方法)，在栈上会分配一个新的帧。这个帧包含局部变量数组，操作数栈，常量池指针,程序计数器，动态链接，返回地址。\n从概念来说，帧的情况如下图所示\n![java字节码_2020-04-25-12-51-54.png](./images/java字节码_2020-04-25-12-51-54.png)\n![java字节码_2020-04-23-10-46-50.png](./images/java字节码_2020-04-23-10-46-50.png)\n\n## 变量\n\n### 局部变量\n\n局部变量的数组也称为局部变量表，包括方法的参数，它也可以用来存储局部变量的值。首先存放的参数，从地址 0 开始编码。如果帧是一个构造器或者实例方法，`this`引用讲存储在地址 0 中，地址 1 存放第一个参数，地址 2 存放第二个参数，依次类推。如果帧是一个静态方法，第一个方法参数会存在地址 0 中，地址 1 存放第二个参数，依次类推。\n\n局部变量数组的大小是在编译期决定的，它取决于局部变量和正常方法参数的数量和大小。操作栈是一个用于`push` 和`pop` 值的后进先出的栈，它的大小也是在编译器决定的。一些操作码指令将值`push` 到操作栈，其它的操作码从栈上获取操作数，操作它们，并将值`push` 回去。操作栈常用来接收方法的返回值。\n\n局部变量可以是以下几种类型：\n\n> char\n> long\n> short\n> int\n> double\n> float\n> 引用\n> 返回地址\n\n除了`long`和`double`类型，每个变量都只占用局部变量区中的一个变量槽(`slot`)，而`long`和 `double`只所以会占用两个变量槽(`slot`)，因为`long`和`double`是 64 位的。\n\n当一个新的变量创建时，操作数栈(`Operand stack`)会存储这个新变量的值。然后这个变量会被存储到局部变量表中对应的位置上。如果这个变量不是基础类型的话，局部变量槽存的就是一个引用，这个引用指向堆中的一个对象。\n\n比如\n\n```java\nint i = 5;\n```\n\n编译后就变成了\n\n```java\n0: bipush      5 //用来将一个字节作为整型数字压入操作数栈中，在这里5就会被压入操作数栈上。\n2: istore_0 //这是istore_这组指令集（译注：严格来说，这个应该叫做操作码，opcode ,指令是指操作码加上对应的操作数，oprand。不过操作码一般作为指令的助记符，这里统称为指令）中的一条，这组指令是将一个整型数字存储到局部变量中。n代表的是局部变量区中的位置，并且只能是0,1,2,3。再多的话只能用另一条指令istore了，这条指令会接受一个操作数，对应的是局部变量区中的位置信息。\n```\n\n这条指令执行的时候，内存布局是这样的：\n![java字节码_2020-04-23-10-47-55.png](./images/java字节码_2020-04-23-10-47-55.png)\n\n每个方法都包含一个局部变量表，如果这段代码在一个方法里面的话，你会在方法的局部变量表中发现如下信息\n![java字节码_2020-04-23-10-48-09.png](./images/java字节码_2020-04-23-10-48-09.png)\n\n### 类字段\n\njava 类里面的字段作为类对象实例的一部分，存储在堆里(类变量存储在对应类对象里)。关于字段的信息会添加到类的`field_info` 数组里，像下面这样\n\n![java字节码_2020-04-23-10-48-26.png](./images/java字节码_2020-04-23-10-48-26.png)\n\n另外如果变量被初始化了，那么初始化的字节码会添加到构造方法里。\n下面这段代码编译之后：\n\n```java\npublic class SimpleClass {\n    public int simpleField = 100;\n}\n```\n\n如果你用 javap 进行反编译，这个被添加到了 field_info 数组里的字段就会多了一段描述：\n\n```java\npublic int simpleField;\n    Signature: I\n    flags: ACC_PUBLIC\n```\n\n初始化变量的字节码会被加到构造方法里，像下面这样：\n\n```java\npublic SimpleClass();\n  Signature: ()V\n  flags: ACC_PUBLIC\n  Code:\n    stack=2, locals=1, args_size=1\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: aload_0\n       5: bipush        100\n       7: putfield      #2                  // Field simpleField:I\n      10: return\n```\n\n上述代码执行的时候内存里面是这样的：\n![java字节码_2020-04-23-10-48-45.png](./images/java字节码_2020-04-23-10-48-45.png)\n\n这里的 putfield 指令的操作数引用的常量池里的第二个位置，JVM 会为每个类型维护一个常量池，运行时的数据结构有点类似一个符号表，尽管它包含的信息更多。java 的字节码操作需要对应的数据，但是这些数据太大了，存储在字节码里不合适，它们都被存储在常量池里，而字节码包含一个常量池的引用，当类文件生成的时候，其中一块就是常量池\n\n```java\nConstant pool:\n   #1 = Methodref          #4.#16         //  java/lang/Object.\"<init>\":()V\n   #2 = Fieldref           #3.#17         //  SimpleClass.simpleField:I\n   #3 = Class              #13            //  SimpleClass\n   #4 = Class              #19            //  java/lang/Object\n   #5 = Utf8               simpleField\n   #6 = Utf8               I\n   #7 = Utf8               <init>\n   #8 = Utf8               ()V\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               LocalVariableTable\n  #12 = Utf8               this\n  #13 = Utf8               SimpleClass\n  #14 = Utf8               SourceFile\n  #15 = Utf8               SimpleClass.java\n  #16 = NameAndType        #7:#8          //  \"<init>\":()V\n  #17 = NameAndType        #5:#6          //  simpleField:I\n  #18 = Utf8               LSimpleClass;\n  #19 = Utf8               java/lang/Object\n```\n\n### 常量字段（类常量）\n\n带有`final`标记的常量字段在`class`文件里会被标记成`ACC_FINAL`.\n\n```java\npublic class SimpleClass {\n    public int simpleField = 100;\n}\n```\n\n字段的描述信息会标记成`ACC_FINAL`:\n\n```java\npublic static final int simpleField = 100;\n    Signature: I\n    flags: ACC_PUBLIC, ACC_FINAL\n    ConstantValue: int 100\n```\n\n对应的初始化代码并不变：\n\n```java\n4: aload_0\n5: bipush        100\n7: putfield      #2                  // Field simpleField:I\n```\n\n### 静态变量\n\n带有`static`修饰符的静态变量则会被标记成`ACC_STATIC`：\n\n```java\npublic static int simpleField;\n    Signature: I\n    flags: ACC_PUBLIC, ACC_STATIC\n```\n\n不过在实例的构造方法中却再也找不到对应的初始化代码了。因为`static`变量会在类的构造方法中进行初始化，并且它用的是`putstatic`指令而不是`putfiled`。\n\n```java\nstatic {};\n  Signature: ()V\n  flags: ACC_STATIC\n  Code:\n    stack=1, locals=0, args_size=0\n       0: bipush         100\n       2: putstatic      #2                  // Field simpleField:I\n       5: return\n```\n\n### 动态链接\n\n每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有该引用是为了支持方法调用过程中的动态连接。\n\n动态分派在 Java 中被大量使用，使用频率及其高，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率，因此 JVM 在类的方法区中建立虚方法表（virtual method table）来提高性能。每个类中都有一个虚方法表，表中存放着各个方法的实际入口。如果某个方法在子类中没有被重写，那子类的虚方法表中该方法的地址入口和父类该方法的地址入口一样，即子类的方法入口指向父类的方法入口。如果子类重写父类的方法，那么子类的虚方法表中该方法的实际入口将会被替换为指向子类实现版本的入口地址。  \n那么虚方法表什么时候被创建？虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。\n\n### 程序计数器\n\n决定当前执行的指令\n\n### 示例\n\n#### 对于一个简单的类我们分析一下其字节码\n\n```java\npublic class Test {\n    private String employeeName;\n\n    public String employeeName(){\n        return this.employeeName;\n    }\n}\n```\n\n查看其字节码\n\n```java\nClassfile /Users/li/Downloads/Test.class\n  Last modified Mar 15, 2018; size 309 bytes\n  MD5 checksum 4553b41dee731dd099687198deb75de7\n  Compiled from \"Test.java\"\npublic class Test\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #4.#15         // java/lang/Object.\"<init>\":()V\n   #2 = Fieldref           #3.#16         // Test.name:Ljava/lang/String;\n   #3 = Class              #17            // Test\n   #4 = Class              #18            // java/lang/Object\n   #5 = Utf8               name\n   #6 = Utf8               Ljava/lang/String;\n   #7 = Utf8               <init>\n   #8 = Utf8               ()V\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               employeeName\n  #12 = Utf8               ()Ljava/lang/String;\n  #13 = Utf8               SourceFile\n  #14 = Utf8               Test.java\n  #15 = NameAndType        #7:#8          // \"<init>\":()V\n  #16 = NameAndType        #5:#6          // name:Ljava/lang/String;\n  #17 = Utf8               Test\n  #18 = Utf8               java/lang/Object\n{\n  java.lang.String name;\n    descriptor: Ljava/lang/String;\n    flags:\n\n  public Test();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 1: 0\n\n  public java.lang.String employeeName();\n    descriptor: ()Ljava/lang/String;\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: getfield      #2                  // Field name:Ljava/lang/String;\n         4: areturn\n      LineNumberTable:\n        line 4: 0\n}\nSourceFile: \"Test.java\"\n```\n\n这个方法(line 44)的字节码有三个操作码组成。\n\n1. 第一个操作码 aload_0，用于将局部变量表中索引为 0 的变量的值推送到操作栈上。前面提到过，局部变量表可以用来为方法传递参数的，构造器和实例方法的 this 引用总是存放在局部变量表的地址 0 处，this 引用必须入栈，因为方法需要访问实例的数据，名称和类。\n2. 第二个操作码 getfield，用于从对象中提取字段。当该操作码执行的时候，操作栈顶的值就会弹出(pop)，然后＃2 就用来在类运行时常量池中构建一个用于存放字段 name 引用地址的索引，当这个引用被提取时，它会被推送到操作栈上。\n3. 第三个操作码 areturn，返回一个来自方法的引用。比较特殊的是，areturn 的执行会导致操作栈顶的值，name 字段的 引用都会被弹出，然后推送到调用方法的操作栈。\n\nemployeeName 的方法相当简单，在考虑一个更复杂的例子之前，我们需要检查每一个操作码左边的值。在 employeeName 的方法的字节码中，这些值是 0，1，4。每个方法都有一个对应的字节码数组。这些值对应每个操作码和它们在参数数组的索引，一些操作码含有参数，这些参数会占据字节数组的空间。aload_0 没有参数，自然而然就占据一个字节，因此，下一个操作码 getfield，就在位置 1 上，然而 areturn 在位置 4 上，因为 getfield 操作码和他的参数占据了位置 1，2，3。位置 1 被操作码 getfield 使用，位置 2，3 被用于存放参数，这些参数用于构成在类运行时常量池中存放值的地方的一个索引。下面的图，展示了 employeeName 的方法的字节码数数组看起来的样子\n![java字节码_2020-04-23-10-50-00.png](./images/java字节码_2020-04-23-10-50-00.png)\n实际上，字节码数组包含代表指令的字节。使用一个 16 进制的编辑器查看 class 文件，可能看到字节码数组中有下面的值\n![java字节码_2020-04-23-10-50-44.png](./images/java字节码_2020-04-23-10-50-44.png)\n\n#### 通过字节码分析`synchronized`方法和`synchronized`代码块的区别\n\n```java\npublic synchronized int top1()\n{\n  return intArr[0];\n}\npublic int top2()\n{\n synchronized (this) {\n  return intArr[0];\n }\n}\n```\n\n```java\nMethod int top1()\n   0 aload_0           //将局部变量表中索引为0的对象引用this入栈。\n\n   1 getfield #6 <Field int intArr[]>\n                       //弹出对象引用this，将访问常量池的intArr对象引用入栈。\n\n   4 iconst_0          //将0入栈。\n   5 iaload            //弹出栈顶的两个值，将intArr中索引为0的值入栈。\n\n   6 ireturn           //弹出栈顶的值，将其压入调用方法的操作栈，并退出。\n\n\nMethod int top2()\n   0 aload_0           //将局部变量表中索引为0的对象引用this入栈。\n   1 astore_2          //弹出this引用，存放到局部变量表中索引为2的地方。\n   2 aload_2           //将this引用入栈。\n   3 monitorenter      //弹出this引用，获取对象的监视器。\n\n   4 aload_0           //开始进入同步块。将this引用压入局部变量表索引为0的地方。\n\n   5 getfield #6 <Field int intArr[]>\n                       //弹出this引用，压入访问常量池的intArr引用。\n\n   8 iconst_0          //压入0。\n   9 iaload            //弹出顶部的两个值，压入intArr索引为0的值。\n\n  10 istore_1          //弹出值，将它存放到局部变量表索引为1的地方。\n\n  11 jsr 19            //压入下一个操作码(14)的地址，并跳转到位置19。\n  14 iload_1           //压入局部变量表中索引为1的值。\n\n  15 ireturn           //弹出顶部的值，并将其压入到调用方法的操作栈中，退出。\n\n  16 aload_2           //同步块结束。将this引用压入到局部变量表索引为2的地方。\n\n  17 monitorexit       //弹出this引用，退出监视器。\n\n  18 athrow            //弹出this引用，抛出异常。\n\n  19 astore_3          //弹出返回地址(14)，并将其存放到局部变量表索引为3的地方。\n\n  20 aload_2           //将this引用压入到局部变量索引为2的地方。\n\n  21 monitorexit       //弹出this引用，并退出监视器。\n\n  22 ret 3             //从局部变量表索引为3的值(14)指示的地方返回。\nException table:       //如果在位置4(包括4)和位置16(排除16)中出现异常，则跳转到位置16.\nfrom to target type\n 4   16   16   any\n```\n\ntop2 比 top1 大，执行还慢，是因为 top2 采取的同步和异常处理方式。注意到 top1 采用 synchronized 方法修饰符，这不会产生额外的字节码。相反 top2 在方法体内使用 synchronized 同步代码块，会产生 monitorenter 和 monitorexit 操作码的字节码，还有额外的用于处理异常的字节码。如果执行到一个同步锁的块(一个监视器)内部时，抛出了一个异常，这个锁要保证在退出同步代码块前被释放。top1 的实现要比 top2 的效率高一些，这能获取一丁点的性能提升。\n\n当 synchronized 方法修饰符出现的时候，锁的获取和释放不是通过 monitorenter 和 monitorexit 操作码来实现的，而是在 JVM 调用一个方法时，它检查 ACC_SYNCHRONIZED 属性的标识。如果有这个标识，正在执行的线程将会先获取一个锁，调用方法然后在方法返回时释放锁。如果同步方法抛出异常，在异常离开方法前会自动释放锁。\n\n## 常用字节码指令集\n\n_Note that any referenced \"value\" refers to a 32-bit int as per the Java instruction set._\n\n|    Mnemonic     | Opcode _(in hex)_ | Opcode (in binary) |                                                                         Other bytes [count]: [operand labels]                                                                         |                                  Stack [before]→[after]                                   | Description                                                                                                                                                                                                                                                            |\n| :-------------: | :---------------: | :----------------: | :-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n|   _(no name)_   |       cb-fd       |                    |                                                                                                                                                                                       |                                                                                           | these values are currently unassigned for opcodes and are reserved for future use                                                                                                                                                                                      |\n|     aaload      |        32         |     0011 0010      |                                                                                                                                                                                       |                                  arrayref, index → value                                  | load onto the stack a reference from an array                                                                                                                                                                                                                          |\n|     aastore     |        53         |     0101 0011      |                                                                                                                                                                                       |                                 arrayref, index, value →                                  | store into a reference in an array                                                                                                                                                                                                                                     |\n|   aconst_null   |        01         |     0000 0001      |                                                                                                                                                                                       |                                          → null                                           | push a _null_ reference onto the stack                                                                                                                                                                                                                                 |\n|      aload      |        19         |     0001 1001      |                                                                                       1: index                                                                                        |                                        → objectref                                        | load a reference onto the stack from a local variable _#index_                                                                                                                                                                                                         |\n|     aload_0     |        2a         |     0010 1010      |                                                                                                                                                                                       |                                        → objectref                                        | load a reference onto the stack from local variable 0                                                                                                                                                                                                                  |\n|     aload_1     |        2b         |     0010 1011      |                                                                                                                                                                                       |                                        → objectref                                        | load a reference onto the stack from local variable 1                                                                                                                                                                                                                  |\n|     aload_2     |        2c         |     0010 1100      |                                                                                                                                                                                       |                                        → objectref                                        | load a reference onto the stack from local variable 2                                                                                                                                                                                                                  |\n|     aload_3     |        2d         |     0010 1101      |                                                                                                                                                                                       |                                        → objectref                                        | load a reference onto the stack from local variable 3                                                                                                                                                                                                                  |\n|    anewarray    |        bd         |     1011 1101      |                                                                               2: indexbyte1, indexbyte2                                                                               |                                     count → arrayref                                      | create a new array of references of length _count_ and component type identified by the class reference _index_ (indexbyte1 << 8 + indexbyte2) in the constant pool                                                                                                    |\n|     areturn     |        b0         |     1011 0000      |                                                                                                                                                                                       |                                    objectref → [empty]                                    | return a reference from a method                                                                                                                                                                                                                                       |\n|   arraylength   |        be         |     1011 1110      |                                                                                                                                                                                       |                                     arrayref → length                                     | get the length of an array                                                                                                                                                                                                                                             |\n|     astore      |        3a         |     0011 1010      |                                                                                       1: index                                                                                        |                                        objectref →                                        | store a reference into a local variable _#index_                                                                                                                                                                                                                       |\n|    astore_0     |        4b         |     0100 1011      |                                                                                                                                                                                       |                                        objectref →                                        | store a reference into local variable 0                                                                                                                                                                                                                                |\n|    astore_1     |        4c         |     0100 1100      |                                                                                                                                                                                       |                                        objectref →                                        | store a reference into local variable 1                                                                                                                                                                                                                                |\n|    astore_2     |        4d         |     0100 1101      |                                                                                                                                                                                       |                                        objectref →                                        | store a reference into local variable 2                                                                                                                                                                                                                                |\n|    astore_3     |        4e         |     0100 1110      |                                                                                                                                                                                       |                                        objectref →                                        | store a reference into local variable 3                                                                                                                                                                                                                                |\n|     athrow      |        bf         |     1011 1111      |                                                                                                                                                                                       |                              objectref → [empty], objectref                               | throws an error or exception (notice that the rest of the stack is cleared, leaving only a reference to the Throwable)                                                                                                                                                 |\n|     baload      |        33         |     0011 0011      |                                                                                                                                                                                       |                                  arrayref, index → value                                  | load a byte or Boolean value from an array                                                                                                                                                                                                                             |\n|     bastore     |        54         |     0101 0100      |                                                                                                                                                                                       |                                 arrayref, index, value →                                  | store a byte or Boolean value into an array                                                                                                                                                                                                                            |\n|     bipush      |        10         |     0001 0000      |                                                                                        1: byte                                                                                        |                                          → value                                          | push a _byte_ onto the stack as an integer _value_                                                                                                                                                                                                                     |\n|   breakpoint    |        ca         |     1100 1010      |                                                                                                                                                                                       |                                                                                           | reserved for breakpoints in Java debuggers; should not appear in any class file                                                                                                                                                                                        |\n|     caload      |        34         |     0011 0100      |                                                                                                                                                                                       |                                  arrayref, index → value                                  | load a char from an array                                                                                                                                                                                                                                              |\n|     castore     |        55         |     0101 0101      |                                                                                                                                                                                       |                                 arrayref, index, value →                                  | store a char into an array                                                                                                                                                                                                                                             |\n|    checkcast    |        c0         |     1100 0000      |                                                                               2: indexbyte1, indexbyte2                                                                               |                                   objectref → objectref                                   | checks whether an _objectref_ is of a certain type, the class reference of which is in the constant pool at _index_ (indexbyte1 << 8 + indexbyte2)                                                                                                                     |\n|       d2f       |        90         |     1001 0000      |                                                                                                                                                                                       |                                      value → result                                       | convert a double to a float                                                                                                                                                                                                                                            |\n|       d2i       |        8e         |     1000 1110      |                                                                                                                                                                                       |                                      value → result                                       | convert a double to an int                                                                                                                                                                                                                                             |\n|       d2l       |        8f         |     1000 1111      |                                                                                                                                                                                       |                                      value → result                                       | convert a double to a long                                                                                                                                                                                                                                             |\n|      dadd       |        63         |     0110 0011      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | add two doubles                                                                                                                                                                                                                                                        |\n|     daload      |        31         |     0011 0001      |                                                                                                                                                                                       |                                  arrayref, index → value                                  | load a double from an array                                                                                                                                                                                                                                            |\n|     dastore     |        52         |     0101 0010      |                                                                                                                                                                                       |                                 arrayref, index, value →                                  | store a double into an array                                                                                                                                                                                                                                           |\n|      dcmpg      |        98         |     1001 1000      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | compare two doubles                                                                                                                                                                                                                                                    |\n|      dcmpl      |        97         |     1001 0111      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | compare two doubles                                                                                                                                                                                                                                                    |\n|    dconst_0     |        0e         |     0000 1110      |                                                                                                                                                                                       |                                           → 0.0                                           | push the constant _0.0_ (a _double_) onto the stack                                                                                                                                                                                                                    |\n|    dconst_1     |        0f         |     0000 1111      |                                                                                                                                                                                       |                                           → 1.0                                           | push the constant _1.0_ (a _double_) onto the stack                                                                                                                                                                                                                    |\n|      ddiv       |        6f         |     0110 1111      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | divide two doubles                                                                                                                                                                                                                                                     |\n|      dload      |        18         |     0001 1000      |                                                                                       1: index                                                                                        |                                          → value                                          | load a double _value_ from a local variable _#index_                                                                                                                                                                                                                   |\n|     dload_0     |        26         |     0010 0110      |                                                                                                                                                                                       |                                          → value                                          | load a double from local variable 0                                                                                                                                                                                                                                    |\n|     dload_1     |        27         |     0010 0111      |                                                                                                                                                                                       |                                          → value                                          | load a double from local variable 1                                                                                                                                                                                                                                    |\n|     dload_2     |        28         |     0010 1000      |                                                                                                                                                                                       |                                          → value                                          | load a double from local variable 2                                                                                                                                                                                                                                    |\n|     dload_3     |        29         |     0010 1001      |                                                                                                                                                                                       |                                          → value                                          | load a double from local variable 3                                                                                                                                                                                                                                    |\n|      dmul       |        6b         |     0110 1011      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | multiply two doubles                                                                                                                                                                                                                                                   |\n|      dneg       |        77         |     0111 0111      |                                                                                                                                                                                       |                                      value → result                                       | negate a double                                                                                                                                                                                                                                                        |\n|      drem       |        73         |     0111 0011      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | get the remainder from a division between two doubles                                                                                                                                                                                                                  |\n|     dreturn     |        af         |     1010 1111      |                                                                                                                                                                                       |                                      value → [empty]                                      | return a double from a method                                                                                                                                                                                                                                          |\n|     dstore      |        39         |     0011 1001      |                                                                                       1: index                                                                                        |                                          value →                                          | store a double _value_ into a local variable _#index_                                                                                                                                                                                                                  |\n|    dstore_0     |        47         |     0100 0111      |                                                                                                                                                                                       |                                          value →                                          | store a double into local variable 0                                                                                                                                                                                                                                   |\n|    dstore_1     |        48         |     0100 1000      |                                                                                                                                                                                       |                                          value →                                          | store a double into local variable 1                                                                                                                                                                                                                                   |\n|    dstore_2     |        49         |     0100 1001      |                                                                                                                                                                                       |                                          value →                                          | store a double into local variable 2                                                                                                                                                                                                                                   |\n|    dstore_3     |        4a         |     0100 1010      |                                                                                                                                                                                       |                                          value →                                          | store a double into local variable 3                                                                                                                                                                                                                                   |\n|      dsub       |        67         |     0110 0111      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | subtract a double from another                                                                                                                                                                                                                                         |\n|       dup       |        59         |     0101 1001      |                                                                                                                                                                                       |                                   value → value, value                                    | duplicate the value on top of the stack                                                                                                                                                                                                                                |\n|      dup2       |        5c         |     0101 1100      |                                                                                                                                                                                       |                   {value2, value1} → {value2, value1}, {value2, value1}                   | duplicate top two stack words (two values, if value1 is not double nor long; a single value, if value1 is double or long)                                                                                                                                              |\n|     dup2_x1     |        5d         |     0101 1101      |                                                                                                                                                                                       |           value3, {value2, value1} → {value2, value1}, value3, {value2, value1}           | duplicate two words and insert beneath third word (see explanation above)                                                                                                                                                                                              |\n|     dup2_x2     |        5e         |     0101 1110      |                                                                                                                                                                                       | {value4, value3}, {value2, value1} → {value2, value1}, {value4, value3}, {value2, value1} | duplicate two words and insert beneath fourth word                                                                                                                                                                                                                     |\n|     dup_x1      |        5a         |     0101 1010      |                                                                                                                                                                                       |                          value2, value1 → value1, value2, value1                          | insert a copy of the top value into the stack two values from the top. value1 and value2 must not be of the type double or long.                                                                                                                                       |\n|     dup_x2      |        5b         |     0101 1011      |                                                                                                                                                                                       |                  value3, value2, value1 → value1, value3, value2, value1                  | insert a copy of the top value into the stack two (if value2 is double or long it takes up the entry of value3, too) or three values (if value2 is neither double nor long) from the top                                                                               |\n|       f2d       |        8d         |     1000 1101      |                                                                                                                                                                                       |                                      value → result                                       | convert a float to a double                                                                                                                                                                                                                                            |\n|       f2i       |        8b         |     1000 1011      |                                                                                                                                                                                       |                                      value → result                                       | convert a float to an int                                                                                                                                                                                                                                              |\n|       f2l       |        8c         |     1000 1100      |                                                                                                                                                                                       |                                      value → result                                       | convert a float to a long                                                                                                                                                                                                                                              |\n|      fadd       |        62         |     0110 0010      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | add two floats                                                                                                                                                                                                                                                         |\n|     faload      |        30         |     0011 0000      |                                                                                                                                                                                       |                                  arrayref, index → value                                  | load a float from an array                                                                                                                                                                                                                                             |\n|     fastore     |        51         |     0101 0001      |                                                                                                                                                                                       |                                 arrayref, index, value →                                  | store a float in an array                                                                                                                                                                                                                                              |\n|      fcmpg      |        96         |     1001 0110      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | compare two floats                                                                                                                                                                                                                                                     |\n|      fcmpl      |        95         |     1001 0101      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | compare two floats                                                                                                                                                                                                                                                     |\n|    fconst_0     |        0b         |     0000 1011      |                                                                                                                                                                                       |                                          → 0.0f                                           | push _0.0f_ on the stack                                                                                                                                                                                                                                               |\n|    fconst_1     |        0c         |     0000 1100      |                                                                                                                                                                                       |                                          → 1.0f                                           | push _1.0f_ on the stack                                                                                                                                                                                                                                               |\n|    fconst_2     |        0d         |     0000 1101      |                                                                                                                                                                                       |                                          → 2.0f                                           | push _2.0f_ on the stack                                                                                                                                                                                                                                               |\n|      fdiv       |        6e         |     0110 1110      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | divide two floats                                                                                                                                                                                                                                                      |\n|      fload      |        17         |     0001 0111      |                                                                                       1: index                                                                                        |                                          → value                                          | load a float _value_ from a local variable _#index_                                                                                                                                                                                                                    |\n|     fload_0     |        22         |     0010 0010      |                                                                                                                                                                                       |                                          → value                                          | load a float _value_ from local variable 0                                                                                                                                                                                                                             |\n|     fload_1     |        23         |     0010 0011      |                                                                                                                                                                                       |                                          → value                                          | load a float _value_ from local variable 1                                                                                                                                                                                                                             |\n|     fload_2     |        24         |     0010 0100      |                                                                                                                                                                                       |                                          → value                                          | load a float _value_ from local variable 2                                                                                                                                                                                                                             |\n|     fload_3     |        25         |     0010 0101      |                                                                                                                                                                                       |                                          → value                                          | load a float _value_ from local variable 3                                                                                                                                                                                                                             |\n|      fmul       |        6a         |     0110 1010      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | multiply two floats                                                                                                                                                                                                                                                    |\n|      fneg       |        76         |     0111 0110      |                                                                                                                                                                                       |                                      value → result                                       | negate a float                                                                                                                                                                                                                                                         |\n|      frem       |        72         |     0111 0010      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | get the remainder from a division between two floats                                                                                                                                                                                                                   |\n|     freturn     |        ae         |     1010 1110      |                                                                                                                                                                                       |                                      value → [empty]                                      | return a float                                                                                                                                                                                                                                                         |\n|     fstore      |        38         |     0011 1000      |                                                                                       1: index                                                                                        |                                          value →                                          | store a float _value_ into a local variable _#index_                                                                                                                                                                                                                   |\n|    fstore_0     |        43         |     0100 0011      |                                                                                                                                                                                       |                                          value →                                          | store a float _value_ into local variable 0                                                                                                                                                                                                                            |\n|    fstore_1     |        44         |     0100 0100      |                                                                                                                                                                                       |                                          value →                                          | store a float _value_ into local variable 1                                                                                                                                                                                                                            |\n|    fstore_2     |        45         |     0100 0101      |                                                                                                                                                                                       |                                          value →                                          | store a float _value_ into local variable 2                                                                                                                                                                                                                            |\n|    fstore_3     |        46         |     0100 0110      |                                                                                                                                                                                       |                                          value →                                          | store a float _value_ into local variable 3                                                                                                                                                                                                                            |\n|      fsub       |        66         |     0110 0110      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | subtract two floats                                                                                                                                                                                                                                                    |\n|    getfield     |        b4         |     1011 0100      |                                                                               2: indexbyte1, indexbyte2                                                                               |                                     objectref → value                                     | get a field _value_ of an object _objectref_, where the field is identified by field reference in the constant pool _index_ (indexbyte1 << 8 + indexbyte2)                                                                                                             |\n|    getstatic    |        b2         |     1011 0010      |                                                                               2: indexbyte1, indexbyte2                                                                               |                                          → value                                          | get a static field _value_ of a class, where the field is identified by field reference in the constant pool _index_ (indexbyte1 << 8 + indexbyte2)                                                                                                                    |\n|      goto       |        a7         |     1010 0111      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                        [no change]                                        | goes to another instruction at _branchoffset_ (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                                                            |\n|     goto_w      |        c8         |     1100 1000      |                                                                 4: branchbyte1, branchbyte2, branchbyte3, branchbyte4                                                                 |                                        [no change]                                        | goes to another instruction at _branchoffset_ (signed int constructed from unsigned bytes branchbyte1 << 24 + branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4)                                                                                                      |\n|       i2b       |        91         |     1001 0001      |                                                                                                                                                                                       |                                      value → result                                       | convert an int into a byte                                                                                                                                                                                                                                             |\n|       i2c       |        92         |     1001 0010      |                                                                                                                                                                                       |                                      value → result                                       | convert an int into a character                                                                                                                                                                                                                                        |\n|       i2d       |        87         |     1000 0111      |                                                                                                                                                                                       |                                      value → result                                       | convert an int into a double                                                                                                                                                                                                                                           |\n|       i2f       |        86         |     1000 0110      |                                                                                                                                                                                       |                                      value → result                                       | convert an int into a float                                                                                                                                                                                                                                            |\n|       i2l       |        85         |     1000 0101      |                                                                                                                                                                                       |                                      value → result                                       | convert an int into a long                                                                                                                                                                                                                                             |\n|       i2s       |        93         |     1001 0011      |                                                                                                                                                                                       |                                      value → result                                       | convert an int into a short                                                                                                                                                                                                                                            |\n|      iadd       |        60         |     0110 0000      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | add two ints                                                                                                                                                                                                                                                           |\n|     iaload      |        2e         |     0010 1110      |                                                                                                                                                                                       |                                  arrayref, index → value                                  | load an int from an array                                                                                                                                                                                                                                              |\n|      iand       |        7e         |     0111 1110      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | perform a bitwise AND on two integers                                                                                                                                                                                                                                  |\n|     iastore     |        4f         |     0100 1111      |                                                                                                                                                                                       |                                 arrayref, index, value →                                  | store an int into an array                                                                                                                                                                                                                                             |\n|    iconst_0     |        03         |     0000 0011      |                                                                                                                                                                                       |                                            → 0                                            | load the int value 0 onto the stack                                                                                                                                                                                                                                    |\n|    iconst_1     |        04         |     0000 0100      |                                                                                                                                                                                       |                                            → 1                                            | load the int value 1 onto the stack                                                                                                                                                                                                                                    |\n|    iconst_2     |        05         |     0000 0101      |                                                                                                                                                                                       |                                            → 2                                            | load the int value 2 onto the stack                                                                                                                                                                                                                                    |\n|    iconst_3     |        06         |     0000 0110      |                                                                                                                                                                                       |                                            → 3                                            | load the int value 3 onto the stack                                                                                                                                                                                                                                    |\n|    iconst_4     |        07         |     0000 0111      |                                                                                                                                                                                       |                                            → 4                                            | load the int value 4 onto the stack                                                                                                                                                                                                                                    |\n|    iconst_5     |        08         |     0000 1000      |                                                                                                                                                                                       |                                            → 5                                            | load the int value 5 onto the stack                                                                                                                                                                                                                                    |\n|    iconst_m1    |        02         |     0000 0010      |                                                                                                                                                                                       |                                           → -1                                            | load the int value −1 onto the stack                                                                                                                                                                                                                                   |\n|      idiv       |        6c         |     0110 1100      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | divide two integers                                                                                                                                                                                                                                                    |\n|    if_acmpeq    |        a5         |     1010 0101      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                     value1, value2 →                                      | if references are equal, branch to instruction at _branchoffset_ (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                                         |\n|    if_acmpne    |        a6         |     1010 0110      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                     value1, value2 →                                      | if references are not equal, branch to instruction at _branchoffset_(signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                                      |\n|    if_icmpeq    |        9f         |     1001 1111      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                     value1, value2 →                                      | if ints are equal, branch to instruction at _branchoffset_ (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                                               |\n|    if_icmpge    |        a2         |     1010 0010      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                     value1, value2 →                                      | if _value1_ is greater than or equal to _value2_, branch to instruction at _branchoffset_ (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                |\n|    if_icmpgt    |        a3         |     1010 0011      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                     value1, value2 →                                      | if _value1_ is greater than _value2_, branch to instruction at _branchoffset_(signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                             |\n|    if_icmple    |        a4         |     1010 0100      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                     value1, value2 →                                      | if _value1_ is less than or equal to _value2_, branch to instruction at _branchoffset_ (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                   |\n|    if_icmplt    |        a1         |     1010 0001      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                     value1, value2 →                                      | if _value1_ is less than _value2_, branch to instruction at _branchoffset_(signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                                |\n|    if_icmpne    |        a0         |     1010 0000      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                     value1, value2 →                                      | if ints are not equal, branch to instruction at _branchoffset_ (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                                           |\n|      ifeq       |        99         |     1001 1001      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                          value →                                          | if _value_ is 0, branch to instruction at _branchoffset_ (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                                                 |\n|      ifge       |        9c         |     1001 1100      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                          value →                                          | if _value_ is greater than or equal to 0, branch to instruction at _branchoffset_ (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                        |\n|      ifgt       |        9d         |     1001 1101      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                          value →                                          | if _value_ is greater than 0, branch to instruction at _branchoffset_ (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                                    |\n|      ifle       |        9e         |     1001 1110      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                          value →                                          | if _value_ is less than or equal to 0, branch to instruction at _branchoffset_(signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                            |\n|      iflt       |        9b         |     1001 1011      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                          value →                                          | if _value_ is less than 0, branch to instruction at _branchoffset_ (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                                       |\n|      ifne       |        9a         |     1001 1010      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                          value →                                          | if _value_ is not 0, branch to instruction at _branchoffset_ (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                                             |\n|    ifnonnull    |        c7         |     1100 0111      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                          value →                                          | if _value_ is not null, branch to instruction at _branchoffset_ (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                                          |\n|     ifnull      |        c6         |     1100 0110      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                          value →                                          | if _value_ is null, branch to instruction at _branchoffset_ (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)                                                                                                                              |\n|      iinc       |        84         |     1000 0100      |                                                                                    2: index, const                                                                                    |                                        [No change]                                        | increment local variable _#index_ by signed byte _const_                                                                                                                                                                                                               |\n|      iload      |        15         |     0001 0101      |                                                                                       1: index                                                                                        |                                          → value                                          | load an int _value_ from a local variable _#index_                                                                                                                                                                                                                     |\n|     iload_0     |        1a         |     0001 1010      |                                                                                                                                                                                       |                                          → value                                          | load an int _value_ from local variable 0                                                                                                                                                                                                                              |\n|     iload_1     |        1b         |     0001 1011      |                                                                                                                                                                                       |                                          → value                                          | load an int _value_ from local variable 1                                                                                                                                                                                                                              |\n|     iload_2     |        1c         |     0001 1100      |                                                                                                                                                                                       |                                          → value                                          | load an int _value_ from local variable 2                                                                                                                                                                                                                              |\n|     iload_3     |        1d         |     0001 1101      |                                                                                                                                                                                       |                                          → value                                          | load an int _value_ from local variable 3                                                                                                                                                                                                                              |\n|     impdep1     |        fe         |     1111 1110      |                                                                                                                                                                                       |                                                                                           | reserved for implementation-dependent operations within debuggers; should not appear in any class file                                                                                                                                                                 |\n|     impdep2     |        ff         |     1111 1111      |                                                                                                                                                                                       |                                                                                           | reserved for implementation-dependent operations within debuggers; should not appear in any class file                                                                                                                                                                 |\n|      imul       |        68         |     0110 1000      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | multiply two integers                                                                                                                                                                                                                                                  |\n|      ineg       |        74         |     0111 0100      |                                                                                                                                                                                       |                                      value → result                                       | negate int                                                                                                                                                                                                                                                             |\n|   instanceof    |        c1         |     1100 0001      |                                                                               2: indexbyte1, indexbyte2                                                                               |                                    objectref → result                                     | determines if an object _objectref_ is of a given type, identified by class reference _index_ in constant pool (indexbyte1 << 8 + indexbyte2)                                                                                                                          |\n|  invokedynamic  |        ba         |     1011 1010      |                                                                            4: indexbyte1, indexbyte2, 0, 0                                                                            |                                [arg1, [arg2 ...]] → result                                | invokes a dynamic method and puts the result on the stack (might be void); the method is identified by method reference _index_ in constant pool (indexbyte1 << 8 + indexbyte2)                                                                                        |\n| invokeinterface |        b9         |     1011 1001      |                                                                          4: indexbyte1, indexbyte2, count, 0                                                                          |                           objectref, [arg1, arg2, ...] → result                           | invokes an interface method on object _objectref_ and puts the result on the stack (might be void); the interface method is identified by method reference _index_ in constant pool (indexbyte1 << 8 + indexbyte2)                                                     |\n|  invokespecial  |        b7         |     1011 0111      |                                                                               2: indexbyte1, indexbyte2                                                                               |                           objectref, [arg1, arg2, ...] → result                           | invoke instance method on object _objectref_ and puts the result on the stack (might be void); the method is identified by method reference _index_ in constant pool (indexbyte1 << 8 + indexbyte2)                                                                    |\n|  invokestatic   |        b8         |     1011 1000      |                                                                               2: indexbyte1, indexbyte2                                                                               |                                [arg1, arg2, ...] → result                                 | invoke a static method and puts the result on the stack (might be void); the method is identified by method reference _index_ in constant pool (indexbyte1 << 8 + indexbyte2)                                                                                          |\n|  invokevirtual  |        b6         |     1011 0110      |                                                                               2: indexbyte1, indexbyte2                                                                               |                           objectref, [arg1, arg2, ...] → result                           | invoke virtual method on object _objectref_ and puts the result on the stack (might be void); the method is identified by method reference _index_ in constant pool (indexbyte1 << 8 + indexbyte2)                                                                     |\n|       ior       |        80         |     1000 0000      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | bitwise int OR                                                                                                                                                                                                                                                         |\n|      irem       |        70         |     0111 0000      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | logical int remainder                                                                                                                                                                                                                                                  |\n|     ireturn     |        ac         |     1010 1100      |                                                                                                                                                                                       |                                      value → [empty]                                      | return an integer from a method                                                                                                                                                                                                                                        |\n|      ishl       |        78         |     0111 1000      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | int shift left                                                                                                                                                                                                                                                         |\n|      ishr       |        7a         |     0111 1010      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | int arithmetic shift right                                                                                                                                                                                                                                             |\n|     istore      |        36         |     0011 0110      |                                                                                       1: index                                                                                        |                                          value →                                          | store int _value_ into variable _#index_                                                                                                                                                                                                                               |\n|    istore_0     |        3b         |     0011 1011      |                                                                                                                                                                                       |                                          value →                                          | store int _value_ into variable 0                                                                                                                                                                                                                                      |\n|    istore_1     |        3c         |     0011 1100      |                                                                                                                                                                                       |                                          value →                                          | store int _value_ into variable 1                                                                                                                                                                                                                                      |\n|    istore_2     |        3d         |     0011 1101      |                                                                                                                                                                                       |                                          value →                                          | store int _value_ into variable 2                                                                                                                                                                                                                                      |\n|    istore_3     |        3e         |     0011 1110      |                                                                                                                                                                                       |                                          value →                                          | store int _value_ into variable 3                                                                                                                                                                                                                                      |\n|      isub       |        64         |     0110 0100      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | int subtract                                                                                                                                                                                                                                                           |\n|      iushr      |        7c         |     0111 1100      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | int logical shift right                                                                                                                                                                                                                                                |\n|      ixor       |        82         |     1000 0010      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | int xor                                                                                                                                                                                                                                                                |\n|       jsr       |        a8         |     1010 1000      |                                                                              2: branchbyte1, branchbyte2                                                                              |                                         → address                                         | jump to subroutine at _branchoffset_ (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2) and place the return address on the stack                                                                                                           |\n|      jsr_w      |        c9         |     1100 1001      |                                                                 4: branchbyte1, branchbyte2, branchbyte3, branchbyte4                                                                 |                                         → address                                         | jump to subroutine at _branchoffset_ (signed int constructed from unsigned bytes branchbyte1 << 24 + branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4) and place the return address on the stack                                                                     |\n|       l2d       |        8a         |     1000 1010      |                                                                                                                                                                                       |                                      value → result                                       | convert a long to a double                                                                                                                                                                                                                                             |\n|       l2f       |        89         |     1000 1001      |                                                                                                                                                                                       |                                      value → result                                       | convert a long to a float                                                                                                                                                                                                                                              |\n|       l2i       |        88         |     1000 1000      |                                                                                                                                                                                       |                                      value → result                                       | convert a long to a int                                                                                                                                                                                                                                                |\n|      ladd       |        61         |     0110 0001      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | add two longs                                                                                                                                                                                                                                                          |\n|     laload      |        2f         |     0010 1111      |                                                                                                                                                                                       |                                  arrayref, index → value                                  | load a long from an array                                                                                                                                                                                                                                              |\n|      land       |        7f         |     0111 1111      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | [bitwise](https://en.wikipedia.org/wiki/Bitwise_operation) AND of two longs                                                                                                                                                                                            |\n|     lastore     |        50         |     0101 0000      |                                                                                                                                                                                       |                                 arrayref, index, value →                                  | store a long to an array                                                                                                                                                                                                                                               |\n|      lcmp       |        94         |     1001 0100      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | push 0 if the two longs are the same, 1 if value1 is greater than value2, -1 otherwise                                                                                                                                                                                 |\n|    lconst_0     |        09         |     0000 1001      |                                                                                                                                                                                       |                                           → 0L                                            | push _0L_ (the number [zero](https://en.wikipedia.org/wiki/Zero) with type _long_) onto the stack                                                                                                                                                                      |\n|    lconst_1     |        0a         |     0000 1010      |                                                                                                                                                                                       |                                           → 1L                                            | push _1L_ (the number [one](https://en.wikipedia.org/wiki/One) with type _long_) onto the stack                                                                                                                                                                        |\n|       ldc       |        12         |     0001 0010      |                                                                                       1: index                                                                                        |                                          → value                                          | push a constant _#index_ from a constant pool (String, int, float, Class, java.lang.invoke.MethodType, or java.lang.invoke.MethodHandle) onto the stack                                                                                                                |\n|     ldc2_w      |        14         |     0001 0100      |                                                                               2: indexbyte1, indexbyte2                                                                               |                                          → value                                          | push a constant _#index_ from a constant pool (double or long) onto the stack (wide _index_ is constructed as indexbyte1 << 8 + indexbyte2)                                                                                                                            |\n|      ldc_w      |        13         |     0001 0011      |                                                                               2: indexbyte1, indexbyte2                                                                               |                                          → value                                          | push a constant _#index_ from a constant pool (String, int, float, Class, java.lang.invoke.MethodType, or java.lang.invoke.MethodHandle) onto the stack (wide _index_ is constructed as indexbyte1 << 8 + indexbyte2)                                                  |\n|      ldiv       |        6d         |     0110 1101      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | divide two longs                                                                                                                                                                                                                                                       |\n|      lload      |        16         |     0001 0110      |                                                                                       1: index                                                                                        |                                          → value                                          | load a long value from a local variable _#index_                                                                                                                                                                                                                       |\n|     lload_0     |        1e         |     0001 1110      |                                                                                                                                                                                       |                                          → value                                          | load a long value from a local variable 0                                                                                                                                                                                                                              |\n|     lload_1     |        1f         |     0001 1111      |                                                                                                                                                                                       |                                          → value                                          | load a long value from a local variable 1                                                                                                                                                                                                                              |\n|     lload_2     |        20         |     0010 0000      |                                                                                                                                                                                       |                                          → value                                          | load a long value from a local variable 2                                                                                                                                                                                                                              |\n|     lload_3     |        21         |     0010 0001      |                                                                                                                                                                                       |                                          → value                                          | load a long value from a local variable 3                                                                                                                                                                                                                              |\n|      lmul       |        69         |     0110 1001      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | multiply two longs                                                                                                                                                                                                                                                     |\n|      lneg       |        75         |     0111 0101      |                                                                                                                                                                                       |                                      value → result                                       | negate a long                                                                                                                                                                                                                                                          |\n|  lookupswitch   |        ab         |     1010 1011      |                      8+: <0–3 bytes padding>, defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, npairs1, npairs2, npairs3, npairs4, match-offset pairs...                       |                                           key →                                           | a target address is looked up from a table using a key and execution continues from the instruction at that address                                                                                                                                                    |\n|       lor       |        81         |     1000 0001      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | bitwise OR of two longs                                                                                                                                                                                                                                                |\n|      lrem       |        71         |     0111 0001      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | remainder of division of two longs                                                                                                                                                                                                                                     |\n|     lreturn     |        ad         |     1010 1101      |                                                                                                                                                                                       |                                      value → [empty]                                      | return a long value                                                                                                                                                                                                                                                    |\n|      lshl       |        79         |     0111 1001      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | bitwise shift left of a long _value1_ by int _value2_ positions                                                                                                                                                                                                        |\n|      lshr       |        7b         |     0111 1011      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | bitwise shift right of a long _value1_ by int _value2_ positions                                                                                                                                                                                                       |\n|     lstore      |        37         |     0011 0111      |                                                                                       1: index                                                                                        |                                          value →                                          | store a long _value_ in a local variable _#index_                                                                                                                                                                                                                      |\n|    lstore_0     |        3f         |     0011 1111      |                                                                                                                                                                                       |                                          value →                                          | store a long _value_ in a local variable 0                                                                                                                                                                                                                             |\n|    lstore_1     |        40         |     0100 0000      |                                                                                                                                                                                       |                                          value →                                          | store a long _value_ in a local variable 1                                                                                                                                                                                                                             |\n|    lstore_2     |        41         |     0100 0001      |                                                                                                                                                                                       |                                          value →                                          | store a long _value_ in a local variable 2                                                                                                                                                                                                                             |\n|    lstore_3     |        42         |     0100 0010      |                                                                                                                                                                                       |                                          value →                                          | store a long _value_ in a local variable 3                                                                                                                                                                                                                             |\n|      lsub       |        65         |     0110 0101      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | subtract two longs                                                                                                                                                                                                                                                     |\n|      lushr      |        7d         |     0111 1101      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | bitwise shift right of a long _value1_ by int _value2_ positions, unsigned                                                                                                                                                                                             |\n|      lxor       |        83         |     1000 0011      |                                                                                                                                                                                       |                                  value1, value2 → result                                  | bitwise XOR of two longs                                                                                                                                                                                                                                               |\n|  monitorenter   |        c2         |     1100 0010      |                                                                                                                                                                                       |                                        objectref →                                        | enter monitor for object (\"grab the lock\" – start of synchronized() section)                                                                                                                                                                                           |\n|   monitorexit   |        c3         |     1100 0011      |                                                                                                                                                                                       |                                        objectref →                                        | exit monitor for object (\"release the lock\" – end of synchronized() section)                                                                                                                                                                                           |\n| multianewarray  |        c5         |     1100 0101      |                                                                         3: indexbyte1, indexbyte2, dimensions                                                                         |                              count1, [count2,...] → arrayref                              | create a new array of _dimensions_ dimensions of type identified by class reference in constant pool _index_ (indexbyte1 << 8 + indexbyte2); the sizes of each dimension is identified by _count1_, [*count2*, etc.]                                                   |\n|       new       |        bb         |     1011 1011      |                                                                               2: indexbyte1, indexbyte2                                                                               |                                        → objectref                                        | create new object of type identified by class reference in constant pool _index_ (indexbyte1 << 8 + indexbyte2)                                                                                                                                                        |\n|    newarray     |        bc         |     1011 1100      |                                                                                       1: atype                                                                                        |                                     count → arrayref                                      | create new array with _count_ elements of primitive type identified by _atype_                                                                                                                                                                                         |\n|       nop       |        00         |     0000 0000      |                                                                                                                                                                                       |                                        [No change]                                        | perform no operation                                                                                                                                                                                                                                                   |\n|       pop       |        57         |     0101 0111      |                                                                                                                                                                                       |                                          value →                                          | discard the top value on the stack                                                                                                                                                                                                                                     |\n|      pop2       |        58         |     0101 1000      |                                                                                                                                                                                       |                                    {value2, value1} →                                     | discard the top two values on the stack (or one value, if it is a double or long)                                                                                                                                                                                      |\n|    putfield     |        b5         |     1011 0101      |                                                                               2: indexbyte1, indexbyte2                                                                               |                                    objectref, value →                                     | set field to _value_ in an object _objectref_, where the field is identified by a field reference _index_ in constant pool (indexbyte1 << 8 + indexbyte2)                                                                                                              |\n|    putstatic    |        b3         |     1011 0011      |                                                                               2: indexbyte1, indexbyte2                                                                               |                                          value →                                          | set static field to _value_ in a class, where the field is identified by a field reference _index_ in constant pool (indexbyte1 << 8 + indexbyte2)                                                                                                                     |\n|       ret       |        a9         |     1010 1001      |                                                                                       1: index                                                                                        |                                        [No change]                                        | continue execution from address taken from a local variable _#index_(the asymmetry with jsr is intentional)                                                                                                                                                            |\n|     return      |        b1         |     1011 0001      |                                                                                                                                                                                       |                                         → [empty]                                         | return void from method                                                                                                                                                                                                                                                |\n|     saload      |        35         |     0011 0101      |                                                                                                                                                                                       |                                  arrayref, index → value                                  | load short from array                                                                                                                                                                                                                                                  |\n|     sastore     |        56         |     0101 0110      |                                                                                                                                                                                       |                                 arrayref, index, value →                                  | store short to array                                                                                                                                                                                                                                                   |\n|     sipush      |        11         |     0001 0001      |                                                                                    2: byte1, byte2                                                                                    |                                          → value                                          | push a short onto the stack as an integer _value_                                                                                                                                                                                                                      |\n|      swap       |        5f         |     0101 1111      |                                                                                                                                                                                       |                              value2, value1 → value1, value2                              | swaps two top words on the stack (note that value1 and value2 must not be double or long)                                                                                                                                                                              |\n|   tableswitch   |        aa         |     1010 1010      | 16+: [0–3 bytes padding], defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, lowbyte1, lowbyte2, lowbyte3, lowbyte4, highbyte1, highbyte2, highbyte3, highbyte4, jump offsets... |                                          index →                                          | continue execution from an address in the table at offset _index_                                                                                                                                                                                                      |\n|      wide       |        c4         |     1100 0100      |                                              3/5: opcode, indexbyte1, indexbyte2 or iinc, indexbyte1, indexbyte2, countbyte1, countbyte2                                              |                         [same as for corresponding instructions]                          | execute _opcode_, where _opcode_ is either iload, fload, aload, lload, dload, istore, fstore, astore, lstore, dstore, or ret, but assume the *index*is 16 bit; or execute iinc, where the _index_ is 16 bits and the constant to increment by is a signed 16 bit short |\n","categories":["java"],"tags":["jvm","字节码"]},{"title":"大学计算机笔记","url":"/2020/04/18/%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AC%94%E8%AE%B0/","content":"\n## 运算减法(补码反码)\n\n对于十二刻时的时钟来说，它的一个周期为 12 个小时，我们称之为模。`9-3`即从 9 点向后拨 3 个小时，那么就是 6 点，同时我们也可以向前拨 9 个小时，那么也是 6 点。也就是说减法可以通过与模来变换成加法。对于时钟来说模`R = 12`,`-3`与模相差`9`。那么`-3`等同于`+9`。这个可以通过如下公式来证明\n\n$$\n   a-b=a-b+R=a+(R-b)\n$$\n\n对于一个`n`位的二进制来说，它的模 R = $2^n$，它的减法可以用以下公式来换算\n\n$$\n   a-b=a-b+2^n=a+(2^n-b)=a+(2^n-1+1-b)=a+((2^n-1)-b)+1\n$$\n\n$2^n-1$用二进制表达就是 n 位 1,$(2^n-1) - b$其实就是计算`-b`的补码所以上述表示式最终可以表现为$a+\\overline{b}+1$，这个就是俗称的反码\n\n## 与非门实现真值表达式\n\n![大学计算机笔记_2020-04-18-17-50-17.png](./images/大学计算机笔记_2020-04-18-17-50-17.png)\n![大学计算机笔记_2020-04-18-17-51-41.png](./images/大学计算机笔记_2020-04-18-17-51-41.png)\n\n## 中文`ASCII`码\n\n`html`中以`&#x`开头的特殊字符\n","categories":["计算机基础"],"tags":["计算机基础"]},{"title":"spring配置类加载yaml配置项的模拟实现","url":"/2020/03/16/spring%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%8A%A0%E8%BD%BDyaml%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/","content":"\n核心思路就是自定义一个注解用以`Spring`启动过程中，将其手动注入到`Spring`容器中，并干预该类的实例化过程\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface YamlBean {\n    String value();\n}\n\n```\n\n```java\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;\nimport org.springframework.context.annotation.ImportBeanDefinitionRegistrar;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.core.type.filter.AnnotationTypeFilter;\n\nimport java.util.Objects;\n\npublic class YamlBeanRegistrar implements ImportBeanDefinitionRegistrar {\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n        createComponentScanner().findCandidateComponents(\"com.leaderli.yaml\").forEach(beanDefinition -> {\n            System.out.println(\"beanDefinition = \" + beanDefinition);\n            beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(Objects.requireNonNull(beanDefinition.getBeanClassName()));\n            beanDefinition.setBeanClassName(ProxyFactoryBean.class.getName()); //指定该类的生成工厂类\n            registry.registerBeanDefinition(Objects.requireNonNull(beanDefinition.getBeanClassName()), beanDefinition);\n        });\n\n    }\n\n    private ClassPathScanningCandidateComponentProvider createComponentScanner() {\n        // 扫描YamlBean注解的类\n        ClassPathScanningCandidateComponentProvider provider\n                = new ClassPathScanningCandidateComponentProvider(false);\n        provider.addIncludeFilter(new AnnotationTypeFilter(YamlBean.class));\n        return provider;\n    }\n}\n```\n\n```java\n\nimport org.springframework.beans.factory.FactoryBean;\nimport org.yaml.snakeyaml.Yaml;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Map;\n\npublic class ProxyFactoryBean<T> implements FactoryBean<T> {\n    private Class<T> interfaceClass;\n\n    public ProxyFactoryBean(Class<T> interfaceClass) {\n        this.interfaceClass = interfaceClass;\n    }\n\n    public T getObject() throws IOException {\n        YamlBean annotation = interfaceClass.getAnnotation(YamlBean.class);\n\n        InputStream inputStream = ClassLoader.getSystemResourceAsStream(\"bean.yml\");\n        Yaml yaml = new Yaml();\n        Map<String,Object> load = yaml.load(inputStream);\n\n        String prefix = annotation.value();\n        System.out.println(\"prefix = \" + prefix);\n\n        for (String key : prefix.split(\"\\\\.\")) {\n            load= (Map<String, Object>) load.get(key);\n            System.out.println(\"load = \" + load);\n\n        }\n        yaml = new Yaml();\n        String dump = yaml.dump(load);\n        System.out.println(\"dump = \" + dump);\n\n        T bean = yaml.loadAs(dump, interfaceClass);\n        System.out.println(\"bean = \" + bean);\n        return bean;\n\n\n    }\n\n    public Class<?> getObjectType() {\n        return interfaceClass;\n    }\n\n    public boolean isSingleton() {\n        return false;\n    }\n}\n\n\n```\n\n在`Spring`的配置类将扫描器导入\n\n```java\n@Configuration\n@Import(YamlBeanRegistrar.class)\npublic class SpringConfig {\n}\n\n```\n","categories":["spring"],"tags":["spring","yaml"]},{"title":"gitlab","url":"/2020/01/14/gitlab/","content":"\n初始密码\nqwer1234\n","categories":["tips"],"tags":["git","gitlab"]},{"title":"springboot自定义加载配置文件","url":"/2019/12/27/springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","content":"\n## 实现\n\n`springboot`提供了注解`@PropertySource`来实现加载配置文件。\n一个普通的注解配置,也可注解在其他`@Configuration`类上\n\n```java\n@SpringBootApplication\n@PropertySource(factory = YamlPropertySourceFactory.class, value = \"classpath:application.yml\")\npublic class Application {\n}\n```\n\n`PropertySource`和`PropertySourceFactory`的源码\n\n```java\n\npackage org.springframework.context.annotation;\n\npublic @interface PropertySource {\n    String name() default \"\";\n    String[] value();\n    boolean ignoreResourceNotFound() default false;\n    String encoding() default \"\";\n    Class<? extends PropertySourceFactory> factory() default PropertySourceFactory.class;\n\n}\n\npublic interface PropertySourceFactory {\n    PropertySource<?> createPropertySource(@Nullable String name, EncodedResource resource) throws IOException;\n}\n```\n\n`PropertySource`的`factory`来表示使用何种`PropertySourceFactory`来实现加载过程，`value`指向的文件会被`spring`加载为`EncodedResource`实例以供`PropertySourceFactory`使用\n\n`value`的值需要为有效资源，若我们需要加载绝对路径的资源文件，我们无视`value`的资源，仅加载自己所需要加载的配置文件。\n首先我们了解下如何加载`yaml`配置\n\n`custom.yml`配置文件,路径为`/Users/li/java/workspace/branches/src/main/resources/custom.yml`\n\n```yml\nfoo: 1\n```\n\n我们可以使用`FileSystemResource`加载文件资源\n\n```java\npackage com.leaderli.branches.utils;\n\nimport org.springframework.beans.factory.config.YamlPropertiesFactoryBean;\nimport org.springframework.core.io.FileSystemResource;\nimport org.springframework.core.io.support.EncodedResource;\n\nimport java.io.File;\nimport java.util.Properties;\n\npublic class ConfigUtil {\n    public static Properties loadYamlIntoProperties(String yml) {\n\n        EncodedResource resource = new EncodedResource(new FileSystemResource(new File(yml)));\n        YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();\n        factory.setResources(resource.getResource());\n        factory.afterPropertiesSet();\n        return factory.getObject();\n    }\n}\n\n```\n\n测试程序\n\n```java\npackage com.leaderli.branches.config;\n\nimport com.leaderli.branches.utils.ConfigUtil;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Properties;\n\nclass YamlPropertySourceFactoryTest {\n    @Test\n    public void test() {\n        String yml = \"/Users/li/java/workspace/branches/src/main/resources/custom.yml\";\n        Properties properties = ConfigUtil.loadYamlIntoProperties(yml);\n        assert  (int)properties.get(\"foo\") == 1;\n    }\n}\n```\n\n接下来只需要实现`PropertySourceFactory`接口即可\n\n```java\npackage com.leaderli.branches.config;\n\nimport com.leaderli.branches.utils.ConfigUtil;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.core.env.PropertiesPropertySource;\nimport org.springframework.core.env.PropertySource;\nimport org.springframework.core.io.support.EncodedResource;\nimport org.springframework.core.io.support.PropertySourceFactory;\n\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class YamlPropertySourceFactory implements PropertySourceFactory {\n    private static final Log LOGGER = LogFactory.getLog(YamlPropertySourceFactory.class);\n\n\n    @Override\n    public PropertySource<?> createPropertySource(String name, EncodedResource resource) throws IOException {\n        Properties propertiesFromYaml = ConfigUtil.loadYamlIntoProperties(\"/Users/li/java/workspace/branches/src/main/resources/custom.yml\");\n        String sourceName = name != null ? name : resource.getResource().getFilename();\n        LOGGER.debug(\"resouce:\" + resource);\n        return new PropertiesPropertySource(sourceName, propertiesFromYaml);\n    }\n\n}\n\n```\n","categories":["spring"],"tags":["properties","yml"]},{"title":"docker_compose","url":"/2019/12/25/docker-compose/","content":"\n## 基础\n\n使用`Dockerfile`和`dockder-compose.yml`来定制容器\n\n### `Dockerfile`\n\n```shell\nFROM li:tomcat\nENTRYPOINT service ssh start && tail -f /dev/null\n```\n\n1. `FROM`表示依赖的镜像\n2. `ENTRYPOINT`容器启动后执行的脚本，可用于启动`ssh`服务等\n\n### `docker-compose.yml`\n\n使用配置文件来确定映射的镜像，参考[compose-file](https://docs.docker.com/compose/compose-file/)\n\n```yml\nversion: \"3\"\nservices:\n  web:\n    build: .\n    image: \"li:linux\"\n    ports:\n      - \"8080:8080\"\n      - \"4022:22\"\n```\n\n1. `services.web.image`构建的镜像名称\n2. `services.web.ports`映射端口\n3. `services.web.build`构建的源文件目录\n","categories":["docker"],"tags":["docker","Dockerfile"]},{"title":"python线程","url":"/2019/12/24/python%E7%BA%BF%E7%A8%8B/","content":"\n## 获取线程执行结果\n\n通过继承自`threading.Thread`，重写其`run`方法来实现\n\n```python\nimport threading\n\n\nclass MyThread(threading.Thread):\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n         使用父类构造器，尽量保持语法一致，仅将线程执行结果缓存\n        \"\"\"\n\n        #设定回调\n        if 'callable' in kwargs:\n            self._callable = kwargs['callable']\n            del kwargs['callable']\n        super(MyThread, self).__init__(*args, **kwargs)\n        self._result = None\n        pass\n\n    def run(self):\n        if self._target:\n            self._result = self._target(*self._args, **self._kwargs)\n\n    def result(self, _callable=None):\n        \"\"\"\n        join()确保任务已经执行完成\n        :return:\n        \"\"\"\n        self.join()\n        # 回调\n        if _callable is None:\n            _callable = self._callable\n        if _callable:\n            _callable(self._result)\n        return self._result\n\n```\n\n测试程序\n\n```python\nimport threading\nimport time\n\ndef foo():\n    time.sleep(1)\n    return time.time()\n\n\ntasks = []\nfor i in range(10):\n    tasks.append(MyThread(target=foo))\nfor t in tasks:\n    t.start()\n\nfor t in tasks:\n    t.result()\n\n```\n","categories":["python"],"tags":["thread"]},{"title":"python队列","url":"/2019/12/24/python%E9%98%9F%E5%88%97/","content":"\n我们直接以代码示例来分析\n\n```python\nimport queue\nimport threading\nimport time\n\n\ndef do_work(item, result):\n    time.sleep(1)\n    result.append(item)\n\n\ndef worker(_queue, _result):\n    while True:\n        item = _queue.get()\n        if item is None:\n            break\n        do_work(item, _result)\n        _queue.task_done()\n\n\ndef join(_queue, num):\n    _queue.join()\n    for x in range(num):\n        _queue.put(None)\n\n\nq = queue.Queue()\nresults = []\nthreads = []\nnum_worker_threads = 10\nfor i in range(num_worker_threads):\n    t = threading.Thread(target=worker, args=(q, results))\n    t.start()\n    threads.append(t)\n\nfor x in range(50):\n    q.put(x)\nprint('size:', q.qsize())\njoin(q, num_worker_threads)\nprint('result:', len(results))\n```\n\n我们查看`queue.join()`的源码\n\n```python\ndef join(self):\n    with self.all_tasks_done:\n        #当unfinished_tasks不为0时一直等待\n        while self.unfinished_tasks:\n            self.all_tasks_done.wait()\n```\n\n```python\n    def put(self, item, block=True, timeout=None):\n        with self.not_full:\n            if self.maxsize > 0:\n                if not block:\n                    if self._qsize() >= self.maxsize:\n                        raise Full\n                elif timeout is None:\n                    while self._qsize() >= self.maxsize:\n                        self.not_full.wait()\n                elif timeout < 0:\n                    raise ValueError(\"'timeout' must be a non-negative number\")\n                else:\n                    endtime = time() + timeout\n                    while self._qsize() >= self.maxsize:\n                        remaining = endtime - time()\n                        if remaining <= 0.0:\n                            raise Full\n                        self.not_full.wait(remaining)\n            self._put(item)\n            #put时unfinished_tasks+1\n            self.unfinished_tasks += 1\n            self.not_empty.notify()\n```\n\n```python\n def task_done(self):\n        with self.all_tasks_done:\n            #task_done时unfinished_tasks-1\n            unfinished = self.unfinished_tasks - 1\n            if unfinished <= 0:\n                if unfinished < 0:\n                    raise ValueError('task_done() called too many times')\n                self.all_tasks_done.notify_all()\n            self.unfinished_tasks = unfinished\n```\n\n根据上述源码我们可以知道，当调用了指定次数的`task_done`时，`join`方法或重新获取到锁，从而离开阻塞状态，对于我们定义的方法`join(_queue, num)`,中先`_queue.joins`,再`put(None)`的原因，是因为我们消费时，当`item`为`None`时直接结束线程执行，而没有再调用一次`task_done`。\n我们可以用上述示例，来实现一个简单的线程池\n","categories":["python"],"tags":["thread","queue"]},{"title":"python装饰器","url":"/2019/12/22/python%E8%A3%85%E9%A5%B0%E5%99%A8/","content":"\n## 基础\n\n`python`装饰器，类似`java`反射，用以实现切面。\n`python`是函数式语言，不需要使用反射，可动态的修改函数或者类。当我们需要给一段函数增加打印函数名和参数的功能时我们可以这样做\n\n```python\ndef hello(name):\n    return 'hello '+name\n\n\ndef log(func):\n    def wrapper(*args, **kwargs):\n        print('-----------before-----------')\n        print(func(*args, **kwargs))\n        print('-----------after-----------')\n    return wrapper\n\n\nhello = log(hello)\n\nhello('li')\n\n```\n\n执行结果如下\n\n> -----------before-----------\n> hello li\n> -----------after-----------\n\n但是当我们`print(hello)`时我们发现\n\n> \\<function log.\\<locals\\>.wrapper at 0x10db2bc80\\>\n\n我们只需要在`log`的内部方法`wrapper`加上注解\n\n```python\nimport functools\n\n\n\n\ndef log(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        print('-----------before-----------')\n        print(func(*args, **kwargs))\n        print('-----------after-----------')\n    return wrapper\n```\n\n这个时候`print(hello)`\n\n> \\<function hello at 0x10ef94c80\\>\n\n## 使用注解实现装饰器\n\n`python`为我们提供了语法糖，来自动实现自动给方法加上装饰器这个过程，只需要使用注解即可\n\n完整代码如下\n\n```python\n\nimport functools\n\n\ndef log(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        print('-----------before-----------')\n        print(func(*args, **kwargs))\n        print('-----------after-----------')\n    return wrapper\n\n\n@log\ndef hello(name):\n    return 'hello '+name\n\n\nhello('li')\n\nprint(hello)\n\n```\n\n输出结果如下\n\n> -----------before-----------\n> hello li\n> -----------after-----------\n> \\<function hello at 0x102690c80\\>\n\n## 类装饰器\n\n`python`还提供了类装饰器，会自动实例化类，并在调用方法时调用类的`__call__`方法。\n需要注意的是，在`__init__`方法，使用参数时，若使用位置参数，则装饰器注解不可带参数，且位置参数有且仅有一个，此参数在运行时即为被装饰的函数。若装饰器注解使用参数，则`__init__`方法，需使用默认参数\n\n```python\nimport functools\n\n\nclass Log(object):\n\n    def __init__(self, func):\n        print('---init---')\n        print(inspect.getfullargspec(a_method))\n\n        self.func = func\n\n    def __call__(self, *args, **kwargs):\n        print('-----------before-----------')\n        print(self.func(*args, **kwargs))\n        print('-----------after-----------')\n\n\n@Log\ndef hello(name):\n    return 'hello '+name\n\n\nhello('li')\nhello('li')\n\nprint(hello)\n```\n\n根据输出结果可以看到，类只加载一次，即`__init__`方法只会执行一次\n\n> ---init---\n> -----------before-----------\n> hello li\n> -----------after-----------\n> -----------before-----------\n> hello li\n> -----------after-----------\n> <**main**.Log object at 0x1048ff668>\n\n## 装饰器使用参数\n\n```python\nimport functools\n\n\ndef log(* args, **kwargs):\n    print(args)\n    print(kwargs)\n\n    def decoractor(func):\n        def wrapper(*args, **kwargs):\n            print(func(*args, **kwargs))\n        return wrapper\n\n    return decoractor\n\n\n@log('hello', 100)\ndef hello(name):\n    return 'hello '+name\n\n\n@log(filter=200)\ndef default(name):\n    return 'hello '+name\n\n\nhello('hello')\ndefault('default')\n\n```\n\n### 类装饰器使用参数\n\n参数需要指定默认值，\n\n```python\nimport functools\n\n\nclass Log(object):\n\n    def __init__(self, name='default'):\n        print('---init---')\n        self.name = name\n\n    def __call__(self, func):\n        def wrapper(*args, **kwargs):\n            print(self.name)\n            print(func(*args, **kwargs))\n        return wrapper\n\n\n@Log('li')\ndef hello(name):\n    return 'hello '+name\n\n\n@Log()\ndef default(name):\n    return 'hello '+name\n\n\nhello('hello')\ndefault('default')\n\n```\n\n参数与位置息息相关\n\n```python\nimport functools\n\nclass Log(object):\n\n    def __init__(self, name=\"default\", filter=0):\n        self.name = name\n        print(filter)\n\n    def __call__(self, func):\n        def wrapper(*args, **kwargs):\n            print(self.name)\n            print(func(*args, **kwargs))\n        return wrapper\n\n\n@Log('hello', 100)\ndef hello(name):\n    return 'hello '+name\n\n\n@Log(filter=200)\ndef default(name):\n    return 'hello '+name\n\n\nhello('hello')\ndefault('default')\n\n```\n","categories":["python"],"tags":["pyhton","decorator","装饰器"]},{"title":"jvm性能排除","url":"/2019/12/19/jvm%E6%80%A7%E8%83%BD%E6%8E%92%E9%99%A4/","content":"\n## 查看`java`进程\n\n```shell\njps #列出本机所有的jvm实例\n```\n\n部分`jps`参数\n\n> -m:输出主函数传入的参数. 下的 hello 就是在执行程序时从命令行输入的参数\n> -l: 输出应用程序主类完整 package 名称或 jar 完整名称.\n> -v: 列出 jvm 参数, -Xms20m -Xmx50m 是启动程序指定的 jvm 参数\n\n## 列出运行中的`Java`程序的运行环境参数\n\n```shell\njinfo <pid>\n```\n\n## 打印每个`class`的实例数目，内存占用，类全名信息。查看是否有类异常加载\n\n```shell\njmap -histo <pid>\n```\n\n示例\n![jvm性能排除_2019-12-19-23-48-31.png](./images/jvm性能排除_2019-12-19-23-48-31.png)\n\n可将上述命令的输出重定向到文件中，然后使用`sort -n -k 2`命令，根据示例数目进行排序，已确定占用数量较多的实例的类\n\n## 查看当前内存使用情况\n\n输出`Java`进程的堆内存信息，包括永久代、年轻代、老年代\n\n```shell\njmap -heap <pid>\n```\n\n示例\n![jvm性能排除_2019-12-19-23-58-41.png](./images/jvm性能排除_2019-12-19-23-58-41.png)\n\n## 实时追踪`GC`情况\n\n`gcutil`是按百分比占比输出`gc`情况的\n\n```java\njstat -gcutil <PID> 5000 # 每5秒输出一次gc\n```\n\n> S0:  新生代中 Survivor space 0 区已使用空间的百分比\n> S1: 新生代中 Survivor space 1 区已使用空间的百分比\n> E: 新生代已使用空间的百分比\n> O: 老年代已使用空间的百分比\n> P: 永久带已使用空间的百分比\n> YGC: 从应用程序启动到当前，发生 Yang GC 的次数\n> YGCT: 从应用程序启动到当前，Yang GC 所用的时间【单位秒】\n> FGC: 从应用程序启动到当前，发生 Full GC 的次数\n> FGCT: 从应用程序启动到当前，Full GC 所用的时间\n> GCT: 从应用程序启动到当前，用于垃圾回收的总时间【单位秒】\n\n示例\n![jvm性能排除_2019-12-20-00-04-43.png](./images/jvm性能排除_2019-12-20-00-04-43.png)\n\n## `jstack`\n\n我们已一个简单的代码来示范如何使用\n\n```java\npublic class Fooloop {\n    public static void main(String[] args) {\n        for (; ; ) {\n\n            System.out.println(\"args = \" + args);\n        }\n    }\n}\n```\n\n启动`Fooloop`后，使用`top`命令查看进程使用情况\n\n进程使用，如果信息过多可考虑使用`top|grep java`,需要清楚哪个是`cpu`的占用信息，对于下述示例为`9`\n![jvm性能排除_2019-12-20-00-39-21.png](./images/jvm性能排除_2019-12-20-00-39-21.png)\n\n我们可以看到`pid`为 432 的进程`cpu`占用率很高，我们使用`top -Hp <pid>`来查看具体是哪个线程`cpu`占用率高。我们可以看到是`433`\n![jvm性能排除_2019-12-20-00-42-52.png](./images/jvm性能排除_2019-12-20-00-42-52.png)\n\n`jstack`命令生成的日志中，关于`nid`是使用`16`进制来表示的，而`top`不是。我们可以使用`printf \"%x\\n\" nid`来讲`10`进制转换为`16`进制。根据此`nid`去`jstack`日志中去找到对应的信息。可使用命令`jstack <pid> |grep -A 30 <nid>`，\n\n我们计算出`433`的十六进制为`1b1`\n![jvm性能排除_2019-12-20-00-45-36.png](./images/jvm性能排除_2019-12-20-00-45-36.png)\n通过日志，可以看出问题出在`Fooloop.main(Fooloop.java:5)`\n\n`jstack`日志中，可以分析是否某个线程持续的输出日志，说明锁的竞争比较激烈，就有可能造成性能问题。我们也可以通过`jps -v`或者`ps -ef|grep java`等来查看具体 java 进程的`pid`。\n","categories":["java"],"tags":["jvm","linux","gc"]},{"title":"jenkins","url":"/2019/12/16/jenkins/","content":"\n## 安装\n\n使用`centos 7`系统安装的`jenkins`服务，\n\n使用安装包进行安装。\n\n```bash\nwget https://pkg.jenkins.io/redhat/jenkins-2.213-1.1.noarch.rpm\nrpm -ivh jenkins-2.213-1.1.noarch.rpm\n```\n\n使用`yum`安装\n\n添加 Jenkins 库到 yum 库，Jenkins 将从这里下载安装。\n\n```bash\nwget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo\nrpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key\nyum install -y jenkins\n```\n\n### 安装过程可能出现的问题\n\n当未卸载干净`jenkins`再进行重装时可能会出现的问题\n\n```txt\nstat: cannot stat ‘/var/cache/jenkins’: No such file or directory\nstat: cannot stat ‘/var/log/jenkins’: No such file or directory\nstat: cannot stat ‘/var/lib/jenkins’: No such file or directory\nerror: %pre(jenkins-2.150.1-1.1.noarch) scriptlet failed, exit status 1\nError in PREIN scriptlet in rpm package jenkins-2.150.1-1.1.noarch\n  Verifying  : jenkins-2.150.1-1.1.noarch                                                                                                                                                                      1/1\n\nFailed:\n  jenkins.noarch 0:2.150.1-1.1\n```\n\n问题的关键是`PREIN scriptlet`，就是`preinstall scriptlet`，这是`rpm`在安装前执行的一段`sh`脚本，为安装创建相应的文件夹什么的。\n\n上面的三个`No such file or directory`显然就是，这三个文件夹没有被创建好。\n\n```bash\nyum install jenkins  --downloadonly --downloaddir=/root\nrpm --scripts -qp jenkins-2.150.1-1.1.noarch.rpm > jenkins.log\n```\n\n查看输出的日志\n\n```txt\nif [ -f \"/etc/sysconfig/jenkins\" ]; then\n      logger -t jenkins.installer \"Found previous config file /etc/sysconfig/jenkins\"\n      . \"/etc/sysconfig/jenkins\"\n      stat --format=%U \"/var/cache/jenkins\" > \"/tmp/jenkins.installer.cacheowner\"\n      stat --format=%U \"/var/log/jenkins\"  >  \"/tmp/jenkins.installer.logowner\"\n      stat --format=%U ${JENKINS_HOME:-/var/lib/jenkins}  > \"/tmp/jenkins.installer.workdirowner\"\n  else\n      logger -t jenkins.installer \"No previous config file /etc/sysconfig/jenkins found\"\n  fi\n```\n\n这问题就很明白了，结合前面的`stat`报错，明确了就是这段报错误。这段的意思是，如果`/etc/sysconfig/jenkins`存在，执行下面一系列操作，应该是为了重复安装写的。\n\n删除文件夹`/var/lib/jenkins,/var/log/jenkins/,/var/cache/jenkins`即可\n\n## 启动\n\n`jenkins`启动时会输出日志，可通过查看日志定位具体错误信息。\n\n```bash\ntail -f /var/log/jenkins/jenkins.log\n```\n\n使用`rpm`安装`jenkins`时，默认会创建`jenkins:jenkins`的用户以及用户组，如果用其他用户启动，需要将以下文件夹用户以及用户组变更\n\n1. /usr/lib/jenkins/jenkins.war WAR 包\n2. /etc/sysconfig/jenkins 配置文件\n3. /var/lib/jenkins/ 默认的 JENKINS_HOME 目录\n4. /var/log/jenkins/jenkins.log Jenkins 日志文件\n\n启停服务,使用`systemctl`工具操作`jenkins`\n\n```shell\nsystemctl start jenkins\nsystemctl stop jenkins\nsystemctl status jenkins\n```\n\n### 修改端口\n\n`vi /etc/sysconfig/jenkins`修改`JENKINS_PORT=\"8081\"`\n\n### 防火墙\n\n当虚拟机外部需要访问`jenkins`时，需要将`centos`的防火墙关闭\n\n1. 使用命令`systemctl status firewalld.service`查看防火墙状态\n2. 使用命令`systemctl disable firewalld.service`，即可永久禁止防火墙服务\n","categories":["java"],"tags":["jenkins","centos"]},{"title":"excel","url":"/2019/12/06/excel/","content":"\n## 折线图\n\n![excel_2019-12-06-01-21-28.png](./images/excel_2019-12-06-01-21-28.png)\n`excel` 折线图的单元格需要为数字，否则无法成功转换。有时候需要将走上角第一个空出来。可以通过更改数据类型进行 x,y 轴反转\n","categories":["tips"],"tags":["excel","tips"]},{"title":"js-tips","url":"/2019/12/05/js-tips/","content":"\n## 格式化输出 json\n\n```javascript\nvar json = JSON.stringify(jsonObj, null, 4);\nconsol.log(json);\n```\n\n## 名字空间\n\n全局变量会绑定到`window`上，不同的 JavaScript 文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。\n\n减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：\n\n```javascript\n// 唯一的全局变量MYAPP:\nvar MYAPP = {};\n\n// 其他变量:\nMYAPP.name = \"myapp\";\nMYAPP.version = 1.0;\n\n// 其他函数:\nMYAPP.foo = function () {\n  return \"foo\";\n};\n```\n\n把自己的代码全部放入唯一的名字空间`MYAPP`中，会大大减少全局变量冲突的可能。\n\n许多著名的 JavaScript 库都是这么干的：jQuery，YUI，underscore 等等。\n\n## 标准对象\n\n总结一下，有这么几条规则需要遵守：\n\n- 不要使用`new Number()`、`new Boolean()`、`new String()`创建包装对象；\n- 用`parseInt()`或`parseFloat()`来转换任意类型到`number`；\n- 用`String()`来转换任意类型到`string`，或者直接调用某个对象的`toString()`方法；\n- 通常不必把任意类型转换为`boolean`再判断，因为可以直接写`if (myVar) {...}`；\n- `typeof`操作符可以判断出`number`、`boolean`、`string`、`function`和`undefined`；\n- 判断`Array`要使用`Array.isArray(arr)`；\n- 判断`null`请使用`myVar === null`；\n- 判断某个全局变量是否存在用`typeof window.myVar === 'undefined'`；\n- 函数内部判断某个变量是否存在用`typeof myVar === 'undefined'`。\n\n最后有细心的同学指出，任何对象都有`toString()`方法吗？`null`和`undefined`就没有！确实如此，这两个特殊值要除外，虽然`null`还伪装成了`object`类型。\n\n更细心的同学指出，`number`对象调用`toString()`报 SyntaxError：\n\n```javascript\n123.toString(); // SyntaxError\n```\n\n遇到这种情况，要特殊处理一下：\n\n```javascript\n(123).toString(); // '123', 注意是两个点！\n(123).toString(); // '123'\n```\n\n不要问为什么，这就是 JavaScript 代码的乐趣！\n\n## JSON\n\n在 JSON 中，一共就这么几种数据类型,并且，JSON 还定死了字符集必须是 UTF-8，表示多语言就没有问题了。为了统一解析，JSON 的字符串规定必须用双引号`\"\"`，Object 的键也必须用双引号`\"\"`。\n\n- `number`：和 JavaScript 的 number 完全一致；\n\n- `boolean`：就是 JavaScript 的 true 或 false；\n\n- `string`：就是 JavaScript 的 string；\n\n- `null`：就是 JavaScript 的 null；\n\n- `array`：就是 JavaScript 的 Array 表示方式——[]；\n\n- `object`：就是 JavaScript 的{ ... }表示方式。\n\n## COOKIE\n\n服务器在设置 Cookie 时可以使用 httpOnly，设定了 httpOnly 的 Cookie 将不能被 JavaScript 读取。这个行为由浏览器实现，主流浏览器均支持 httpOnly 选项，IE 从 IE6 SP1 开始支持。\n\n为了确保安全，服务器端在设置 Cookie 时，应该始终坚持使用 httpOnly。\n\n## 作用域\n\n1. 在 object 内的 function this 指向 object，而属于 function 内部的闭包函数 this 指向 window 对象,纯 function this 也指向 window 对象\n\n2. “自由变量”。在 A 作用域中使用的变量 x，却没有在 A 作用域中声明（即在其他作用域中声明的），对于 A 作用域来说，x 就是一个自由变量。如下\n\n```javascript\nvar x = 10;\nfunction fn() {\n  var b = 20;\n  console.log(x + b); //这里的x在这里就是一个自由变量\n}\n```\n\n如上程序中，在调用 fn()函数时，函数体中第 6 行。取 b 的值就直接可以在 fn 作用域中取，因为 b 就是在这里定义的。而取 x 的值时，就需要到另一个作用域中取。到哪个作用域中取呢？\n\n有人说过要到父作用域中取，其实有时候这种解释会产生歧义。例如：\n\n```javascript\nvar x = 10;\nfunction fn() {\n  console.log(x);\n}\nfunction show(f) {\n  var x = 20;\n  (function () {\n    f(); //10 而不是20\n  })();\n}\nshow(fn);\n```\n\n要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记——其实这就是所谓的“静态作用域”。\n\n## 原型\n\n```javascript\nfunction Fn() {}\nFn.prototype.name = \"xiaoming\";\nFn.prototype.getYear = function () {\n  return 1988;\n};\n\nvar fn = new Fn();\nconsole.log(fn.name);\nconsole.log(fn.getYear());\n```\n\n1. 函数 Fn 也是对象，每个函数都有一个属性`prototype`，`prototype`的值为原型对象\n2. fn 为 Fn 函数的一个实例对象，每个对象都有一个隐藏属性 `__proto__`,fn 的`__proto__`指向 Fn 的`prototype`，即原型对象。\n3. Object.prototype 是一个特例——它的`__proto__`指向的是 null\n4. 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着`__proto__`这条链向上找，这就是原型链。\n\n![js-tips_2020-04-25-13-18-14.png](./images/js-tips_2020-04-25-13-18-14.png)\n\n## 执行上下文\n\n函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。\n\n```javascript\nconsole.log(f1); // function f1(){};\nconsole.log(f2); //undefined\nfunction f1() {}\nvar f2 = function () {};\n```\n\n在初始化时，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。\n\n全局代码的上下文环境数据内容为：\n\n好了，总结完了函数的附加内容，我们就此要全面总结一下上下文环境的数据内容。\n\n全局代码的上下文环境数据内容为：\n\n- 普通变量（包括函数表达式），如： var a = 10; `声明（默认赋值为undefined）`\n  - 函数声明，如： function fn() { } `赋值`\n    - this `赋值`\n\n如果代码段是函数体，那么在此基础上需要附加：\n\n- 参数 `赋值`\n  - arguments `赋值`\n  - 自由变量的取值作用域 `赋值`\n\n给执行上下文环境下一个通俗的定义——在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用`undefined`占个空。\n\n## js 可变参数\n\n```javascript\nvar a = 100;\nvar b = 100;\n\nfunction test() {\n  var obj = {};\n\n  for (var i = 0; i < arguments.length; i++) {\n    var name = arguments[i];\n    obj[name] = eval(name);\n  }\n\n  return obj;\n}\nconsole.log(test(\"a\", \"b\"));\n```\n\n## 根据空行分割字符串\n\n```javascript\nconsole.log(str.trim().split(/\\s+/));\n```\n\n## js 进制\n\n```javascript\n//二进制0b开头\n//八进制0开头\n//十六进制0x开头\nvar a = 0b10;\nvar b = 070;\nvar c = 0x36;\n```\n","categories":["js"],"tags":["tips","js"]},{"title":"css","url":"/2019/12/03/css/","content":"\n## 多个`class`生效问题\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Title</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"c1.css\" />\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"c2.css\" />\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"c3.css\" />\n  </head>\n  <body>\n    <div class=\"c1 c2\">c1 c2</div>\n    <div class=\"c2 c1\">c2 c1</div>\n    <div class=\"c2 c3\">c2 c3</div>\n    <div class=\"c3 c2\">c3 c2</div>\n  </body>\n</html>\n```\n\n`c1.css`\n\n```css\n.c1 {\n  color: blue;\n}\n```\n\n`c2.css`\n\n```css\n.c2 {\n  color: green;\n}\n```\n\n`c3.css`\n\n```css\n.c3 {\n  color: red;\n}\n```\n\n显示效果\n\n![css_2019-12-04-00-38-34.png](./images/css_2019-12-04-00-38-34.png)\n当一个`div`指定多个`class`时，和指定`css`样式的顺序无关，只和加载`css`的顺序有关\n\n## 带有层级的`class`\n\n描述越具体的选择器优先级越高\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Title</title>\n    <style>\n      .c1 {\n        color: green;\n      }\n\n      .c2 {\n        color: black;\n      }\n\n      .c1 .c2 {\n        color: red;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"c1\">c1</div>\n    <div class=\"c2\">c2</div>\n    <div class=\"c1 c2\">\n      c1\n      <div class=\"c2\">c2</div>\n    </div>\n  </body>\n</html>\n```\n\n显示效果\n![css_2019-12-06-01-36-04.png](./images/css_2019-12-06-01-36-04.png)\n","categories":["css"],"tags":["css"]},{"title":"响应式编程学习","url":"/2019/11/26/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/","content":"\n\n","categories":["响应式编程"],"tags":["reactor"]},{"title":"git","url":"/2019/11/21/git/","content":"\n## 安装 git\n\n系统使用 centos7\n\n```shell\n$ cd /usr/local/src wget https://github.com/git/git/archive/master.zip\n$ unzip master.zip\n# 由于系统中已存在 git，所以先备份现有 git。\n$ mv /usr/bin/git{,.bak}\n# 编译安装\ncd /usr/local/src/git-master\n$ make configure\n$ ./configure --prefix=/usr/bin\n$ make && make install\n# 拷贝到原有 Git 所在位置\n$ cp /usr/local/src/git-master/git /usr/bin\n```\n\n## 配置\n\n### `gitignore`\n\n1. `/mtk`过滤整个文件夹,但不过滤子文件夹\n2. `mtk/`过滤文件夹所有文件\n3. `\\*.zip` 过滤所有`.zip` 文件\n4. `/mtk/do.c` 过滤某个具体文件\n5. `!/mtk/one.txt` 追踪（不过滤）某个具体文件\n\n注意：如果你创建`.gitignore` 文件之前就`push`了某一文件，那么即使你在`.gitignore`文件中写入过滤该文件的规则，该规则也不会起作用，`git` 仍然会对该文件进行版本管理。\n\n#### `gitignore`不生效\n\n`.gitignore` 中已经标明忽略的文件目录下的文件，`git push` 的时候还会出现在 `push` 的目录中，原因是因为在 `git` 忽略目录中，新建的文件在 `git` 中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在`.gitignore` 中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行 `git` 的 `push`，这样就不会出现忽略的文件了。`git` 清除本地缓存命令如下：\n\n```shell\ngit rm -r --cached .\ngit add .\ngit commit -m 'update .gitignore'\n```\n\n### 别名\n\n我们可通过配置 alias 来简化 git 命令\n`git config –-global --edit`来编辑`[alias]`下面的配置别名\n\n```config\n[alias]\nal = config --get-regexp alias\nb = branch\ncm = commit -m\nco = checkout --\ncp = cherry-pick\ndt = difftool\nmt = mergetool\nmg = merge --no-ff -m\nl = log --graph --pretty=oneline --abbrev-commit\npl = pull\nps = push\nst = status -s\nsw = checkout\n```\n\n## 查看\n\n### 查看状态\n\n`git show`默认查看当前`<commit>`提交的内容，可使用`git show <commit>`查看具体某个提交的信息\n`git status`查看当前工作区与暂存区状态，可使用`git status -s`简化输出信息。类似如下的信息`M`表示有改动,`D`表示删除,`??`表示未`add`,`A`表示新增但未提交\n\n> M 1.txt\n> D 2.txt\n> ?? 4.txt\n> A 5.txt\n\n### 查看缓存区文件\n\n`git ls-fles` 显示`index`和工作区的文件的信息。\n选项\n\n含义\n\n> -c, --cached\n> 显示缓存了的文件（默认）\n> -d, --deleted\n> 显示删除了的文件\n> -m, --modified\n> 显示修改了的文件\n> -o, --others\n> 显示其他类型的文件（比如未追踪的）\n> -i, --ignored\n> 显示忽略了的文件（满足忽略模式的）\n> -s, --stage\n> 显示暂存的条目的相关信息（模式位，文件哈希后的值，暂存号和文件名），\n\n### 日志\n\n`git log` 命令显示从最近到最远的提交日志,如果嫌输出信息太多，看得眼花缭乱的，可以试试加上`--pretty=oneline`参数\n\n```shell\ngit log --pretty=oneline\n```\n\n显示所有分支关系\n\n```shell\ngit log --graph --decorate --oneline --all\n```\n\n使用自带图形化工具查看\n\n```shell\ngitk --all\n```\n\n查看文件修改历史记录，显示差异\n\n```shell\ngit log -p <file>\n```\n\n### 比较差异\n\n`git diff`比较工作区和缓存区，当修改工作区内容时且未`add`,缓存区的内容则与工作区有差异，此时缓存区与仓库同样是没有变动，所以使用`git diff --cached`,发现没有差异，当使用`add`后，缓存区则和工作区相同了。单因为没有`commit`,所以使用`git diff --cached`，可以看到差异的内容。当使用`commit`后，则变成一致的状态  \n用 `git diff HEAD -- readme.txt` 命令可以查看工作区和版本库里面最新版本的区别，`HEAD`可以使用`git log`或者`git reflog`查看的版本号替换\n\n```shell\ngit diff\ngit diff --cached\ngit diff HEAD\n\ngit diff -- file\ngit diff --cached --file\ngit diff HEAD -- file\n```\n\n可使用第三方软件来比较\n目前`mac`上安装的是`Kaleidoscope`\n`git difftool`使用方式类似`git diff`\n\n比较两个`commit`的差异\n\n```shell\ngit diff <commit1> <commit2>\n```\n\n要查看有哪些文件发生了变化，可以加上--stat 参数\n\n```shell\ngit diff <commit1> <commit2> --stat\n```\n\n若想查看目录的变化，可以使用--dirstat\n\n```shell\ngit diff <commit1> <commit2> --dirstat=files\n```\n\n仅查看某文件夹下的版本差异\n\n```shell\ngit diff --stat <commit1> <commit2> dir\n```\n\n显示冲突`conflict` 文件,`--diff-filter`也可用来过滤新增文件等\n\n```shell\ngit diff --name-only --diff-filter=U\n```\n\n### 命令历史记录\n\n`git reflog`用来记录你的每一次命令\n\n### 查找丢失记录\n\n`git fsck --full`检查数据库的完整性。 如果使用一个 --full 选项运行它，它会向你显示出所有没有被其他对象指向的对象：\n\n## 提交\n\n### 追加提交\n\n重写更改提交信息,执行后会把最近`add`的内容一并放入到此次`commit`\n\n```shell\ngit commit --amend\n```\n\n## 回退,撤销\n\n`HEAD^`或`HEAD~`表示上一个版本，用`git log`可以查看提交历史，以便确定要回退到哪个版本。`git reflog`查看命令历史，以便确定要回到未来的哪个版本。\n\n### `checkout`\n\n1. 未`add`到`stage`时可用`git checkout -- file`,丢弃工作区的修改。\n2. 以`add`到`stage`先用`git reset HEAD <file>`可以把暂存区的修改撤销掉（`unstage`），重新放回工作区，然后再丢弃工作区修改\n3. `git checkout <branch>`切换分支\n4. `git checkout -b <branch> <commit>` 在`commit`创建一个分支\n\n### `reset`\n\n![深入git_reset细节.png](./images/深入git_reset细节.png)\n\n### `revert`\n\n> `git revert <commit>`，撤销提交。不同于`reset`，`revert`不是回退版本，而是通过一个新的反向的提交来实现。会进入交互模式，需要填写新的`commit`信息\n> `git revert -n <commit>`,撤销提交，需要手动`commit`\n\n### `apply`\n\n补丁\n\n## 分支\n\n### 创建分支\n\n我们创建`dev`分支，然后切换到`dev`分支：\n\n```shell\ngit checkout -b dev`\n```\n\n### 查看当前分支\n\n查看当前分支，当前分支前面会标一个`*`号。\n\n```shell\ngit branch`\n```\n\n### 重命名分支\n\n在当前分支下重命名分支\n\n```shell\ngit branch -m new-name\n```\n\n### 分支策略\n\n首先，`master`分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在`dev`分支上，也就是说，`dev`分支是不稳定的，到某个时候，比如`1.0`版本发布时，再把`dev`分支合并到`master`上，在`master`分支发布`1.0`版本；你和你的小伙伴们每个人都在`dev`分支上干活，每个人都有自己的分支，时不时地往`dev`分支上合并就可以了。\n\n所以，团队合作的分支看起来就像这样：\n![git_2019-12-05-00-32-43.png](./images/git_2019-12-05-00-32-43.png)\n\n### 合并分支\n\n合并分支,把`dev`分支的工作成果合并到`master`分支上：\n\n```shell\ngit merge dev\n```\n\n通常，合并分支时，如果可能，`Git`会用`Fast forward`模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用`Fast forward`模式，`Git`就会在`merge`时生成一个新的`commit`，这样，从分支历史上就可以看出分支信息。\n\n```shell\ngit merge --no-ff -m \"merge with no-ff\" dev\n\n```\n\n### 删除分支\n\n如果要丢弃一个没有被合并过的分支，可以通过 `git branch -D <name>`强行删除。\n\n### 移动分支\n\n我有两个`git`分支，`A`和`B`，并提交编号 1 到 8。我的历史记录如下\n\n> 1 -> 2 -> 3 -> 4[A] -> 5 -> 6 -> 7 -> 8[B]\n\n我想更改它，以便我的历史记录如下：\n\n> 1 -> 2 -> 3 -> 4 -> 5 -> 6[A] -> 7 -> 8[B]\n\n也就是说，我想将分支`A`的头从提交 4 移动到提交 6。\n\n```shell\ngit branch -f A 6\n```\n\n### 挑选提交\n\n同上示例，加入`A`分支仅希望用 7 这个提交\n那么我们可以使用`cherry-pick`,在`A`分支下使用\n\n```shell\ngit  cherry-pick 7\n```\n\n### 挑选文件\n\n当我们需要用别的分支的文件覆盖本分支的文件时可以使用如下命令，该命令会同时覆盖工作区和缓存区的文件\n\n```shell\ngit checkout <branch> <file>\n```\n\n## 标签\n\n### 新建标签\n\n分支打标签，默认标签是打在最新提交的`commit`上的。还可以创建带有说明的标签，用`-a`指定标签名，`-m`指定说明文字\n\n```shell\ngit tag v1.0\ngit tag -a v0.1 -m \"version 0.1 released\"\n\n```\n\n默认标签是打在最新提交的`commit`上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？  \n方法是找到历史提交的`commit id`，然后打上就可以了：\n\n```shell\ngit tag v0.9 f52c633\n```\n\n### 删除标签\n\n```shell\ngit tag -d v0.1\n```\n\n### 查看标签\n\n查看所有标签\n\n```shell\ngit tag\n```\n\n查看标签信息，可以看到标签说明文字\n\n```shell\ngit show tag\n```\n\n### 操作标签\n\n类似`<commit>`的作用，可以使用`checkout`,`reset`等\n\n### 更新远程标签\n\n当使用`git fetch`命令时，本地已经有的标签不会被更新为远程的值\n我们需要先将本地的标签删除后再更新\n\n```bash\ngit tag -l |xargs git tag -d\n```\n\n## `rebase`\n\n提交信息过多过杂，或者分支合并操作过多,可以使用`git rebase`整理提交记录\n\n```shell\ngit rebase -i ID #-i交互模式，来觉得哪些分支的记录会被保留\n```\n\n交互模式的`command`选项\n\n> pick：正常选中\n> reword：选中，并且修改提交信息；\n> edit：选中，rebase 时会暂停，允许你修改这个 commit（参考这里）\n> squash：选中，会将当前 commit 与上一个 commit 合并\n> fixup：与 squash 相同，但不会保存当前 commit 的提交信息\n> exec：执行其他 shell 命令\n> merge:将几个 commit 合并为一个 commit\n\n### 合并第一条和第二条记录\n\n1. 首先我们查看当前提交记录\n   ![git_2020-01-04-11-18-26.png](./images/git_2020-01-04-11-18-26.png)\n2. 我们使用`git rebase -i da0e80b`\n   ![git_2020-01-04-11-19-59.png](./images/git_2020-01-04-11-19-59.png)\n3. 将`df060c5`前更改为`edit`状态后保存退出\n   ![git_2020-01-04-11-21-41.png](./images/git_2020-01-04-11-21-41.png)\n4. 使用`git reset --soft HEAD^`,保留第二版的改动回退到第一个版本\n   ![git_2020-01-04-11-27-41.png](./images/git_2020-01-04-11-27-41.png)\n5. 将改动追加提交到第一个版本即可`git commmit --amend`\n   ![git_2020-01-04-11-29-59.png](./images/git_2020-01-04-11-29-59.png)\n6. 继续`rebase`,使用`git rebase --continue`\n   ![git_2020-01-04-11-30-56.png](./images/git_2020-01-04-11-30-56.png)\n\n当然我们可以使用更简单的命令`git rebase -i --root`\n\n### 合并策略\n\n基本使用命令如下，仅介绍两个策略\n\n```shell\ngit merge <branch> --strategy=<strategy>\n```\n\n#### `ours`\n\n在合并的时候，无论有多少个合并分支，当前分支就直接是最终的合并结果。无论其他人有多少修改，在此次合并之后，都将不存在（当然历史里面还有）。你可能觉得这种丢失改动的合并策略没有什么用。但如果你准备重新在你的仓库中进行开发（程序员最喜欢的重构），那么当你的修改与旧分支合并时，采用此合并策略就非常有用，你新的重构代码将完全不会被旧分支的改动所影响。\n\n#### `recursive`\n\n默认的合并策略是`recursive`,此策略可以指定额外参数\n\n1. `ours`如果不冲突，那么与默认的合并方式相同。但如果发生冲突，将自动应用自己这一方的修改。注意策略里面也有一个`ours`，与这个不同的。\n\n2. `theirs`这与 `ours`相反。如果不冲突，那么与默认的合并方式相同。但如果发生冲突，将自动应用来自其他人的修改（也就是 `merge`参数中指定的那个分支的修改）。\n\n```shell\ngit merge --no-ff -m 'msg' <branch> --strategy=recursive --strategy-option=theirs\n#可以简化成\ngit merge --no-ff -m 'msg' <branch> --strategy-option=theirs\n\n```\n\n## 远程仓库\n\n### 将新项目导入远程仓库\n\n```shell\ngit init\ngit remote add origin <uri>\ngit remote rename origin old-origin #重命名\ngit add .\ngit commit -m 'init '\ngit push -u origin master\ngit push -u origin  --all #推送所有分支\n\n```\n\n### 查看远程仓库\n\n```shell\ngit remote\n```\n\n### 删除远程分支\n\n```shell\ngit push origin --delete test\n\n# 远程已经删除的分支，在本地执行 git branch -a 显示还存在，可通过如下方式删除\ngit remote prune origin\n```\n\n### 拉取远程仓库的更新\n\n```shell\ngit fetch\ngit fetch --all\ngit fetch -p #会自动删除本地已经失效的远程分支\n```\n\n### 强制更新覆盖为远程分支\n\n```shell\ngit reset --hard <remote>/<branch>\n```\n\n### 推送到远程\n\n```shell\ngit push #推送前会校验是否在最新状态\ngit push -f #强制推送\n```\n\n## `Git`原理\n\n参考{% post_link 深入git %}\n","categories":["tips"],"tags":["tips","git"]},{"title":"分布式锁实现","url":"/2019/11/20/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/","content":"\n## 临界区\n\n临界区指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待（例如：bounded waiting 等待法），有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共用资源是被互斥获得使用，例如：semaphore。只能被单一线程访问的设备，例如：打印机。\n\n## 锁\n\n当多个线程访问临界区资源时，可能会引起冲突。那么我们需要实现以下效果\n\n1. 同一时间内，仅有一个线程可以访问临界区\n2. 具备可重入性\n\n同时为了防止死锁，我们需要\n\n1. 具备锁失效机制\n2. 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。一般情况下在尝试一段时间后返回失败\n\n## java 线程锁\n\n在了解分布式锁之前我们先了解一下`java`的两种锁的实现\n\n### `synchronized`\n\n```java\nObject lock = new Object();\nsynchronized (lock) {\n}\n```\n\n查看上述代码的字节码\n\n```java\n11: monitorenter\n12: aload_2\n13: monitorexit\n```\n\n我们可以观察到在进入`synchronized`代码块时，使用`monitorenter`指定获取锁，在结束代码块的语句时，使用`monitorexit`，释放锁。\n\n等待锁的过程\n![分布式锁实现_2019-11-20-01-13-39.png](./images/分布式锁实现_2019-11-20-01-13-39.png)\n\n参考{% post_link java数组 %}中关于对象头的部分，对象在有锁的情况下，会保存占用锁的线程指针。从而保证在同一个时刻，仅允许一个线程可以占用`monitor`锁，无法获取`monitor`锁的线程被阻塞直到对象释放锁。\n\n### `AbstractQueuedSynchronizer`\n\n以`ReentrantLock`为代表的同步锁框架是基于`AQS`，`AQS`依赖`FIFO`队列实现。线程获取锁通过`tryAcquire`向`FIFO`插入并使用乐观锁`CAS`的方式，判断是否为`HEAD`节点，若是`HEAD`节点则表示获取到锁，释放锁则通过`tryRelease`该队列的`HEAD`节点，并唤醒等待节点。\n\n[JVM 源码分析之 Object.wait/notify 实现](https://www.jianshu.com/p/f4454164c017)\n\n## 分布式锁\n\n### 构建测试程序\n\n在分布式场景下，无法通过`JVM`内存来保持一致性。我们需要一个定义一个临界区。对于锁的实现，和`java`锁没有本质区别，仅在于实现方式不同\n\n首先我们构造测试程序,我们使用`SpringBoot`构建项目\n\n`pom`依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.2.1.RELEASE</version>\n    <relativePath/> <!-- lookup parent from repository -->\n  </parent>\n  <groupId>com.leaderli</groupId>\n  <artifactId>demo</artifactId>\n  <version>0.0.1-SNAPSHOT</version>\n  <name>demo</name>\n  <description>Demo project for Spring Boot</description>\n\n  <properties>\n    <java.version>1.8</java.version>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.mybatis.spring.boot</groupId>\n      <artifactId>mybatis-spring-boot-starter</artifactId>\n      <version>2.1.0</version>\n    </dependency>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-test</artifactId>\n      <scope>test</scope>\n      <exclusions>\n        <exclusion>\n          <groupId>org.junit.vintage</groupId>\n          <artifactId>junit-vintage-engine</artifactId>\n        </exclusion>\n      </exclusions>\n    </dependency>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n</project>\n\n```\n\n配置文件\n\n```yaml\nspring:\n  application:\n    name: demo\n  datasource:\n    url: jdbc:mysql://localhost:3306/li\n    username: root\n    password: root\n    driver-class-name: com.mysql.cj.jdbc.Driver\nlogging:\n  level:\n    root: error\nlock:\n  use: nolock\n  bean:\n    name: coral\n    machine: mymac\n```\n\n临界资源\n\n```java\npackage com.leaderli.demo.lock;\n\npublic class CriticalSection {\n    public static int ID = 0;\n}\n\n```\n\n锁接口\n\n```java\npackage com.leaderli.demo.lock;\n\npublic interface Lock {\n\n    boolean lock();\n\n    void unlock();\n}\n```\n\n为了使代码清晰，封装一些方法\n\n```java\npackage com.leaderli.demo.util;\n\nimport java.util.Random;\n\npublic class SomeUtils {\n\n    public static void sleep(long millis) {\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static Random random = new Random();\n\n    public static int random(int boundary) {\n        return random.nextInt(boundary);\n    }\n\n    public static void logWithThread(Object msg) {\n        System.out.println(Thread.currentThread() + \"\\t\" + String.valueOf(msg));\n    }\n\n    public static void join(Thread thread) {\n        try {\n            thread.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n\n测试程序\n\n```java\npackage com.leaderli.demo.lock;\n\n\nimport com.leaderli.demo.util.SomeUtils;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.context.ApplicationContext;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@SpringBootTest\nclass LockTest {\n    @Autowired\n    ApplicationContext applicationContext;\n\n\n    int maxThreadCount = 10;\n    int endID = 1000;\n    //设置合适的值，确保持有锁期间，其他线程企图获取锁\n    int randomBoundary = 10;\n\n    @Test\n    public void test() {\n        Runnable task = () -> {\n            //所有Lock实现类都为非单例，保证所有线程的锁不为同一个对象以模拟分布式锁\n            Lock lock = applicationContext.getBean(Lock.class);\n            while (true) {\n                //不断消费序列号，直到测试结束\n                if (task(lock)) {\n                    return;\n                }\n            }\n\n        };\n\n        List<Thread> threadPool = new ArrayList<>();\n        for (int i = 1; i <= maxThreadCount; i++) {\n            Thread cosumer = new Thread(task);\n            cosumer.setName((100 - i) + \"\");\n            threadPool.add(cosumer);\n        }\n        threadPool.forEach(Thread::start);\n        threadPool.forEach(SomeUtils::join);\n        //断言程序是否正常结束\n        Assertions.assertEquals(endID, CriticalSection.ID);\n    }\n\n    public boolean task(Lock lock) {\n        if (lock.lock()) {\n            //模拟重入锁\n            if (SomeUtils.random(3) == 1) {\n                if (task(lock)) {\n                    return true;\n                }\n            }\n            try {\n                int a = CriticalSection.ID + 1;\n                SomeUtils.sleep(SomeUtils.random(randomBoundary));\n                if (CriticalSection.ID >= endID) {\n                    //达到最大值，测试结束\n                    return true;\n                }\n                CriticalSection.ID++;\n                if (a != CriticalSection.ID) {\n                    //断言失败，结束程序\n                    return true;\n                }\n            } finally {\n                lock.unlock();\n            }\n        }\n        return false;\n    }\n}\n```\n\n通过使用`SpringBoot`的注解`ConditionalOnProperty`来方便测试\n首先我们测试没有锁的情况下\n\n```java\npackage com.leaderli.demo.lock;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.stereotype.Component;\n\n@ConditionalOnProperty(prefix = \"lock\", name = \"use\", havingValue = \"nolock\")\n@Component\n@Scope(BeanDefinition.SCOPE_PROTOTYPE)\npublic class NoLock implements Lock {\n\n    @Override\n    public boolean lock() {\n        return true;\n    }\n\n    @Override\n    public void unlock() {\n    }\n}\n```\n\n配置文件中将`NoLock`类激活，即`lock.use=nolock`  \n![分布式锁实现_2019-11-21-00-56-35.png](./images/分布式锁实现_2019-11-21-00-56-35.png)\n我们很容易就观察到没有锁时，一个线程在运行期间，临界区资源被修改了\n\n### 数据库锁\n\n根据锁的原则，我们使用数据库锁需要考虑的实现方式:\n\n1. 我们通过数据库唯一约束(主键约束)来确保同一时间内，仅有一个线程可以访问临界区资源。通过唯一`ID`，获取锁时插入锁，释放锁则删除锁记录\n2. 为了确保可重入性，我们需要记录占用锁的线程，同时为了保证仅在所有重入锁都释放后再释放锁，我们需要记录重入锁的次数，释放锁时判断重入锁次数是否为`0`，为`0`则删除锁记录\n\n3. 为了具有锁失效机制，当线程占用锁后出现异常情况，没有释放锁，会导致锁一直被占用，其他线程无法获取锁。所以我们需要记录获取锁的时间，以及设定锁的失效时间。则在获取锁时判断是否锁已经失效，失效则删除锁。\n\n4. 为了具有非阻塞锁特性，在线程获取锁时，首先查询数据库锁是否被占用，若被占用，则重新尝试，达到指定次数后，则直接返回获取锁失败。通过`insert`插入锁失败，也直接返回失败\n\n### `redis`锁\n\n--\n\n### `zookeeper`锁\n\n--\n","categories":["java"],"tags":["redis","分布式锁","synchronized","ConditionalOnProperty","ConfigurationProperties","zookeeper"]},{"title":"Stream流工作原理浅析与模仿","url":"/2019/11/17/Stream%E6%B5%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%E4%B8%8E%E6%A8%A1%E4%BB%BF/","content":"\n尝试分析`Stream`流工作原理，并模仿其工作原理实现一些轮子。\n\n## 使用`AND`,`OR`,`NOT`拆分复杂`boolean`操作\n\n参照`Stream`的工作方式，我们将运算逻辑缓存，仅在终结节点`end()`才开始计算\n要实现链式调用，那么方法`and()`,`or()`,`not()`,`test()`就需要返回类型相同的对象，我们定义`PipeLine`类来进行链式调用\n对于我们需要实现的`boolean`工具，我们需要关心的问题\n\n1. 如何进行计算\n2. 何时结束\n3. 规则校验\n4. 运算结果如何保存\n\n我们定义`Sink`类来保存运算逻辑:\n\n1. `accpet`方法，进行逻辑运算以及流程走向\n2. `cancel`方法，决定是否需要终结流程\n3. `valid`方法，校验链式调用语法是否合法，因为连续调用两次`and`，是无法进行计算的\n4. 通过外部传递的`Bool`对象来保存运算结果\n\n```java\npackage com.leaderli.demo.bool;\n\n\nimport java.util.Arrays;\nimport java.util.function.Predicate;\n\npublic class PipeLine<T> {\n\n\n    /**\n     * 在调用end时，需要找到第一个节点进行运算\n     */\n    private PipeLine<T> prev;\n    /**\n     * 存储结果，仅在显式new PipeLine时初始化\n     */\n    private Bool bool;\n    /**\n     * 每个PipeLine绑定一个操作\n     */\n    private Sink<T> sink;\n\n\n    private PipeLine(Bool bool) {\n        this.bool = bool;\n    }\n\n    public PipeLine() {\n        this.bool = new Bool();\n        begin();\n    }\n\n    /**\n     * 本身不做任何逻辑运算，仅锚定开始位置\n     */\n    private void begin() {\n        this.sink = new Sink<T>(bool, Sink.Type.BEGIN) {\n            @Override\n            public Sink<T> accept(T test) {\n                return next;\n            }\n\n            @Override\n            public void valid() {\n                valid(Type.TEST, Type.NOT);\n\n            }\n        };\n        this.prev = null;\n    }\n\n    /**\n     * 实现链表\n     *\n     * @param sink 当前运算逻辑\n     * @param type 运算结果\n     * @return 新增链表节点并返回\n     */\n    private PipeLine<T> add(Sink<T> sink, Sink.Type type) {\n        PipeLine<T> pipeLine = new PipeLine<>(this.bool);\n        pipeLine.prev = this;\n        pipeLine.sink = sink;\n        return pipeLine;\n    }\n\n    public PipeLine<T> test(Predicate<T> predicate) {\n        assert predicate != null;\n        Sink<T> sink = new Sink<T>(bool, Sink.Type.TEST) {\n            @Override\n            public void valid() {\n                valid(Type.END, Type.AND, Type.OR);\n            }\n        };\n        sink.predicate = predicate;\n        return add(sink, Sink.Type.TEST);\n    }\n\n    /**\n     * 对于or来说，如果上一个运算逻辑为true，则整个表达式都为true，所以可以直接结束\n     * 否则可以直接忽略or操作前面的运算结果\n     */\n    public PipeLine<T> or() {\n        Sink<T> sink = new Sink<T>(bool, Sink.Type.OR) {\n            @Override\n            public boolean cancel(Bool bool) {\n                return bool.result;\n            }\n\n            @Override\n            public Sink<T> accept(T test) {\n                return this.next;\n            }\n\n            @Override\n            public void valid() {\n                valid(Type.TEST, Type.NOT);\n            }\n        };\n        return add(sink, Sink.Type.OR);\n    }\n\n    /**\n     * 返回下一个test的否定\n     */\n    public PipeLine<T> not() {\n        Sink<T> sink = new Sink<T>(bool, Sink.Type.NOT) {\n\n            @Override\n            public Sink<T> accept(T test) {\n                Sink<T> sink = this.next;\n                this.next = new Sink<T>(bool, Type.TEST) {\n                    @Override\n                    public Sink<T> accept(T test) {\n                        Sink<T> accept = sink.accept(test);\n                        this.bool.result = !this.bool.result;\n                        return accept;\n                    }\n                };\n                return this.next;\n            }\n\n            @Override\n            public void valid() {\n                valid(Type.TEST);\n            }\n        };\n        return add(sink, Sink.Type.NOT);\n    }\n\n    /**\n     * 对于or来说，如果上一个运算逻辑为false，则整个表达式都为false，所以可以直接结束\n     * 否则可以直接忽略or操作前面的运算结果\n     */\n    public PipeLine<T> and() {\n        Sink<T> sink = new Sink<T>(bool, Sink.Type.AND) {\n\n            @Override\n            public boolean cancel(Bool bool) {\n                return !bool.result;\n            }\n\n            @Override\n            public Sink<T> accept(T test) {\n                return this.next;\n            }\n\n            @Override\n            public void valid() {\n                valid(Type.TEST, Type.NOT);\n\n\n            }\n        };\n        return add(sink, Sink.Type.OR);\n    }\n\n    /**\n     * 向前查找PipeLine，同时将Sink链接起来\n     *\n     * @return 返回链表第一个节点，即BEGIN\n     */\n    public PipeLine<T> end() {\n        PipeLine<T> pipeLine = this;\n        Sink<T> temp = pipeLine.sink;\n        //最后一个操作执行一个一定会cancel的终结节点\n        temp.next = new Sink<T>(bool, Sink.Type.END) {\n            @Override\n            public boolean cancel(Bool result) {\n                return true;\n            }\n        };\n        PipeLine<T> pr = pipeLine.prev;\n        while (pr != null) {\n            pipeLine = pr;\n            pr = pipeLine.prev;\n            pipeLine.sink.next = temp;\n            temp = pipeLine.sink;\n        }\n        pr = null;\n        return pipeLine;\n    }\n\n    /**\n     * 依次执行Sink，直到触发cancel或者所有Sink执行完成,支持多次操作\n     *\n     * @param test 数据\n     * @return 逻辑运算结果\n     */\n    public boolean accept(T test) {\n        return forSink(sink, test);\n    }\n\n    private static class Bool {\n        boolean result = false;\n    }\n\n    private static class Sink<T> {\n        /**\n         * 标记操作的类型，主要用来校验表达式是否合法\n         */\n        public enum Type {\n            BEGIN,\n            TEST,\n            NOT,\n            OR,\n            END,\n            AND\n        }\n\n        protected Type type;\n\n        public Sink(Bool bool, Type type) {\n            this.bool = bool;\n            this.type = type;\n        }\n\n        Bool bool;\n        Predicate<T> predicate;\n        /**\n         * 使用链表的方式，将所有操作步骤串联起来\n         */\n        Sink<T> next;\n\n        /**\n         * 是否需要提前结束表达式\n         */\n        public boolean cancel(Bool result) {\n            return false;\n        }\n\n        /**\n         * @param test 断言\n         * @return 返回下一个操作\n         */\n        public Sink<T> accept(T test) {\n            this.bool.result = this.predicate.test(test);\n            return next;\n        }\n\n        /**\n         * 表达式是否合法，一般只需要考虑当前类型操作的下一个操作类型可以为\n         */\n        public void valid() {\n        }\n\n        void valid(Type... types) {\n            if (next == null) {\n                throw new IllegalStateException(\"must have end()\");\n            }\n            if (Arrays.stream(types).noneMatch(type -> next.type == type)) {\n                throw new IllegalStateException(type + \" --> \" + Arrays.toString(types) + \"; actual is : \" + next.type);\n            }\n        }\n\n    }\n\n    private boolean forSink(Sink<T> sink, T test) {\n        while (sink != null) {\n            sink.valid();\n            if (sink.cancel(bool)) {\n                break;\n            }\n            sink = sink.accept(test);\n        }\n        return bool.result;\n    }\n\n}\n```\n\n参考[Stream 流水线原理](https://www.jianshu.com/p/893fb6febc70)\n","categories":["java"],"tags":["源码","轮子"]},{"title":"Spring_Autowired源码分析","url":"/2019/11/14/Spring-Autowired%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","content":""},{"title":"spring_initMethod执行过程","url":"/2019/11/13/spring-initMethod%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/","content":"\n## 准备\n\n`pom`依赖，`jdk`版本为`1.8`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n<modelVersion>4.0.0</modelVersion>\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.2.1.RELEASE</version>\n    <relativePath/> <!-- lookup parent from repository -->\n</parent>\n<groupId>com.leaderli</groupId>\n<artifactId>demo</artifactId>\n<version>0.0.1-SNAPSHOT</version>\n<name>demo</name>\n<description>Demo project for Spring Boot</description>\n\n<properties>\n    <java.version>1.8</java.version>\n</properties>\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n        <exclusions>\n            <exclusion>\n                <groupId>org.junit.vintage</groupId>\n                <artifactId>junit-vintage-engine</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n</dependencies>\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n\n</project>\n\n```\n\n为了方便分析`Spring`中`bean`的生命周期，我们使用`@Lazy`来注解`bean`\n\n```java\n@Component\npublic class BeAutowired {\n    static {\n        System.out.println(\"-------BeAutowired--------\");\n    }\n}\n\n@Component\n@Lazy\npublic class Person {\n    @Autowired\n    BeAutowired beAutowired;\n    @PostConstruct\n    public void begin(){\n        System.out.println(\" beAutowired= \" + beAutowired);\n    }\n}\n```\n\n我们使用测试程序来分析`person`的加载过程\n\n```java\npublic static void main(String[] args) {\n    String packageName = Person.class.getPackage().getName();\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(packageName);\n    Person person = context.getBean(Person.class);\n    System.out.println(\"person = \" + person);\n}\n```\n\n## 分析\n\n### `doGetBean`\n\n因为使用了`@Lazy`,所以`Person`在执行`context.getBean(Person.class)`时才加载，我们`debug`进去大致了解一下关键的加载过程\n\n```java\n//交由BeanFactory去加载\n@Override\npublic <T> T getBean(Class<T> requiredType) throws BeansException {\n    assertBeanFactoryActive();\n    return getBeanFactory().getBean(requiredType);\n}\n```\n\n省略中间过程，最终会调用`BeanFactory`的`doGetBean`方法\n\n```java\npublic <T> T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)\n        throws BeansException {\n\n    return doGetBean(name, requiredType, args, false);\n}\n```\n\n`doGetBean`大致流程如下：\n\n1. \b 如果是单例模式的，则尝试从缓存中获取`bean`\n2. 尝试从父类`BeanFactory`中加载`bean`\n3. 加载依赖`bean`， `@DependsOn`注解的`bean`\n4. 使用方法`createBean(beanName, mbd, args)`,加载单例 bean\n\n`doGetBean`源码，无视其他代码，只关心我们需要了解的\n\n```java\nprotected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,\n        @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {\n\n    final String beanName = transformedBeanName(name);\n    Object bean;\n\n    // 1. \b如果是单例模式的，则尝试从缓存中获取bean\n    Object sharedInstance = getSingleton(beanName);\n    if (sharedInstance != null && args == null) {\n        if (logger.isTraceEnabled()) {\n            if (isSingletonCurrentlyInCreation(beanName)) {\n                logger.trace(\"Returning eagerly cached instance of singleton bean '\" + beanName +\n                        \"' that is not fully initialized yet - a consequence of a circular reference\");\n            }\n            else {\n                logger.trace(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n            }\n        }\n        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n    }\n\n    else {\n        // Fail if we're already creating this bean instance:\n        // We're assumably within a circular reference.\n        if (isPrototypeCurrentlyInCreation(beanName)) {\n            throw new BeanCurrentlyInCreationException(beanName);\n        }\n\n        // 2. 尝试从父类BeanFactory中加载bean\n        BeanFactory parentBeanFactory = getParentBeanFactory();\n        if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n            // Not found -> check parent.\n            String nameToLookup = originalBeanName(name);\n            if (parentBeanFactory instanceof AbstractBeanFactory) {\n                return ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n                        nameToLookup, requiredType, args, typeCheckOnly);\n            }\n            else if (args != null) {\n                // Delegation to parent with explicit args.\n                return (T) parentBeanFactory.getBean(nameToLookup, args);\n            }\n            else if (requiredType != null) {\n                // No args -> delegate to standard getBean method.\n                return parentBeanFactory.getBean(nameToLookup, requiredType);\n            }\n            else {\n                return (T) parentBeanFactory.getBean(nameToLookup);\n            }\n        }\n\n        if (!typeCheckOnly) {\n            markBeanAsCreated(beanName);\n        }\n\n        try {\n            final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n            checkMergedBeanDefinition(mbd, beanName, args);\n\n            // 3. 加载依赖bean， @DependsOn注解的bean\n            String[] dependsOn = mbd.getDependsOn();\n            if (dependsOn != null) {\n                for (String dep : dependsOn) {\n                    if (isDependent(beanName, dep)) {\n                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                                \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\");\n                    }\n                    registerDependentBean(dep, beanName);\n                    try {\n                        getBean(dep);\n                    }\n                    catch (NoSuchBeanDefinitionException ex) {\n                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                                \"'\" + beanName + \"' depends on missing bean '\" + dep + \"'\", ex);\n                    }\n                }\n            }\n\n            // 4. 加载单例bean\n            if (mbd.isSingleton()) {\n                sharedInstance = getSingleton(beanName, () -> {\n                    try {\n                        return createBean(beanName, mbd, args);\n                    }\n                    catch (BeansException ex) {\n                        // Explicitly remove instance from singleton cache: It might have been put there\n                        // eagerly by the creation process, to allow for circular reference resolution.\n                        // Also remove any beans that received a temporary reference to the bean.\n                        destroySingleton(beanName);\n                        throw ex;\n                    }\n                });\n                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n            }\n\n            else if (mbd.isPrototype()) {\n                // It's a prototype -> create a new instance.\n                Object prototypeInstance = null;\n                try {\n                    beforePrototypeCreation(beanName);\n                    prototypeInstance = createBean(beanName, mbd, args);\n                }\n                finally {\n                    afterPrototypeCreation(beanName);\n                }\n                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n            }\n\n            else {\n                String scopeName = mbd.getScope();\n                final Scope scope = this.scopes.get(scopeName);\n                if (scope == null) {\n                    throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");\n                }\n                try {\n                    Object scopedInstance = scope.get(beanName, () -> {\n                        beforePrototypeCreation(beanName);\n                        try {\n                            return createBean(beanName, mbd, args);\n                        }\n                        finally {\n                            afterPrototypeCreation(beanName);\n                        }\n                    });\n                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n                }\n                catch (IllegalStateException ex) {\n                    throw new BeanCreationException(beanName,\n                            \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" +\n                            \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\",\n                            ex);\n                }\n            }\n        }\n        catch (BeansException ex) {\n            cleanupAfterBeanCreationFailure(beanName);\n            throw ex;\n        }\n    }\n\n    // Check if required type matches the type of the actual bean instance.\n    if (requiredType != null && !requiredType.isInstance(bean)) {\n        try {\n            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\n            if (convertedBean == null) {\n                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n            }\n            return convertedBean;\n        }\n        catch (TypeMismatchException ex) {\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"Failed to convert bean '\" + name + \"' to required type '\" +\n                        ClassUtils.getQualifiedName(requiredType) + \"'\", ex);\n            }\n            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n        }\n    }\n    return (T) bean;\n}\n```\n\n### `createBean`\n\n`createBean`大致流程如下：\n\n1. _`createBeanInstance`_,使用构造器或者工厂方法实例化`bean`\n2. _`populateBean`_,对`bean`进行数据的初始化操作，比如加载`@autowire`的`bean`，`@value`的属性赋值，`@PostConstruct`方法执行等\n3. _`initializeBean`_,执行`BeanDefinition`中定义的`initMethod`，一般在`xml` 配置中(`<bean class=\"Person\" init-method=\"initMethod\"/>`)，或者`@Bean(initMethod = \"initMethod\")`中定义的方法名\n\n`createBean`源码，无视其他代码，只关心我们需要了解的\n\n```java\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n        throws BeanCreationException {\n\n    // 1. 使用构造器实例化`bean`\n    BeanWrapper instanceWrapper = null;\n    if (mbd.isSingleton()) {\n        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n    }\n    if (instanceWrapper == null) {\n        instanceWrapper = createBeanInstance(beanName, mbd, args);\n    }\n    final Object bean = instanceWrapper.getWrappedInstance();\n    Class<?> beanType = instanceWrapper.getWrappedClass();\n    if (beanType != NullBean.class) {\n        mbd.resolvedTargetType = beanType;\n    }\n\n    // Allow post-processors to modify the merged bean definition.\n    synchronized (mbd.postProcessingLock) {\n        if (!mbd.postProcessed) {\n            try {\n                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n            }\n            catch (Throwable ex) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"Post-processing of merged bean definition failed\", ex);\n            }\n            mbd.postProcessed = true;\n        }\n    }\n\n    //这里主要解决循环依赖的问题，这里不做深入讨论\n    boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n            isSingletonCurrentlyInCreation(beanName));\n    if (earlySingletonExposure) {\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Eagerly caching bean '\" + beanName +\n                    \"' to allow for resolving potential circular references\");\n        }\n        addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n    }\n\n    // Initialize the bean instance.\n    Object exposedObject = bean;\n    try {\n        //2. 对bean进行数据的初始化操作，比如加载@autowire的bean，@value的属性赋值，@PostConstruct方法执行等\n        populateBean(beanName, mbd, instanceWrapper);\n        //3. 执行BeanDefinition中定义的initMethod，一般在xml配置中，或者@Bean(initMethod = \"initMethod\")中定义的方法名\n        exposedObject = initializeBean(beanName, exposedObject, mbd);\n    }\n    catch (Throwable ex) {\n        if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {\n            throw (BeanCreationException) ex;\n        }\n        else {\n            throw new BeanCreationException(\n                    mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex);\n        }\n    }\n\n    if (earlySingletonExposure) {\n        Object earlySingletonReference = getSingleton(beanName, false);\n        if (earlySingletonReference != null) {\n            if (exposedObject == bean) {\n                exposedObject = earlySingletonReference;\n            }\n            else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n                String[] dependentBeans = getDependentBeans(beanName);\n                Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);\n                for (String dependentBean : dependentBeans) {\n                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n                        actualDependentBeans.add(dependentBean);\n                    }\n                }\n                if (!actualDependentBeans.isEmpty()) {\n                    throw new BeanCurrentlyInCreationException(beanName,\n                            \"Bean with name '\" + beanName + \"' has been injected into other beans [\" +\n                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n                            \"] in its raw version as part of a circular reference, but has eventually been \" +\n                            \"wrapped. This means that said other beans do not use the final version of the \" +\n                            \"bean. This is often the result of over-eager type matching - consider using \" +\n                            \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\");\n                }\n            }\n        }\n    }\n\n    // Register bean as disposable.\n    try {\n        registerDisposableBeanIfNecessary(beanName, bean, mbd);\n    }\n    catch (BeanDefinitionValidationException ex) {\n        throw new BeanCreationException(\n                mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n    }\n\n    return exposedObject;\n}\n```\n\n### `populateBean`\n\n这里我们简单介绍一下`@Autowired`是何时被加载的。我们通过打断点，并设置`evaluate`语句，在断点处输出日志的方式查看  \n![spring-initMethod执行过程_2019-11-14-01-27-39.png](./images/spring-initMethod执行过程_2019-11-14-01-27-39.png)\n\n断点调试最后输出的日志如下  \n![spring-initMethod执行过程_2019-11-14-01-29-22.png](./images/spring-initMethod执行过程_2019-11-14-01-29-22.png)\n我们可以得知被`@Autowired`的属性或方法是否处理器`AutowiredAnnotationBeanPostProcessor`去实现的，具体加载过程参考 {% post_link Spring_Autowired源码分析 %}\n\n```java\nprotected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {\n    if (bw == null) {\n        if (mbd.hasPropertyValues()) {\n            throw new BeanCreationException(\n                    mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n        }\n        else {\n            // Skip property population phase for null instance.\n            return;\n        }\n    }\n\n    // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the\n    // state of the bean before properties are set. This can be used, for example,\n    // to support styles of field injection.\n    boolean continueWithPropertyPopulation = true;\n\n    if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n        for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n                    continueWithPropertyPopulation = false;\n                    break;\n                }\n            }\n        }\n    }\n\n    if (!continueWithPropertyPopulation) {\n        return;\n    }\n\n    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);\n\n    int resolvedAutowireMode = mbd.getResolvedAutowireMode();\n    if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n        // Add property values based on autowire by name if applicable.\n        if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {\n            autowireByName(beanName, mbd, bw, newPvs);\n        }\n        // Add property values based on autowire by type if applicable.\n        if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n            autowireByType(beanName, mbd, bw, newPvs);\n        }\n        pvs = newPvs;\n    }\n\n    boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n    boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n    PropertyDescriptor[] filteredPds = null;\n    if (hasInstAwareBpps) {\n        if (pvs == null) {\n            pvs = mbd.getPropertyValues();\n        }\n        //对满足条件的BeanPostProcessor，执行postProcessProperties方法，对bean的属性进行赋值操作\n        for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);\n                if (pvsToUse == null) {\n                    if (filteredPds == null) {\n                        filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n                    }\n                    pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n                    if (pvsToUse == null) {\n                        return;\n                    }\n                }\n                pvs = pvsToUse;\n            }\n        }\n    }\n    if (needsDepCheck) {\n        if (filteredPds == null) {\n            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n        }\n        checkDependencies(beanName, mbd, filteredPds, pvs);\n    }\n\n    if (pvs != null) {\n        applyPropertyValues(beanName, mbd, bw, pvs);\n    }\n}\n```\n\n### `initializeBean`\n\n`initializeBean`大致执行步骤如下：\n\n1. 若接口实现了`Aware`，则执行对应的方法\n2. 执行所有`BeanPostProcessor`的`postProcessBeforeInitialization`方法\n3. 执行`BeanDefinition`中定义的`init-method`\n4. 执行所有`BeanPostProcessor`的`postProcessAfterInitialization`方法\n\n```java\nprotected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {\n    if (System.getSecurityManager() != null) {\n        AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n            invokeAwareMethods(beanName, bean);\n            return null;\n        }, getAccessControlContext());\n    }\n    else {\n        //1. 若接口实现了`Aware`，则执行对应的方法\n        invokeAwareMethods(beanName, bean);\n    }\n\n    Object wrappedBean = bean;\n    if (mbd == null || !mbd.isSynthetic()) {\n        2. 执行所有`BeanPostProcessor`的`postProcessBeforeInitialization`方法\n        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n    }\n\n    try {\n        3. 执行`BeanDefinition`中定义的`init-method`\n        invokeInitMethods(beanName, wrappedBean, mbd);\n    }\n    catch (Throwable ex) {\n        throw new BeanCreationException(\n                (mbd != null ? mbd.getResourceDescription() : null),\n                beanName, \"Invocation of init method failed\", ex);\n    }\n    if (mbd == null || !mbd.isSynthetic()) {\n        4. 执行所有`BeanPostProcessor`的`postProcessAfterInitialization`方法\n        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n    }\n\n    return wrappedBean;\n}\n```\n\n我们对上述`initializeBean`的第三步骤不做过多介绍，其大致执行过程为在初始化`BeanDefinition`时，将`initMethod`的值通过下述方法加载\n\n```java\nvoid setInitMethodName(@Nullable String initMethodName);\n```\n\n然后`initializeBean`通过`invokeInitMethods`来执行`initMethod`\n\n#### applyBeanPostProcessorsBeforeInitialization\n\n我们同样通过断点调试的方式来观察，`@PostConstruct`方法是何时被执行的  \n![spring-initMethod执行过程_2019-11-14-01-45-47.png](./images/spring-initMethod执行过程_2019-11-14-01-45-47.png)\n我们可以得知是在`CommonAnnotationBeanPostProcessor`中被处理的\n\n我们查看其源码\n\n```java\n@Override\npublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n    //查找是否有@PostConstruct注解的方法\n    LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());\n    try {\n        //执行所有被注解了@PostConstruct的方法\n        metadata.invokeInitMethods(bean, beanName);\n    }\n    catch (InvocationTargetException ex) {\n        throw new BeanCreationException(beanName, \"Invocation of init method failed\", ex.getTargetException());\n    }\n    catch (Throwable ex) {\n        throw new BeanCreationException(beanName, \"Failed to invoke init method\", ex);\n    }\n    return bean;\n}\n```\n\n查看`findLifecycleMetadata`-->`buildLifecycleMetadata`细节  \n我们只需要了解`this.initAnnotationType`, `this.destroyAnnotationType`的赋值情况即可\n\n```java\nprivate LifecycleMetadata buildLifecycleMetadata(final Class<?> clazz) {\n    //是否有指定注解的方法存在\n    if (!AnnotationUtils.isCandidateClass(clazz, Arrays.asList(this.initAnnotationType, this.destroyAnnotationType))) {\n        return this.emptyLifecycleMetadata;\n    }\n\n    List<LifecycleElement> initMethods = new ArrayList<>();\n    List<LifecycleElement> destroyMethods = new ArrayList<>();\n    Class<?> targetClass = clazz;\n\n    do {\n        final List<LifecycleElement> currInitMethods = new ArrayList<>();\n        final List<LifecycleElement> currDestroyMethods = new ArrayList<>();\n\n        ReflectionUtils.doWithLocalMethods(targetClass, method -> {\n            if (this.initAnnotationType != null && method.isAnnotationPresent(this.initAnnotationType)) {\n                LifecycleElement element = new LifecycleElement(method);\n                currInitMethods.add(element);\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Found init method on class [\" + clazz.getName() + \"]: \" + method);\n                }\n            }\n            if (this.destroyAnnotationType != null && method.isAnnotationPresent(this.destroyAnnotationType)) {\n                currDestroyMethods.add(new LifecycleElement(method));\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"Found destroy method on class [\" + clazz.getName() + \"]: \" + method);\n                }\n            }\n        });\n        //将扫描到的init,destroy方法放入LifecycleMetadata\n        initMethods.addAll(0, currInitMethods);\n        destroyMethods.addAll(currDestroyMethods);\n        targetClass = targetClass.getSuperclass();\n    }\n    while (targetClass != null && targetClass != Object.class);\n\n    return (initMethods.isEmpty() && destroyMethods.isEmpty() ? this.emptyLifecycleMetadata :\n            new LifecycleMetadata(clazz, initMethods, destroyMethods));\n}\n\n```\n\n我们通过查看`CommonAnnotationBeanPostProcessor`的构造器发现了`@PostConstruct`的赋值过程。\n\n```java\npublic CommonAnnotationBeanPostProcessor() {\n    setOrder(Ordered.LOWEST_PRECEDENCE - 3);\n    setInitAnnotationType(PostConstruct.class);\n    setDestroyAnnotationType(PreDestroy.class);\n    ignoreResourceType(\"javax.xml.ws.WebServiceContext\");\n}\n```\n","categories":["spring"],"tags":["源码分析","Spring加载过程"]},{"title":"java面试题_1","url":"/2019/11/12/java%E9%9D%A2%E8%AF%95%E9%A2%98-1/","content":"\n### `HashMap`,`HashTable`,`CocurrentHashMap`的共同点和区别\n\n共同点：\n\n1. 底层使用拉链式数组\n2. 为了避免`hash`冲突，当当数组元素已用槽数量超过(容量\\*容载因子)就会扩容\n3. `\bput`时，对`key`进行`hash`计算槽，若槽没有元素则赋值，否则插入链表的结尾\n4. `get`时，对`key`进行`hash`计算槽，若槽没有元素或者仅有一个元素，则直接返回，\n   否则，通过`equals`方法比较`key`，返回指定的元素\n\n不同点：\n\n1. `HashTable`的`key`和`value`不允许`null`\n2. `hash`方法不同，`HashTable`直接对`hashcode`进行取模运算，`HashMap`首先对`hashcode`进行扰动计算，尽量避免 hash 碰撞。然后因其数组长度恒定为$2^n$,所以直接通过与运算进行取模，\n3. `HashMap`线程不安全，`HashTable`通过`synchronized`修改关键方法确保线程安全，`CoccurentHashMap`通过分段锁的方式实现\n\n### 说出几种幂等的实现方式\n\n幂等操作指任意多次执行的结果和执行一次的结果一样。通俗来说，就是同一用户的对同一操作的多次请求的结果是一致的。\n\n保证幂等性主要是三点：\n\n1. 对于同一操作的请求必须有唯一标识，例如订单支付系统，肯定包含订单`ID`，确保一个订单仅支付一次。\n2. 处理请求时需要有标识记录操作的状态，如正在处理中，已经处理完成等。\n3. 每次接受请求时，需要判断是否已经处理过该请求或者正在处理该请求。\n\n实现方式：\n\n1. 分布式锁\n2. 数据库锁\n3. 事务\n\n### `Spring`的`init-method`，`destroy-metdho`的实现方式\n\n根据{% post_link spring-initMethod执行过程 %}的分析，我们可以知道`Spring`在扫描`bean`的配置信息时，将\n`init-method`，`destroy-metdhod`的信息存储在`BeanDefinition`中，在`bean`的生命周期的一开始即实例化`bean`，以及对`bean`的属性进行初始化赋值后，会查找当前`BeanDefinition`,是否有`init-method`方法，有则通过反射去执行。在`bean`的生命周期的最后，会查找当前`BeanDefinition`,是否有`destroy-metdhod`方法，有则通过反射去执行。\n","categories":["面试题"],"tags":["java","面试题"]},{"title":"java数组","url":"/2019/11/12/java%E6%95%B0%E7%BB%84/","content":"\n## java 在堆中的内存分为三个部分\n\n1. 对象头 `Object header`\n2. 值 `value`\n3. 对齐 `padding`(不一定存在，java 内存需要对齐 8byte，不足部分填充)\n\n### java 对象头\n\n```java\n|--------------------------------------------------------------|\n|                     Object Header (64 bits)                  |\n|------------------------------------|-------------------------|\n|        Mark Word (32 bits)         |    Klass Word (32 bits) |\n|------------------------------------|-------------------------|\n```\n\njava 数组头\n\n```java\n|---------------------------------------------------------------------------------|\n|                                 Object Header (96 bits)                         |\n|--------------------------------|-----------------------|------------------------|\n|        Mark Word(32bits)       |    Klass Word(32bits) |  array length(32bits)  |\n|--------------------------------|-----------------------|------------------------|\n```\n\n其中`Mark Word`\n\n```java\n|-------------------------------------------------------|--------------------|\n|                  Mark Word (32 bits)                  |       State        |\n|-------------------------------------------------------|--------------------|\n| identity_hashcode:25 | age:4 | biased_lock:1 | lock:2 |       Normal       |\n|-------------------------------------------------------|--------------------|\n|  thread:23 | epoch:2 | age:4 | biased_lock:1 | lock:2 |       Biased       |\n|-------------------------------------------------------|--------------------|\n|               ptr_to_lock_record:30          | lock:2 | Lightweight Locked |\n|-------------------------------------------------------|--------------------|\n|               ptr_to_heavyweight_monitor:30  | lock:2 | Heavyweight Locked |\n|-------------------------------------------------------|--------------------|\n|                                              | lock:2 |    Marked for GC   |\n|-------------------------------------------------------|--------------------|\n```\n\n```java\n|------------------------------------------------------------------------------|--------------------|\n|                                  Mark Word (64 bits)                         |       State        |\n|------------------------------------------------------------------------------|--------------------|\n| unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 |       Normal       |\n|------------------------------------------------------------------------------|--------------------|\n| thread:54 |       epoch:2        | unused:1 | age:4 | biased_lock:1 | lock:2 |       Biased       |\n|------------------------------------------------------------------------------|--------------------|\n|                       ptr_to_lock_record:62                         | lock:2 | Lightweight Locked |\n|------------------------------------------------------------------------------|--------------------|\n|                     ptr_to_heavyweight_monitor:62                   | lock:2 | Heavyweight Locked |\n|------------------------------------------------------------------------------|--------------------|\n|                                                                     | lock:2 |    Marked for GC   |\n|------------------------------------------------------------------------------|--------------------|\n```\n\nlock:2 位的锁状态标记位，由于希望用尽可能少的二进制位表示尽可能多的信息，所以设置了 lock 标记。该标记的值不同，整个 mark word 表示的含义不同。\n\n| biased_lock | Tlock |     状态 |\n| :---------- | :---: | -------: |\n| 0           |  01   |     无锁 |\n| 1           |  01   |   偏向锁 |\n| 0           |  00   | 轻量级锁 |\n| 0           |  10   | 重量级锁 |\n| 0           |  11   |  GC 标记 |\n\n1. biased_lock`：对象是否启用偏向锁标记，只占 1 个二进制位。为 1 时表示对象启用偏向锁，为 0 时表示对象没有偏向锁。\n\n2. `age`：4 位的 `Java` 对象年龄。在 `GC` 中，如果对象在 `Survivor` 区复制一次，年龄增加 1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行 `GC` 的年龄阈值为 15，并发 `GC` 的年龄阈值为 6。由于 `age` 只有 4 位，所以最大值为 15，这就是`-XX:MaxTenuringThreshold` 选项最大值为 15 的原因。\n\n3. `identity_hashcode`：25 位的对象标识 `Hash` 码，采用延迟加载技术。调用方法 `System.identityHashCode()`计算，并会将结果写到该对象头中。当对象被锁定时，该值会移动到管程 `Monitor` 中。\n\n4. `thread`：持有偏向锁的线程 `ID`。\n\n5. `epoch`：偏向时间戳。\n\n6. `ptr_to_lock_record`：指向栈中锁记录的指针。\n\n7. `ptr_to_heavyweight_monitor`：指向管程 `Monitor` 的指针。\n\n### class pointer\n\n这一部分用于存储对象的类型指针，该指针指向它的类元数据，`JVM` 通过这个指针确定对象是哪个类的实例。该指针的位长度为 `JVM` 的一个字大小，即 32 位的 `JVM` 为 32 位，64 位的 `JVM` 为 64 位。\n\n### array length\n\n如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，这部分数据的长度也随着 `JVM` 架构的不同而不同：32 位的 `JVM` 上，长度为 32 位；64 位 `JVM` 则为 64 位。64 位 `JVM` 如果开启`+UseCompressedOops` 选项，该区域长度也将由 64 位压缩至 32 位。\n\n## 数组下标寻址\n\n1. 首先根据栈上的指针找到该数组对象在内存中的位置`p`\n\n2. 判断`index`是否越界，即与数组对象头中存储的`array length`做比较\n\n3. 根据数组对象头的`class pointer`确定数组元素的内存占用长度`n`\n\n4. 根据数组对象头长度`base`和下标计算出访问的元素的内存位置，即`p+base+n*index`\n","categories":["java"],"tags":["jvm"]},{"title":"bitOperation","url":"/2019/10/19/bitOperation/","content":"\n在 Java 中，位运算符有很多，例如与`&`、非`~`、或`|`、异或`^`、移位`<<`和`>>`等。这些运算符在日常编码中很少会用到。\n\n在下面的一个例子中，会用到位掩码`BitMask`，其中包含大量的位运算。不只是在`Java`中，其他编写语言中也是可以使用的。\n\n例如，在一个系统中，用户一般有查询`Select`、新增`Insert`、修改`Update`、删除`Delete`四种权限，四种权限有多种组合方式，也就是有`16`中不同的权限状态（2 的 4 次方）。\n\n## `Permission`\n\n一般情况下会想到用四个`boolean`类型变量来保存：\n\n```java\npublic class Permission {\n    // 是否允许查询\n    private boolean allowSelect;\n    // 是否允许新增\n    private boolean allowInsert;\n    // 是否允许删除\n    private boolean allowDelete;\n    // 是否允许更新\n    private boolean allowUpdate;\n}\n```\n\n上面用四个 boolean 类型变量来保存每种权限状态。\n\n## `NewPermission`\n\n下面是另外一种方式，使用位掩码的话，用一个二进制数即可，每一位来表示一种权限，`0`表示无权限，`1`表示有权限。\n\n```java\npublic class NewPermission {\n    // 是否允许查询，二进制第1位，0表示否，1表示是\n    public static final int ALLOW_SELECT = 1 << 0; // 0001\n    // 是否允许新增，二进制第2位，0表示否，1表示是\n    public static final int ALLOW_INSERT = 1 << 1; // 0010\n    // 是否允许修改，二进制第3位，0表示否，1表示是\n    public static final int ALLOW_UPDATE = 1 << 2; // 0100\n    // 是否允许删除，二进制第4位，0表示否，1表示是\n    public static final int ALLOW_DELETE = 1 << 3; // 1000\n    // 存储目前的权限状态\n    private int flag；\n    /**\n        *  重新设置权限\n        */\n    public void setPermission(int permission) {\n        flag = permission;\n    }\n    /**\n        *  添加一项或多项权限\n        */\n    public void enable(int permission) {\n        flag |= permission;\n    }\n    /**\n        *  删除一项或多项权限\n        */\n    public void disable(int permission) {\n        flag &= ~permission;\n    }\n    /**\n        *  是否拥某些权限\n        */\n    public boolean isAllow(int permission) {\n        return (flag & permission) == permission;\n    }\n    /**\n        *  是否禁用了某些权限\n        */\n    public boolean isNotAllow(int permission) {\n        return (flag & permission) == 0;\n    }\n    /**\n        *  是否仅仅拥有某些权限\n        */\n    public boolean isOnlyAllow(int permission) {\n        return flag == permission;\n    }\n}\n\n```\n\n以上代码中，用四个常量表示了每个二进制位代码的权限项。\n\n例如：\n\n`ALLOW_SELECT = 1 << 0` 转成二进制就是`0001`，二进制第一位表示`Select`权限。\n`ALLOW_INSERT = 1 << 1` 转成二进制就是`0010`，二进制第二位表示`Insert`权限。\n\n`private int flag`存储了各种权限的启用和停用状态，相当于代替了`Permission`中的四个`boolean`类型的变量。\n\n用`flag`的四个二进制位来表示四种权限的状态，每一位的 0 和 1 代表一项权限的启用和停用，下面列举了部分状态表示的权限：\n\n| flag     | 删除 | 修改 | 新增 | 查询 |                                   |\n| -------- | ---- | ---- | ---- | ---- | --------------------------------- |\n| 1(0001)  | 0    | 0    | 0    | 1    | 只允许查询（即等于 ALLOW_SELECT） |\n| 2(0010)  | 0    | 0    | 1    | 0    | 只允许新增（即等于 ALLOW_INSERT） |\n| 4(0100)  | 0    | 1    | 0    | 0    | 只允许修改（即等于 ALLOW_UPDATE） |\n| 8(1000)  | 1    | 0    | 0    | 0    | 只允许删除（即等于 ALLOW_DELETE） |\n| 3(0011)  | 0    | 0    | 1    | 1    | 只允许查询和新增                  |\n| 0        | 0    | 0    | 0    | 0    | 四项权限都不允许                  |\n| 15(1111) | 1    | 1    | 1    | 1    | 四项权限都允许                    |\n\n使用位掩码的方式，只需要用一个大于或等于`0`且小于`16`的整数即可表示所有的 16 种权限的状态。\n\n此外，还有很多设置权限和判断权限的方法，需要用到位运算，例如：\n\n```java\npublic void enable(int permission) {\n    flag |= permission; // 相当于flag = flag | permission;\n}\n```\n\n调用这个方法可以在现有的权限基础上添加一项或多项权限。\n\n添加一项`Update`权限：\n\n```java\npermission.enable(NewPermission.ALLOW_UPDATE);\n```\n\n假设现有权限只有`Select`，也就是`flag`是`0001`。执行以上代码，`flag = 0001 | 0100`，也就是`0101`，便拥有了`Select`和`Update`两项权限。\n\n添加`Insert`、`Update`、`Delete`三项权限：\n\n```java\npermission.enable(NewPermission.ALLOW_INSERT\n    | NewPermission.ALLOW_UPDATE | NewPermission.ALLOW_DELETE);\n\n```\n\n`NewPermission.ALLOW_INSERT | NewPermission.ALLOW_UPDATE | NewPermission.ALLOW_DELETE`运算结果是`1110`。假设现有权限只有`Select`，也就是`flag`是`0001`。`flag = 0001 | 1110，也就是1111`，便拥有了这四项权限，相当于添加了三项权限。\n\n上面的设置如果使用最初的`Permission`类的话，就需要下面三行代码：\n\n```java\npermission.setAllowInsert(true);\npermission.setAllowUpdate(true);\npermission.setAllowDelete(true);\n```\n\n## 二者对比\n\n### 设置仅允许 Select 和 Insert 权限\n\nPermission\n\n```java\npermission.setAllowSelect(true);\npermission.setAllowInsert(true);\npermission.setAllowUpdate(false);\npermission.setAllowDelete(false);\n```\n\nNewPermission\n\n```java\npermission.setPermission(NewPermission.ALLOW_SELECT | NewPermission.ALLOW_INSERT);\n```\n\n### 判断是否允许 Select 和 Insert、Update 权限\n\n`Permission`\n\n```java\nif (permission.isAllowSelect() && permission.isAllowInsert() && permission.isAllowUpdate())\n```\n\n`NewPermission`\n\n```java\nif (permission. isAllow (NewPermission.ALLOW_SELECT\n    | NewPermission.ALLOW_INSERT | NewPermission.ALLOW_UPDATE))\n```\n\n### 判断是只否允许 Select 和 Insert 权限\n\n`Permission`\n\n```java\nif (permission.isAllowSelect() && permission.isAllowInsert()\n    && !permission.isAllowUpdate() && !permission.isAllowDelete())\n```\n\n`NewPermission`\n\n```java\nif (permission. isOnlyAllow (NewPermission.ALLOW_SELECT | NewPermission.ALLOW_INSERT))\n```\n\n二者对比可以感受到`MyPermission`位掩码方式相对于`Permission`的优势，可以节省很多代码量，位运算是底层运算，效率也非常高，而且理解起来也很简单。\n","categories":["java"],"tags":["bit"]},{"title":"genericsAndReflect","url":"/2019/10/19/genericsAndReflect/","content":"\n## `void`类型的范型方法\n\n```java\nprivate <T> void set(T t) {\n  System.out.println(t);\n}\n```\n\n## `java`运行时无法捕获`ClassCastException`的解决办法\n\n```java\n private static <T> T get(Object o, T def) {\n   try {\n     return (T) def.getClass().cast(o);\n   } catch (Throwable e) {\n     return (T) def;\n   }\n }\n```\n\n通过查看字节码就可以了解,直接 `return (T) value` 是在方法外检测`cast`\n\n## 可变参数方法的反射\n\n```java\npublic static void me(Object ... objects){\n    for (Object object : objects) {\n        System.out.println(object);\n    }\n}\n@Test\npublic void  test() throws Exception {\n    Class clazz = this.getClass();\n    //Method method = clazz.getMethod(\"me\",(new Object[0]).getClass());\n    //Method method = clazz.getMethod(\"me\",Array.newInstance(Object.class,0).getClass());\n    Method method = clazz.getMethod(\"me\",Class.forName(\"[Ljava.lang.Object;\"));\n    //1\n    Object objs = Array.newInstance(object.class,2);\n    Array.set(objs,0,1);\n    Array.set(objs,1,\"test\");\n    method.invoke(clazz,objs);\n    //2\n    Object[] obj = {1,\"test\"}\n    method.invoke(clazz,new Object[]{obj});\n}\n```\n\n可变参数不可直接显式使用 null 作为参数\n\n```java\npublic class TestStatic {\n    public static void main(String[] args) {\n        String s = null;\n        m1(s);\n        Util.log(\"begin null\");\n        m1(null);\n    }\n\n    private static void m1(String... strs) {\n        System.out.println(strs.length);\n    }\n\n}\n```\n\n```java\n0: aconst_null          //将null压入操作栈\n1: astore_1             //弹出栈顶(null)存储到本地变量1\n2: iconst_1             //压栈1此时已经到方法m1了，在初始化参数，此值作为数组长度\n3: anewarray     #2     //新建数组            // class java/lang/String\n6: dup                  //复制数组指针引用\n7: iconst_0             //压栈0，作为数组0角标\n8: aload_1              //取本地变量1值压栈，作为数组0的值\n9: aastore              //根据栈顶的引用型数值（value）、数组下标（index）、数组引用（arrayref）出栈，将数值存入对应的数组元素中\n10: invokestatic  #3    //此时实际传递的是一个数组，只是0位置为null的元素 Method m1:([Ljava/lang/String;)V\n13: iconst_1\n14: anewarray     #4    //class java/lang/Object\n17: dup\n18: iconst_0\n19: ldc           #5    //String begin null\n1: aastore\n22: invokestatic  #6    //Method li/Util.log:([Ljava/lang/Object;)V\n25: aconst_null         //此处并没有新建数组操作，直接压栈null\n26: invokestatic  #3    //此处一定会抛出空指针  Method m1:([Ljava/lang/String;)V\n29: return\n```\n\n## 泛型 `extends super`\n\n```java\n//不管是extends或是super，只能使用在变量声明上，实际赋值的时候，一定是指定具体实现类的。\n\n//那么对于<? extends T>来说，具体的实现类的泛型A只是变量声明的泛型T的子类，如果以T进行插入时，是无法保证插入的class类型，一定是A，所以extends禁用插入动作\nList<Apple> apples = new ArrayList<Apple>();\nList<? extends Fruit> fruits = apples;\n// 对于<? super T>来说，具体的实现类的泛型A一定是变量声明的泛型T的父类，如果以T类型进入取值操作，无法保证取出的值一定是T类型，因为A一定是T的父类，所以插入的所有实例一定也是A的多态\n\nList<Fruit> fruits = new ArrayList<Fruit>();\nList<? super Apple> = fruits;\n```\n\n## 如何修改 final 修饰符的值\n\n```java\nString str = \"fuck\";\n\nField value = String.class.getDeclaredField(\"value\");\n//Field中包含当前属性的修饰符，通过改变修饰符的final属性，达到重新赋值的功能\nField modifier = Field.class.getDeclaredField(\"modifiers\");\nmodifier.setAccessible(true);\nmodifier.set(value, value.getModifiers() & ~Modifier.FINAL);\n\nvalue.setAccessible(true);\nvalue.set(str, \"notfuck\".toCharArray());\n//修改成功后重新加上final修饰符\nmodifier.set(value, value.getModifiers() | Modifier.FINAL);}\n```\n","categories":["java"],"tags":["反射","泛型"]},{"title":"annotation","url":"/2019/10/19/annotation/","content":"\n## 注解的原理\n\n注解本质是一个继承了`Annotation`的特殊接口，其具体实现类是`Java`运行时生成的动态代理类。而我们通过反射获取注解时，返回的是`Java`运行时生成的动态代理对象`$Proxy1`。通过代理对象调用自定义注解（接口）的方法，会最终调用`AnnotationInvocationHandler`的`invoke`方法。该方法会从`memberValues`这个`Map`中索引出对应的值。而`memberValues`的来源是`Java`常量池。\n\n## 元注解\n\n`java.lang.annotation`提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：\n\n### `Retention` 定义该注解的生命周期\n\n1. `RetentionPolicy.SOURCE` : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。`@Override`, `@SuppressWarnings`都属于这类注解。\n2. `RetentionPolicy.CLASS` : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式\n3. `RetentionPolicy.RUNTIME` : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。\n\n### `Target` 表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的`ElementType`参数包括\n\n1. `ElementType.CONSTRUCTOR`:用于描述构造器\n2. `ElementType.FIELD`:成员变量、对象、属性（包括`enum`实例）​​\n3. `ElementType.LOCAL_VARIABLE`:用于描述局部变量\n4. `ElementType.METHOD`:用于描述方法\n5. `ElementType.PACKAGE`:用于描述包\n6. `ElementType.PARAMETER`:用于描述参数\n7. `ElementType.TYPE`:用于描述类、接口(包括注解类型) 或`enum`声明\n\n### `Documented` 一个简单的`Annotations`标记注解，表示是否将注解信息添加在`java`文档中\n\n### `Inherited`  元注解是一个标记注解，`@Inherited`阐述了某个被标注的类型是被继承的。如果一个使用了`@Inherited`修饰的`annotation`类型被用于一个`class`，则这个`annotation`将被用于该`class`的子类\n\n## 自定义注解\n\n自定义注解类编写的一些规则:\n`Annotation`型定义为`@interface`, 所有的`Annotation`会自动继承`java.lang.Annotation`这一接口,并且不能再去继承别的类或是接口.\n参数成员只能用`public`或默认(`default`)这两个访问权修饰\n参数成员只能用基本类型`byte`,`short`,`char`,`int`,`long`,`float`,`double`,`boolean`八种基本数据类型和`String`、`Enum`、`Class`、`annotations`等数据类型,以及这一些类型的数组.\n要获取类方法和字段的注解信息，必须通过`Java`的反射技术来获取 `Annotation`对象,因为你除此之外没有别的获取注解对象的方法\n注解也可以没有定义成员, 不过这样注解就没啥用了PS:自定义注解需要使用到元注解\n\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.PARAMETER, ElementType.TYPE})\npublic @interface NotNull {\n}\n```\n","categories":["java"],"tags":["注解","反射"]},{"title":"mac","url":"/2019/10/17/mac/","content":"\n## 常见问题\n\n1. mac 无法直接输入汉字,杀进程就行了\n\n   `safari`连接不上网络,`sudo killall -9 networkd`\n\n2. terminal 切换到 root 提示\n\n   > sh: autojump_add_to_database: command not found\n\n   切换 root 使用`su - root`即可解决这个问题\n\n3. command + tab 切换应用无反应\n   Command+tab 键，选中到那个应用之后，再松开 tab 键，按住 option 键，然后再松开 Command 键就可以显示窗口了\n\n## 命令\n\n`more 1.txt|pbcopy`  \n将文件内容复制到剪切板  \n`pbpaste >> 1.txt`  \n将剪切板内容复制到文件  \n`pandoc`  \nmarkdown 转换为 doc，pdf 等  \n`ncdu`  \n查看当前目录文件大小  \n`mdfind`  \nspotlight 搜索  \n`fzf`  \n模糊搜索工具,进入 fzf 模式  \n`enca`  \n字符集转码  \n`bwm-ng`  \n实时网速显示  \n`ag`  \n文本搜索工具\n\n## 合并 PDF\n\n```shell\n\"/System/Library/Automator/Combine PDF Pages.action/Contents/Resources/join.py\" -o  ~/Downloads/1.pdf    ~/*.pdf\n\n\"/System/Library/Automator/Combine PDF Pages.action/Contents/Resources/join.py\" -o  ~/Downloads/1.pdf    ~/1.pdf ~/2.pdf\n\n```\n\n## 打开`class`文件\n\n```shell\nvim -b XXX.class\n:%!xxd\n```\n\n## 快速搜索文本\n\n使用 grep 命令搜索文件时输出行号（`grep -n`），在 iTerm2 中打开可以直接定位到行\n\n## 虚拟机 ip 固定\n\n在虚拟机/etc/hosts 配置 ip\n","categories":["tips"],"tags":["mac"]},{"title":"bash.md","url":"/2019/10/15/bash-md/","content":"\n## 概述\n\n每条`shell`命令执行都会有个状态码`0`表示成功，`1`表示失败。可以使用`$?`得到上一条命令的执行结果来决定是否执行后续命令，快速的用法是使用`&&`,`||`\n\n{% post_link shell-变量 %}\n\n## 重定向符\n\n对于内核而言，所有打开的文件都是通过文件描述符引用的\n\n文件描述符就是从 0 开始的小的非负整数，内核用以标识一个特定进程正在访问的文件。当打开一个文件或创建一个文件，内核向进程返回一个文件描述符。\n\nLinux 进程默认情况下会有三个缺省打开的文件描述符\n\n- 0（标准输入）`stdin`\n- 1（标准输出）`stdout`\n- 2（标准错误）`stderr`\n\n所以`2>&1` 的意思就是将标准错误也输出到标准输出当中。\n\n`shell`中可能经常能看到：`echo log > /dev/null 2>&1`,命令的结果可以通过`%>`的形式来定义输出,`/dev/null` ：代表空设备文件\n\n_`1 > /dev/null 2>&1` 语句含义,_\n\n1. `1 > /dev/null` ： 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。\n2. 2>&1 ：接着，标准错误输出重定向（等同于）标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。\n\n_`cmd >a 2>a` 和 `cmd >a 2>&1` 为什么不同？_\n\n1. `cmd >a 2>a` ：`stdout`和`stderr`都直接送往文件 `a` ，`a`文件会被打开两遍，由此导致`stdout`和`stderr`互相覆盖。`cmd >a 2>a` 相当于使用了`FD1`、`FD2`两个互相竞争使用文件 `a` 的管道；\n2. `cmd >a 2>&1` ：`stdout`直接送往文件`a`，`stderr`是继承了`FD1`的管道之后，再被送往文件`a` 。`a`文件只被打开一遍，就是`FD1`将其打开。`cmd >a 2>&1` 只使用了一个管道`FD1`，但已经包括了`stdout`和`stderr`。从`IO`效率上来讲，`cmd >a 2>&1`的效率更高。\n\n### 使错误日志重定向到正常输出\n\nsh error.sh > messge.log 2>&1\n\n## 组合命令\n\n可通过`&&`,让多个命令顺序执行，也可以通过`;`,不同的地方为`&&`，当前一个命令的返回码为 0 时，才会执行后一个命令\n例如\n\n```shell\ncd ~/Downloads/ && rm -rf temp`\n```\n\n`||`,与`&&`相反，当前一个命令的返回码大于 0 才执行第二条\n\n## 函数\n\nshell 中函数的定义格式如下：\n\n```shell\n[ function ] funname [()]\n\n{\n\n    action;\n\n    [return int;]\n\n}\n\n```\n\n1. 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return 后跟数值 n(0-255\n2. 函数返回值在调用该函数后通过 \\$? 来获得。\n3. 调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1 表示第一个参数，\\$2 表示第二个参数\n\n示例\n\n```shell\nfun(){\n   echo $1\n   return 1\n}\n\nfun 'hello'\necho $?\n\n```\n\n## 搜索\n\n使用`**/`来递归搜索\n\n```shell\nls -a **/*.log\n```\n\n全局搜索`locate`\n\n递归查找指定文件的制定内容，显示文件名行号内容\n\n```shell\ngrep -rn 'stream' . --include='*.cpp'\n```\n\n## 脚本参数\n\n在写脚本的一开始加上`set -xeuo pipefail`，一般用于调试脚本\n\n示例\n\n```shell\n#!/bin/bash\nset -x\n\n...\n```\n\n> -x: 在执行每一个命令之前把经过变量展开之后的命令打印出来\n> -e: 在遇到一个命令失败时，立即退出\n> -u: 试图使用未经定义的变量，立即退出\n> -o pipefail: 只要管道中的一个子命令失败，整个管道命令就失败。\n\n## 读取用户输入\n\nwhile read line\n\nread 通过输入重定向，把 file 的第一行所有的内容赋值给变量 line，循环体内的命令一般包含对变量 line 的处理；然后循环处理 file 的第二行、第三行。。。一直到 file 的最后一行。还记得 while 根据其后的命令退出状态来判断是否执行循环体吗？是的，read 命令也有退出状态，当它从文件 file 中读到内容时，退出状态为 0，循环继续惊醒；当 read 从文件中读完最后一行后，下次便没有内容可读了，此时 read 的退出状态为非 0，所以循环才会退出。\n\n```shell\n# line 仅仅是个变量名\nwhile read line\ndo\n   echo $line\ndone < file\n```\n\n另一种也很常见的用法：\n\n```shell\ncommand | while read line\ndo\n   echo $line\ndone\n```\n\n如果你还记得管道的用法，这个结构应该不难理解吧。command 命令的输出作为 read 循环的输入，这种结构长用于处理超过一行的输出，当然 awk 也很擅长做这种事。\n\n## 判断文件属性\n\n| 操作符 | 含义                                        |\n| -----: | :------------------------------------------ |\n|     -a | 检查文件是否存在                            |\n|     -b | 检查是否为块特殊文件[1]                     |\n|     -c | 检查是否为字符特殊文件[2]                   |\n|     -d | 检查是否为文件夹                            |\n|     -e | 检查文件是否存在                            |\n|     -f | 检查是否为常规文件[3]                       |\n|     -g | 检查 gid[4]是否被置位                       |\n|     -G | 检查是否有相同的组 ID                       |\n|     -k | 检查防删除位是否被置位                      |\n|     -L | 检查是否为符号链接[5]                       |\n|     -n | 判断字符串长度是否不为 0                    |\n|     -O | 检查文件是否被当前进程的 user ID 拥有       |\n|     -p | 检查文件是否为 FIFO[6]特殊文件或命名管道[7] |\n|     -r | 检查文件是否可读                            |\n|     -s | 检查文件大小是否大于 0                      |\n|     -S | 检查文件是否为 socket 文件                  |\n|     -t | 检查文件描述符是否打开                      |\n|     -u | 检查 uid[8]是否被置位                       |\n|     -w | 检查文件是否可写                            |\n|     -x | 检查文件是否可执行                          |\n|     -z | 判断字符串长度是否为 0                      |\n\n示例\n\n```shell\nif [  -e \"$myPath\"]; then\n   echo 'ok'\nfi\n```\n\n## 逻辑判断\n\n在 linux 中 命令执行状态：0 为真，其他为假\n\n| 操作符 | 解释              |\n| -----: | :---------------- |\n|    -eq | 等于              |\n|    -ne | 不等于            |\n|    -gt | 大于 （greater ） |\n|    -lt | 小于 （less）     |\n|    -ge | 大于等于          |\n|    -le | 小于等于          |\n\n## switch\n\n```shell\ncase 值 in\n模式1)\n    command1\n    command2\n    command3\n    ;;\n模式2）\n    command1\n    command2\n    command3\n    ;;\n*)\n    command1\n    command2\n    command3\n    ;;\nesac\n```\n\n在 shell 中设定`set -u`\n\n## 菜单\n\nselect 命令只需要一条命令就可以创建出菜单，然后获取输入的答案并自动处理。\n命令格式如下：\n\n```shell\nselect variable in list\ndo\ncommands\ndone\n```\n\nlist 参数是由空格分隔的文本选项列表，这些列表构成了整个菜单。select 命令会将每个列表项显示成一个带编号的选项，然后为选项显示一个由 PS3 环境变量定义的特殊提示符。\n\n例如：\n\n```shell\n#!/bin/bash\n# using select in the menu\n\nfunction diskspace {\n clear\n df -k\n}\n\nfunction whoseon {\n clear\n who\n}\n\nfunction memusage {\n clear\n cat /proc/meminfo\n}\n\nPS3=\"Enter an option: \"\nselect option in \"Display disk space\" \"Display logged on users\" \"Display memory usage\" \"Exit program\"\ndo\n case $option in\n \"Exit program\")\n break ;;\n \"Display disk space\")\n diskspace ;;\n \"Display logged on users\")\n memusage ;;\n \"Display memory usage\"）\n memusage ;;\n *)\n clear\n echo \"Sorry, wrong selection\";;\n esac\ndone\nclear\n```\n\n> wsx@wsx:~/tmp\\$ ./smenu1\n>\n> 1. Display disk space 3) Display memory usage\n> 2. Display logged on users 4) Exit program\n>    Enter an option:\n\n## 错误问题\n\n执行 sh 脚本时报错\n\n> '\\r':command not found\n\n这是因为在 win 上的格式有问题，使用 dos2unix 命令转换一下脚本即可\n","categories":["linux"],"tags":["bash","shell"]},{"title":"python入门","url":"/2019/10/10/python%E5%85%A5%E9%97%A8/","content":"\n## class 实例的方法，第一个参数自动转换为实例的索引\n\n第一个参数不一定非要是`self`\n\n## 类方法\n\n直接使用`Class.method(instance)`，参数需要显式的传递实例对象\n\n## python 对重载运算符\n\n什么是运算符重载\n让自定义的类生成的对象(实例)能够使用运算符进行操作\n作用:\n让自定义的实例像内建对象一样进行运算符操作\n让程序简洁易读\n对自定义对象将运算符赋予新的规则\n\n### 算术运算符的重载\n\n方法名                   运算符和表达式       说明\n\n```python\n__add__(self,rhs)        self + rhs        加法\n__sub__(self,rhs)        self - rhs         减法\n__mul__(self,rhs)        self * rhs         乘法\n__truediv__(self,rhs)   self / rhs          除法\n__floordiv__(self,rhs)  self //rhs          地板除\n__mod__(self,rhs)       self % rhs       取模(求余)\n__pow__(self,rhs)       self **rhs         幂运算\n__or__(self, other)      self | other      或运算\n__and__(self, other)      self & other      与运算\n```\n\n示例\n\n```python\nclass Mynumber:\n    def __init__(self,v):\n        self.data = v\n    def __repr__(self): #消除两边的尖括号\n        return \"Mynumber(%d)\"%self.data\n\n    def __add__(self,other):\n        '''此方法用来制定self + other的规则'''\n\n        v = self.data + other.data\n        return Mynumber(v) #用v创建一个新的对象返回给调用者\n\n    def __sub__(self,other):\n        '''此方法用来制定self - other的规则'''\n        v = self.data - other.data\n        return Mynumber(v)\n\nn1 = Mynumber(100)\nn2 = Mynumber(200)\n# n3 = n1 + n2\nn3 = n1+n2 # n3 = n1.__add__(n2)\nprint(n3)   #Mynumber(300)\nn4 = n3 - n2 #等同于n4 = n3.__sub__(n2)\n```\n\n### 反向运算符的重载\n\n当运算符的左侧为内建类型时,右侧为自定义类型进行算术匀算符运算时会出现 TypeError 错误,因为无法修改内建类型的代码          实现运算符重载,此时需要使用反向运算符的重载\n\n方法名                   运算符和表达式       说明\n\n```python\n**radd**(self,lhs)       lhs + self       加法\n**rsub**(self,lhs)       lhs - self       减法\n**rmul**(self,lhs)       lhs \\* self       乘法\n**rtruediv**(self,lhs)   lhs / self       除法\n**rfloordiv**(self,lhs)  lhs // self       地板除\n**rmod**(self,lhs)       lhs % self       取模(求余)\n**rpow**(self,lhs)       lhs \\*\\* self       幂运算\n```\n\n### 比较算术运算符的重载\n\n方法名                   运算符和表达式       说明\n\n```python\n__lt__(self,rhs)       self < rhs        小于\n__le__(self,rhs)       self <= rhs       小于等于\n__gt__(self,rhs)       self > rhs        大于\n__ge__(self,rhs)       self >= rhs       大于等于\n__eq__(self,rhs)       self == rhs       等于\n__ne__(self,rhs)       self != rhs       不等于\n```\n\n### 位运算符重载\n\n方法名               运算符和表达式         说明\n\n```python\n__and__(self,rhs)       self & rhs           位与\n__or__(self,rhs)        self | rhs              位或\n__xor__(self,rhs)       self ^ rhs             位异或\n__lshift__(self,rhs)    self <<rhs            左移\n__rshift__(self,rhs)    self >>rhs            右移\n```\n\n### 其他运算符重载\n\nin/not in 运算符重载\n注: in / not in 返回布尔值 True / False\n当重载了\\_\\_contains\\_\\_后,in 和 not in 运算符都可用\nnot in 运算符的返回值与 in 相反\n\n```python\n__contains__(self,e):\n```\n\n## 父类构造器\n\n`python`不会自动调用父类构造器,需要显式的调用\n\n```python\nclass SongBird(Bird):\n\n    def __init__(self):\n\n        Bird.__init__(self)\n\n        self.sound = 'Squawk'\n\n    def sing(self):\n\n        print self.sound\n\n```\n\n## class 属性\n\n定义在`class`方法外的属性,`method`本身也属于`class`属性\n\n## 断言\n\n断言自定义提示信息\n\n```python\nassert x >= 0, 'x is less than zero'\n```\n\n## 更新`PIP`\n\n`python -m pip install -U pip`\n\n## `XML`解析\n\n```python\nimport xml.etree.ElementTree as ET\n\ntree = ET.parse(\"country.xml\")\nroot = tree.getroot()\nroot.tag\nroot.attrlib\n\nfind(match)    # 查找第一个匹配的子元素， match可以时tag或是xpaht路径\nfindall(match  # 返回所有匹配的子元素列表\nfindtext(match, default=None)\niter(tag=None) # 以当前元素为根节点 创建树迭代器,如果tag不为None,则以tag进行过滤\niterfind(match)\n\n```\n\n## 调用其他 py 文件方法\n\n```python\nimport other\n\nother.m()\n\n```\n\n## 动态调用方法\n\n在`py`文件中，可以使用\n\n```python\ndef func(arg1,arg2):\n    pass\n\nglobals()['func'](1,2)\n```\n\n调用`class`方法，可以使用\n\n```python\nclass Data:\n    def func(self,arg1,arg2):\n        pass\n\ndata = Data()\nfunc = getattr(data,'func')\nfunc(1,2)\n\n```\n\n## 字符串格式化\n\n`python`可以使用`''' str '''`,来进行纯字符串赋值，而不需要考虑转译字符。\n`python`字符串可定义占位符，通过`format`函数进行格式化\n\n```python\nprint('{}1{}'.format(0,3))\nprint('{a}1{b}'.format(** {\"a\":1,\"b\":3,}))\n\n```\n\n`json`格式化输出\n\n```python\nimport json\nstr = '{\"foo\":\"bar\",\"name\":\"he\"}'\nparsed = json.loads(str)\nprint(json.dumps(parsed,indent=4,sort_keys=True))\n```\n\n## 常用函数\n\n### `zip`将多个数组打包成元组\n\n```python\na = [1,2,3]\nb = [4,5,6,7,8]\nzipped =zip(a,b)       # 元素个数与最短的列表一致\nzip(*zipped)           # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式\n```\n\n### `list`转换为数组\n\n很多常用函数函数的不是直接的数组，比如`map`,`filter`等，需要在使用`list`直接转换为数组\n\n### `enumerate`函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标\n\n```python\nenumerate(sequence, [start=0])\n\nseasons = ['Spring', 'Summer', 'Fall', 'Winter']\nlist(enumerate(seasons))\n#[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]\n```\n\n## 返回多个值\n\n```python\ndef multi():\n    return 1,2\n\nx,y = multi()\n\n```\n\n实际上 python 返回的是一个`tulpe`，在语法上，返回一个 tuple 可以省略括号，而多个变量可以同时接收一个 tuple，按位置赋给对应的值，所以，Python 的函数返回多值其实就是返回一个 tuple，但写起来更方便.\n\n## 获取方法文档注释\n\n```python\nmy_func.__doc__\n```\n\n## 获取`python`版本\n\n```python\nimport sys\nif sys.version_info[0] < 3:\n    raise Exception(\"Must be using Python 3\")\n```\n\n## 枚举\n\n`python3.4`版本支持\n\n```python\nfrom enum import Enum\n\n\nclass Direction(Enum):\n    LEFT = \"left\"\n    RIGHT = \"right\"\n    UP = \"up\"\n    DOWN = \"down\"\n\n\ndef move(direction):\n\n    # Type checking\n    if not isinstance(direction, Direction):\n        raise TypeError('direction must be an instance of Direction Enum')\n\n    print(direction.value)\n\nmove(Direction.LEFT)#left\nmove(\"right\")#TypeError: direction must be an instance of Direction Enum\nprint({d.name: d.value for d in Direction})\nprint(Direction('up').name)#UP\n\n```\n\n## 获取所有方法\n\n```python\nprint([func for func in dir(Func) if callable(getattr(Func,func))])\n```\n\n## 打印方法的所有参数\n\n```python\nimport inspect\nprint(inspect.getfullargspec(a_method))\n```\n\n## 参数\n\n### 可变参数\n\n1. 当我们声明一个星号的参数，如`*param`，那么从这一点开始到结束的所有位置的参数都被收集到一个叫`param`的元组中。\n2. 同样,当我们声明一个双星参数，如`**param`，那么从那一点开始到结束的所有关键字参数都被收集到一个叫`param`的字典中。\n3. 当我们调用方法时显示的使用`*`，即表示将当前数组展开为多个参数。`**`同理\n\n```python\n\na = [1, 2, 3]\n\n\ndef m1(*arg):\n    print(arg)\n    pass\n\n\nm1(1, 2)\nm1(a)\nm1(*a)\n\n\ndef m2(arg):\n    print(arg)\n    pass\n\n\nm2(a)\nm2(*a)\n\n```\n\n执行结果\n\n> (1, 2)\n> ([1, 2, 3],)\n> (1, 2, 3)\n> [1, 2, 3]\n> Traceback (most recent call last):\n> File \"/Users/li/Downloads/test.py\", line 21, in \\<module\\>\n> m2(\\*a)\n\n调用方法显示使用`**`\n\n```python\npara = {'a': 1, 'b': 2}\n\n\ndef m(** para):\n\n    print(para)\n    pass\n\n\nm(**para)\nprint('-----------------')\nm(para)\n\n```\n\n> {'a': 1, 'b': 2}\n> '-----------------\n> Traceback (most recent call last):\n> File \"/Users/li/Downloads/test.py\", line 12, in \\<module\\>\n> m(para)\n\n### 默认参数\n\n```python\ndef log(level='debug'):\n\n    print(level)\n\nlog()\nlog('hello')\nlog(level='info')\n\n```\n\n> debug\n> hello\n> info\n\n## 全局变量\n\n全局变量需要在外部声明，在方法内部使用时需要在方法内部使用 global 申声明\n\n```python\nname = None\ndef foo():\n    global name\n    print(name)\n\ndef bar():\n    global name\n    name ='bar'\n\nfoo()\nbar()\nfoo()\n```\n\n> None\n> bar\n\n## 开启一个简单的 http 服务\n\npython2 或者低版本，直接敲\n\n```shell\npython -m SimpleHTTPServer <port>\n```\n\npython3\n\n```shell\npython -m http.server <port>\n```\n","categories":["python"],"tags":["python"]},{"title":"jquery相关","url":"/2019/09/10/jquery%E7%9B%B8%E5%85%B3/","content":"\n## 引入公共页面\n\n```html\n<div id=\"header\"></div>\n```\n\n```js\n$(\"#header\").load(\"header.html\");\n```\n","categories":["前端"],"tags":["jquery","html"]},{"title":"vue入门","url":"/2019/09/08/vue%E5%85%A5%E9%97%A8/","content":"\n## 安装`vue-cli`\n\n`npm i -gD vue-cli`\n\n## 创建项目\n\n`vue init webpack projectname`,`webpack`表示模板，项目名必须全部小写,安装过程中注意`vue-router`选择`Y`\n项目安装失败，尝试重新安装`vue-cli`\n\n## 启动项目\n\n`npm run dev`\n\n## `package.json`\n\n模块描述文件，类似`maven`的`pom.xml`文件\n\n`name` - 包名.\n`version` - 包的版本号。\n`description` - 包的描述。\n`homepage` - 包的官网 URL。\n`author` - 包的作者。\n`contributors` - 包的其他贡献者。\n`dependencies` / devDependencies - 生产/开发环境依赖包列表。它们将会被安装在 node_module 目录下。\n`repository` - 包代码的 Repo 信息，包括 type 和 URL，type 可以是 git 或 svn，URL 则是包的 Repo 地址。\n`main - main` 字段指定了程序的主入口文件，require('moduleName') 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。\n`keywords` - 关键字\n\n## 路由\n\n`<router-view>`挂载路由，默认挂载`/`  \n`<router-link on='/xxx'>`路由跳转，渲染后既是`<a>`  \n`mode: 'history'`使用历史模式，即`url`不以`#`跳转页面\n\n### 配置路由\n\n模块`A.vue`\n\n```html\n<router-link to=\"/b\">xxx</router-link> <router-view></router-view>\n```\n\n路由配置\n\n```javascript\nimport Vue from \"vue\";\nimport Router from \"vue-router\";\nimport A from \"./components/A.vue\";\nimport B from \"./components/B.vue\";\n\nVue.use(Router);\n\nexport default new Router({\n  mode: \"history\",\n  base: process.env.BASE_URL,\n  routes: [\n    {\n      path: \"/\",\n      component: A,\n      children: [\n        {\n          path: \"/b\",\n          component: B,\n        },\n      ],\n    },\n  ],\n});\n```\n\n在模块中使用`<router-view>`,同时在关于模块中的路由配置需要配置`children`实现挂载页面，效果既是在跳转`b`时，`A`模块会作为公共模块依然存在\n\n## 手动创建`vue`项目\n\n1. `npm install`会生成`package-lock.json`文件\n2. `npm init -f`会生成`package.json`文件\n3. 安装`vue`需要的依赖，`npm i vue-router -D`\n\n## `vue3`\n\n安装 `npm i -g @vue/cli`\n图像界面`vue ui`\n创建项目 `vue create projectname`  \n启动项目 `npm run serve`\n\n> safari 浏览器缓存的问题，页面刷新不及时，使用 chrome 去调试\n\n## 引入`css`\n\n在需要加入的模块引入\n\n```css\n<style>\n@import url(../../public/vue.css);\n</style>\n```\n\n在`index.html`首页添加，全局有效\n\n## 语法规则\n\n### \\$mount 的用法\n\n\\$mount 方法是用来挂载我们的扩展的。做一个扩展，然后用\\$mount 的方法把扩展挂载到 dom 上\n\n```javascript\nvar judy = Vue.extend({\n  template: \"<p>{{message}}</p>\",\n  data: function () {\n    return {\n      message: \"I am Judy\",\n    };\n  },\n});\nvar vm = new judy().$mount(\"#app\");\n```\n\n```html\n<div id=\"app\">\n  {{message}}\n</div>\n```\n","categories":["前端"],"tags":["node","vue","npm"]},{"title":"log4j日志问题","url":"/2019/09/05/log4j%E6%97%A5%E5%BF%97%E9%97%AE%E9%A2%98/","content":"\n## 问题描述\n\n应用中需要将多个`logger`的日志输出到同一个文件中，且需要根据时间每天自动分割文件。我们使用`DailyRollingFileAppender`\n配置如下\n\n```properties\n# 开启log4j的日志\nlog4j.debug=true\nlog4j.rootLogger=error, stdout\nlog4j.logger.l1=DEBUG, fuck1\nlog4j.logger.l2=DEBUG, fuck2\n\n#l1\nlog4j.appender.fuck1=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.fuck1.DatePattern='.'-yyyy-MM-dd-HH-mm\nlog4j.appender.fuck1.layout=org.apache.log4j.PatternLayout\nlog4j.appender.fuck1.File=/Users/li/Downloads/log4j/log4j.log\nlog4j.appender.fuck1.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n\n\n#l2\nlog4j.appender.fuck2=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.fuck2.DatePattern='.'-yyyy-MM-dd-HH-mm\nlog4j.appender.fuck2.layout=org.apache.log4j.PatternLayout\nlog4j.appender.fuck2.File=/Users/li/Downloads/log4j/log4j.log\nlog4j.appender.fuck2.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n\n\n```\n\n测试代码我使用`Spring`的`Scheduled`\n\n```java\npackage com.li.springboot.util;\n\nimport org.apache.log4j.Logger;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class ScheduledTask {\n\n    Logger logger = Logger.getLogger(\"l1\");\n    Logger logger2 = Logger.getLogger(\"l2\");\n    private int index = 0;\n\n    @Scheduled(cron = \"*/1 * * * * *\")\n    public void log() {\n        logger.info(\"--------------------\" + index++);\n        logger2.debug(\"--------------------\" + index++);\n    }\n\n}\n\n```\n\n`*/1 * * * * *`表示每秒执行一次\n\n`log4j.appender.fuck1.DatePattern='.'-yyyy-MM-dd-HH-mm`表示每分钟分割一次文件\n\n在执行定时任务到底切割点时，我们可以观察到日志输出\n\n`log4j`自身的日志一定输出在`System.out`中\n\n```log\n2019-09-05 21:16:59 DEBUG l2:22 - --------------------44\nlog4j: /Users/li/Downloads/log4j/log4j.log -> /Users/li/Downloads/log4j/log4j.log.-2019-09-05-21-16\nlog4j: setFile called: /Users/li/Downloads/log4j/log4j.log, true\nlog4j: setFile ended\n2019-09-05 21:17:00 INFO  l1:21 - --------------------45\nlog4j: /Users/li/Downloads/log4j/log4j.log -> /Users/li/Downloads/log4j/log4j.log.-2019-09-05-21-16\nlog4j: setFile called: /Users/li/Downloads/log4j/log4j.log, true\nlog4j: setFile ended\n2019-09-05 21:17:00 DEBUG l2:22 - --------------------46\n```\n\n我们观察下源码分析下这个过程\n\n```java\n  protected void subAppend(LoggingEvent event) {\n    long n = System.currentTimeMillis();\n    //检测当前时间点是否需要分割文件\n    if (n >= nextCheck) {\n      now.setTime(n);\n      nextCheck = rc.getNextCheckMillis(now);\n      try {\n        rollOver();\n      }\n      catch(IOException ioe) {\n          if (ioe instanceof InterruptedIOException) {\n              Thread.currentThread().interrupt();\n          }\n        LogLog.error(\"rollOver() failed.\", ioe);\n      }\n    }\n    super.subAppend(event);\n   }\n}\n\nvoid rollOver() throws IOException {\n\n    /* Compute filename, but only if datePattern is specified */\n    if (datePattern == null) {\n      errorHandler.error(\"Missing DatePattern option in rollOver().\");\n      return;\n    }\n\n    String datedFilename = fileName+sdf.format(now);\n    // It is too early to roll over because we are still within the\n    // bounds of the current interval. Rollover will occur once the\n    // next interval is reached.\n    if (scheduledFilename.equals(datedFilename)) {\n      return;\n    }\n\n    // close current file, and rename it to datedFilename\n    this.closeFile();\n    //如果存在其他分割后的文件，则删除\n    File target  = new File(scheduledFilename);\n    if (target.exists()) {\n      target.delete();\n    }\n\n    File file = new File(fileName);\n    //将当前日志文件改名为代日期的文件\n    boolean result = file.renameTo(target);\n    if(result) {\n      LogLog.debug(fileName +\" -> \"+ scheduledFilename);\n    } else {\n      LogLog.error(\"Failed to rename [\"+fileName+\"] to [\"+scheduledFilename+\"].\");\n    }\n\n    try {\n      // This will also close the file. This is OK since multiple\n      // close operations are safe.\n      //将log4j日志的输出重定向为不带日期的文件\n      this.setFile(fileName, true, this.bufferedIO, this.bufferSize);\n    }\n    catch(IOException e) {\n      errorHandler.error(\"setFile(\"+fileName+\", true) call failed.\");\n    }\n    scheduledFilename = datedFilename;\n  }\n\n```\n\n1. `logger`的日志在`logger2`之前，因此先触发`rollOver`,此时没有文件`log4j.log.-2019-09-05-21-16`,将`log4j.log`重命名为`log4j.log.-2019-09-05-21-16`,并将`logger`的日志流重定向为`log4j.log`\n\n2. 紧接着`logger2`的日志流触发`rollOver`,此时会将`log4j.log.-2019-09-05-21-16`删除，同时将`log4j.log`重命名为`log4j.log.-2019-09-05-21-16`，并将`logger2`的日志流重定向为`log4j.log`。此时`logger`的日志流就的文件名被改名了。\n\n3. 我们可以看出第一轮的日志被`logger2`触发的`rollOver`删除了，而`logger`的日志流输出到`上一轮`\n\n## 解决方案\n\n根据分析，我们确保`target.delete()`和`ile.renameTo(target)`只被执行一次，且其他`logger`在指定时间重新将日志流指向到最新的`log4j.log`即可。\n\n比如说简单的重写`DailyRollingFileAppender`,在`rollOver`代码处稍作修改\n\n```java\nFile target = new File(scheduledFilename);\n//当目标文件已经存在时，就说明已经被切割过了，则简单重定向即可\nif (!target.exists()) {\n    File file = new File(fileName);\n    boolean result = file.renameTo(target);\n    if (result) {\n        LogLog.debug(fileName + \" -> \" + scheduledFilename);\n    } else {\n        LogLog.error(\"Failed to rename [\" + fileName + \"] to [\" + scheduledFilename + \"].\");\n    }\n}\ntry {\n        this.setFile(fileName, true, this.bufferedIO, this.bufferSize);\n    } catch (IOException e) {\n        errorHandler.error(\"setFile(\" + fileName + \", true) call failed.\");\n}\n    scheduledFilename = datedFilename;\n```\n","categories":["java"],"tags":["log4j"]},{"title":"aop概念","url":"/2019/09/04/aop%E6%A6%82%E5%BF%B5/","content":"\n## 术语\n\n1. 连接点 `Join Point` java运行过程中的位置，对于`Spring`来说，表示允许使用切面的位置，它一般是指方法运行的过程，比如运行前，运行后，抛出异常等。\n2. 通知 `Advice` 在某连接点上执行的特殊操作\n3. 切入点 `PointCut` 切入点通过表达式来连接通知和连接点，确定连接点是否符合切入点表达式\n4. 目标类 `Target` 被切面切入的类\n5. 代理类 `AOP proxy` 实现切面的方式即实现目标类的代理类对象，对于`Spring`来说，通过`JDK`动态代理和`CGLIB`字节码代理\n6. 织入 `Weaving` 把切面应用到目标对象来创建新的代理对象的过程\n\n## `JDK`动态代理\n\n`JDK`动态代理仅支持代理接口(因为代理类继承`Proxy`，而`java`不支持多继承)。\b由`JDK`动态生成继承接口的子类，子类的所有方法调用都由创建代理类时使用的参数`java.lang.reflect.InvocationHandler`的`invoke`方法去完成。\n\n```java\npackage com.li.springboot.aop;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.function.Supplier;\n\npublic class DJKProxy<T> implements InvocationHandler {\n\n    private T t;\n\n    public DJKProxy(T t) {\n        this.t = t;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"method = \" + method);\n        return method.invoke(t, args);\n    }\n\n    public static void main(String[] args) {\n        //设置为true时，将会在项目跟目录生成代理类的源码\n        System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\");\n        Supplier supplier = () -> 1;\n        DJKProxy<Supplier> proxy = new DJKProxy<>(supplier);\n        Supplier proxyInstance = (Supplier) Proxy.newProxyInstance(DJKProxy.class.getClassLoader(), supplier.getClass().getInterfaces(), proxy);\n        Object result = proxyInstance.get();\n        System.out.println(\"proxyInstance = \" + proxyInstance);\n        System.out.println(\"result = \" + result);\n    }\n}\n\n```\n\n下面是自动生成的代理类反编译的源码\n\n```java\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\n\npackage com.sun.proxy;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\nimport java.util.function.Supplier;\n\npublic final class $Proxy0 extends Proxy implements Supplier {\n    private static Method m1;\n    private static Method m2;\n    private static Method m3;\n    private static Method m0;\n\n    public $Proxy0(InvocationHandler var1) throws  {\n        super(var1);\n    }\n\n    public final boolean equals(Object var1) throws  {\n        try {\n            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final String toString() throws  {\n        try {\n            return (String)super.h.invoke(this, m2, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final Object get() throws  {\n        try {\n            return (Object)super.h.invoke(this, m3, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final int hashCode() throws  {\n        try {\n            return (Integer)super.h.invoke(this, m0, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    static {\n        try {\n            m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\"));\n            m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\");\n            m3 = Class.forName(\"java.util.function.Supplier\").getMethod(\"get\");\n            m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\");\n        } catch (NoSuchMethodException var2) {\n            throw new NoSuchMethodError(var2.getMessage());\n        } catch (ClassNotFoundException var3) {\n            throw new NoClassDefFoundError(var3.getMessage());\n        }\n    }\n}\n```\n\n我们可以看到实际所有方法的调用都由`InvocationHandler`去调用，我们查看下`Proxy.newProxyInstance`的细节\n\n```java\n public static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        Objects.requireNonNull(h);\n\n        final Class<?>[] intfs = interfaces.clone();\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n        }\n\n        /*\n         *  获取代理类class类型，也就是动态生成代理类的过程\n         */\n        Class<?> cl = getProxyClass0(loader, intfs);\n\n        /*\n         * Invoke its constructor with the designated invocation handler.\n         */\n        try {\n            if (sm != null) {\n                checkNewProxyPermission(Reflection.getCallerClass(), cl);\n            }\n            /**\n             * 获取使用InvocationHandler作为参数的构造器，并且实例化\n             */\n            final Constructor<?> cons = cl.getConstructor(constructorParams);\n            final InvocationHandler ih = h;\n            if (!Modifier.isPublic(cl.getModifiers())) {\n                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        cons.setAccessible(true);\n                        return null;\n                    }\n                });\n            }\n            return cons.newInstance(new Object[]{h});\n        } catch (IllegalAccessException|InstantiationException e) {\n            throw new InternalError(e.toString(), e);\n        } catch (InvocationTargetException e) {\n            Throwable t = e.getCause();\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            } else {\n                throw new InternalError(t.toString(), t);\n            }\n        } catch (NoSuchMethodException e) {\n            throw new InternalError(e.toString(), e);\n        }\n    }\n\n```\n\n```java\n private static final WeakCache<ClassLoader, Class<?>[], Class<?>>\n        proxyClassCache = new WeakCache<>(new KeyFactory(), new ProxyClassFactory());\n\nprivate static Class<?> getProxyClass0(ClassLoader loader,\n                                        Class<?>... interfaces) {\n    if (interfaces.length > 65535) {\n        throw new IllegalArgumentException(\"interface limit exceeded\");\n    }\n    //根据接口返回代理类，当前classloader已经存在则直接返回缓存\n    return proxyClassCache.get(loader, interfaces);\n}\n```\n\n```java\npublic V get(K key, P parameter) {\n    Objects.requireNonNull(parameter);\n\n    expungeStaleEntries();\n\n    Object cacheKey = CacheKey.valueOf(key, refQueue);\n\n    ConcurrentMap<Object, Supplier<V>> valuesMap = map.get(cacheKey);\n    if (valuesMap == null) {\n        ConcurrentMap<Object, Supplier<V>> oldValuesMap\n            = map.putIfAbsent(cacheKey,\n                                valuesMap = new ConcurrentHashMap<>());\n        if (oldValuesMap != null) {\n            valuesMap = oldValuesMap;\n        }\n    }\n\n    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));\n    Supplier<V> supplier = valuesMap.get(subKey);\n    Factory factory = null;\n\n    while (true) {\n        if (supplier != null) {\n            V value = supplier.get();\n            if (value != null) {\n                return value;\n            }\n        }\n        if (factory == null) {\n            factory = new Factory(key, parameter, subKey, valuesMap);\n        }\n\n        if (supplier == null) {\n            supplier = valuesMap.putIfAbsent(subKey, factory);\n            if (supplier == null) {\n                supplier = factory;\n            }\n        } else {\n            if (valuesMap.replace(subKey, supplier, factory)) {\n                supplier = factory;\n            } else {\n                supplier = valuesMap.get(subKey);\n            }\n        }\n    }\n}\n\n```\n\n通过断点`debug`，我们可以得出`supplier`的类为`class java.lang.reflect.WeakCache$Factory`,查看其`get`方法，\n\n```java\npublic synchronized V get() { // serialize access\n    // re-check\n    Supplier<V> supplier = valuesMap.get(subKey);\n    if (supplier != this) {\n        // the loop\n        return null;\n    }\n    V value = null;\n    try {\n        //根据上面的代码可知valueFactory为ProxyClassFactory\n        value = Objects.requireNonNull(valueFactory.apply(key, parameter));\n    } finally {\n        if (value == null) { // remove us on failure\n            valuesMap.remove(subKey, this);\n        }\n    }\n    assert value != null;\n\n    CacheValue<V> cacheValue = new CacheValue<>(value);\n\n    if (valuesMap.replace(subKey, this, cacheValue)) {\n        reverseMap.put(cacheValue, Boolean.TRUE);\n    } else {\n        throw new AssertionError(\"Should not reach here\");\n    }\n    return value;\n}\n```\n\n查看`ProxyClassFactory`的`apply`方法，\n\n```java\n@Override\npublic Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {\n\n    Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);\n    for (Class<?> intf : interfaces) {\n        Class<?> interfaceClass = null;\n        try {\n            interfaceClass = Class.forName(intf.getName(), false, loader);\n        } catch (ClassNotFoundException e) {\n        }\n        if (interfaceClass != intf) {\n            throw new IllegalArgumentException(\n                intf + \" is not visible from class loader\");\n        }\n        if (!interfaceClass.isInterface()) {\n            throw new IllegalArgumentException(\n                interfaceClass.getName() + \" is not an interface\");\n        }\n        if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {\n            throw new IllegalArgumentException(\n                \"repeated interface: \" + interfaceClass.getName());\n        }\n    }\n\n    String proxyPkg = null;     // package to define proxy class in\n    int accessFlags = Modifier.PUBLIC | Modifier.FINAL;\n\n    for (Class<?> intf : interfaces) {\n        int flags = intf.getModifiers();\n        if (!Modifier.isPublic(flags)) {\n            accessFlags = Modifier.FINAL;\n            String name = intf.getName();\n            int n = name.lastIndexOf('.');\n            String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1));\n            if (proxyPkg == null) {\n                proxyPkg = pkg;\n            } else if (!pkg.equals(proxyPkg)) {\n                throw new IllegalArgumentException(\n                    \"non-public interfaces from different packages\");\n            }\n        }\n    }\n\n    if (proxyPkg == null) {\n        proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\";\n    }\n\n    long num = nextUniqueNumber.getAndIncrement();\n    //代理类的类名 com.sun.proxy. + $Proxy + 1\n    String proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n        proxyName, interfaces, accessFlags);\n    try {\n        //加载类\n        return defineClass0(loader, proxyName,\n                            proxyClassFile, 0, proxyClassFile.length);\n    } catch (ClassFormatError e) {\n        throw new IllegalArgumentException(e.toString());\n    }\n}\n```\n\n```java\n private final static boolean saveGeneratedFiles =java.security.AccessController.doPrivileged(new GetBooleanAction(\"sun.misc.ProxyGenerator.saveGeneratedFiles\")).booleanValue();\npublic static byte[] generateProxyClass(final String name, Class<?>[] interfaces,int accessFlags){\n    ProxyGenerator gen = new ProxyGenerator(name, interfaces, accessFlags);\n    //生成类\n    final byte[] classFile = gen.generateClassFile();\n\n    if (saveGeneratedFiles) {//根据sun.misc.ProxyGenerator.saveGeneratedFiles决定是否输出代理类的文件\n        java.security.AccessController.doPrivileged(\n        new java.security.PrivilegedAction<Void>() {\n            public Void run() {\n                try {\n                    int i = name.lastIndexOf('.');\n                    Path path;\n                    if (i > 0) {\n                        Path dir = Paths.get(name.substring(0, i).replace('.', File.separatorChar));\n                        Files.createDirectories(dir);\n                        path = dir.resolve(name.substring(i+1, name.length()) + \".class\");\n                    } else {\n                        path = Paths.get(name + \".class\");\n                    }\n                    Files.write(path, classFile);\n                    return null;\n                } catch (IOException e) {\n                    throw new InternalError(\n                        \"I/O exception saving generated file: \" + e);\n                }\n            }\n        });\n    }\n\n    return classFile;\n}\n\n```\n\n```java\nprivate byte[] generateClassFile() {\n\n    /*\n     * 注册Object方法的代理方法\n     */\n    addProxyMethod(hashCodeMethod, Object.class);\n    addProxyMethod(equalsMethod, Object.class);\n    addProxyMethod(toStringMethod, Object.class);\n\n    /*\n     * 注解接口方法的代理方法\n     */\n    for (Class<?> intf : interfaces) {\n        for (Method m : intf.getMethods()) {\n            addProxyMethod(m, intf);\n        }\n    }\n\n    for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n        checkReturnTypes(sigmethods);\n    }\n\n    try {\n        // 生成默认构造器\n        methods.add(generateConstructor());\n\n        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n            for (ProxyMethod pm : sigmethods) {\n\n                // 生成静态变量target方法\n                fields.add(new FieldInfo(pm.methodFieldName,\n                    \"Ljava/lang/reflect/Method;\",\n                        ACC_PRIVATE | ACC_STATIC));\n\n                // 生成代理方法细节，即交由InvocationHandler调用，参数使用了静态属性target方法\n                methods.add(pm.generateMethod());\n            }\n        }\n\n        methods.add(generateStaticInitializer());\n\n    } catch (IOException e) {\n        throw new InternalError(\"unexpected I/O Exception\", e);\n    }\n\n    if (methods.size() > 65535) {\n        throw new IllegalArgumentException(\"method limit exceeded\");\n    }\n    if (fields.size() > 65535) {\n        throw new IllegalArgumentException(\"field limit exceeded\");\n    }\n\n    cp.getClass(dotToSlash(className));\n    cp.getClass(superclassName);\n    for (Class<?> intf: interfaces) {\n        cp.getClass(dotToSlash(intf.getName()));\n    }\n    cp.setReadOnly();\n    ByteArrayOutputStream bout = new ByteArrayOutputStream();\n    DataOutputStream dout = new DataOutputStream(bout);\n\n    try {\n                                    // u4 magic;\n        dout.writeInt(0xCAFEBABE);\n                                    // u2 minor_version;\n        dout.writeShort(CLASSFILE_MINOR_VERSION);\n                                    // u2 major_version;\n        dout.writeShort(CLASSFILE_MAJOR_VERSION);\n\n        cp.write(dout);             // (write constant pool)\n\n                                    // u2 access_flags;\n        dout.writeShort(accessFlags);\n                                    // u2 this_class;\n        dout.writeShort(cp.getClass(dotToSlash(className)));\n                                    // u2 super_class;\n        dout.writeShort(cp.getClass(superclassName));\n\n                                    // u2 interfaces_count;\n        dout.writeShort(interfaces.length);\n                                    // u2 interfaces[interfaces_count];\n        for (Class<?> intf : interfaces) {\n            dout.writeShort(cp.getClass(\n                dotToSlash(intf.getName())));\n        }\n\n                                    // u2 fields_count;\n        dout.writeShort(fields.size());\n                                    // field_info fields[fields_count];\n        for (FieldInfo f : fields) {\n            f.write(dout);\n        }\n\n                                    // u2 methods_count;\n        dout.writeShort(methods.size());\n                                    // method_info methods[methods_count];\n        for (MethodInfo m : methods) {\n            m.write(dout);\n        }\n\n                                        // u2 attributes_count;\n        dout.writeShort(0); // (no ClassFile attributes for proxy classes)\n\n    } catch (IOException e) {\n        throw new InternalError(\"unexpected I/O Exception\", e);\n    }\n\n    return bout.toByteArray();\n}\n\n```\n\n```java\n/**\n * 根据方法名，方法参数类型，方法返回类型，抛出异常来给fromClass增加方法\n */\nprivate void addProxyMethod(Method m, Class<?> fromClass) {\n    String name = m.getName();\n    Class<?>[] parameterTypes = m.getParameterTypes();\n    Class<?> returnType = m.getReturnType();\n    Class<?>[] exceptionTypes = m.getExceptionTypes();\n\n    String sig = name + getParameterDescriptors(parameterTypes);\n    List<ProxyMethod> sigmethods = proxyMethods.get(sig);\n    if (sigmethods != null) {\n        for (ProxyMethod pm : sigmethods) {\n            if (returnType == pm.returnType) {\n                List<Class<?>> legalExceptions = new ArrayList<>();\n                collectCompatibleTypes( exceptionTypes, pm.exceptionTypes, legalExceptions);\n                collectCompatibleTypes( pm.exceptionTypes, exceptionTypes, legalExceptions);\n                pm.exceptionTypes = new Class<?>[legalExceptions.size()];\n                pm.exceptionTypes = legalExceptions.toArray(pm.exceptionTypes);\n                return;\n            }\n        }\n    } else {\n        sigmethods = new ArrayList<>(3);\n        proxyMethods.put(sig, sigmethods);\n    }\n    sigmethods.add(new ProxyMethod(name, parameterTypes, returnType, exceptionTypes, fromClass));\n}\n```\n\n## `CGLIB`字节码代理\n\n示例\n\n```java\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\n\npublic class CGlibProxy {\n    public static void main(String[] args) {\n        //在指定目录下生成代理类的class文件\n        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, \"/Users/li/Downloads\");\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(Target.class);\n        enhancer.setCallback((MethodInterceptor) (target, method, objects, methodProxy) -> {\n            System.out.println(\"method : \" + method);\n            return methodProxy.invokeSuper(target, args);\n        });\n        Target target = (Target) enhancer.create();\n        target.log();\n    }\n\n}\n\npublic class Target {\n    public void log() {\n        System.out.println(\"target\");\n    }\n}\n```\n\n反编译生成的字节码\n\n```java\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by Fernflower decompiler)\n//\n\npackage com.li.springboot.aop;\n\nimport java.lang.reflect.Method;\nimport net.sf.cglib.core.ReflectUtils;\nimport net.sf.cglib.core.Signature;\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\npublic class Target$$EnhancerByCGLIB$$1d0dbdbc extends Target implements Factory {\n    private boolean CGLIB$BOUND;\n    public static Object CGLIB$FACTORY_DATA;\n    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;\n    private static final Callback[] CGLIB$STATIC_CALLBACKS;\n    private MethodInterceptor CGLIB$CALLBACK_0;\n    private static Object CGLIB$CALLBACK_FILTER;\n    private static final Method CGLIB$log$0$Method;\n    private static final MethodProxy CGLIB$log$0$Proxy;\n    private static final Object[] CGLIB$emptyArgs;\n    private static final Method CGLIB$equals$1$Method;\n    private static final MethodProxy CGLIB$equals$1$Proxy;\n    private static final Method CGLIB$toString$2$Method;\n    private static final MethodProxy CGLIB$toString$2$Proxy;\n    private static final Method CGLIB$hashCode$3$Method;\n    private static final MethodProxy CGLIB$hashCode$3$Proxy;\n    private static final Method CGLIB$clone$4$Method;\n    private static final MethodProxy CGLIB$clone$4$Proxy;\n\n    static void CGLIB$STATICHOOK1() {\n        CGLIB$THREAD_CALLBACKS = new ThreadLocal();\n        CGLIB$emptyArgs = new Object[0];\n        Class var0 = Class.forName(\"com.li.springboot.aop.Target$$EnhancerByCGLIB$$1d0dbdbc\");\n        Class var1;\n        Method[] var10000 = ReflectUtils.findMethods(new String[]{\"equals\", \"(Ljava/lang/Object;)Z\", \"toString\", \"()Ljava/lang/String;\", \"hashCode\", \"()I\", \"clone\", \"()Ljava/lang/Object;\"}, (var1 = Class.forName(\"java.lang.Object\")).getDeclaredMethods());\n        CGLIB$equals$1$Method = var10000[0];\n        CGLIB$equals$1$Proxy = MethodProxy.create(var1, var0, \"(Ljava/lang/Object;)Z\", \"equals\", \"CGLIB$equals$1\");\n        CGLIB$toString$2$Method = var10000[1];\n        CGLIB$toString$2$Proxy = MethodProxy.create(var1, var0, \"()Ljava/lang/String;\", \"toString\", \"CGLIB$toString$2\");\n        CGLIB$hashCode$3$Method = var10000[2];\n        CGLIB$hashCode$3$Proxy = MethodProxy.create(var1, var0, \"()I\", \"hashCode\", \"CGLIB$hashCode$3\");\n        CGLIB$clone$4$Method = var10000[3];\n        CGLIB$clone$4$Proxy = MethodProxy.create(var1, var0, \"()Ljava/lang/Object;\", \"clone\", \"CGLIB$clone$4\");\n        CGLIB$log$0$Method = ReflectUtils.findMethods(new String[]{\"log\", \"()V\"}, (var1 = Class.forName(\"com.li.springboot.aop.Target\")).getDeclaredMethods())[0];\n        CGLIB$log$0$Proxy = MethodProxy.create(var1, var0, \"()V\", \"log\", \"CGLIB$log$0\");\n    }\n\n    final void CGLIB$log$0() {\n        super.log();\n    }\n\n    public final void log() {\n        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;\n        if (var10000 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        if (var10000 != null) {\n            var10000.intercept(this, CGLIB$log$0$Method, CGLIB$emptyArgs, CGLIB$log$0$Proxy);\n        } else {\n            super.log();\n        }\n    }\n\n    final boolean CGLIB$equals$1(Object var1) {\n        return super.equals(var1);\n    }\n\n    public final boolean equals(Object var1) {\n        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;\n        if (var10000 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        if (var10000 != null) {\n            Object var2 = var10000.intercept(this, CGLIB$equals$1$Method, new Object[]{var1}, CGLIB$equals$1$Proxy);\n            return var2 == null ? false : (Boolean)var2;\n        } else {\n            return super.equals(var1);\n        }\n    }\n\n    final String CGLIB$toString$2() {\n        return super.toString();\n    }\n\n    public final String toString() {\n        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;\n        if (var10000 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        return var10000 != null ? (String)var10000.intercept(this, CGLIB$toString$2$Method, CGLIB$emptyArgs, CGLIB$toString$2$Proxy) : super.toString();\n    }\n\n    final int CGLIB$hashCode$3() {\n        return super.hashCode();\n    }\n\n    public final int hashCode() {\n        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;\n        if (var10000 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        if (var10000 != null) {\n            Object var1 = var10000.intercept(this, CGLIB$hashCode$3$Method, CGLIB$emptyArgs, CGLIB$hashCode$3$Proxy);\n            return var1 == null ? 0 : ((Number)var1).intValue();\n        } else {\n            return super.hashCode();\n        }\n    }\n\n    final Object CGLIB$clone$4() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    protected final Object clone() throws CloneNotSupportedException {\n        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;\n        if (var10000 == null) {\n            CGLIB$BIND_CALLBACKS(this);\n            var10000 = this.CGLIB$CALLBACK_0;\n        }\n\n        return var10000 != null ? var10000.intercept(this, CGLIB$clone$4$Method, CGLIB$emptyArgs, CGLIB$clone$4$Proxy) : super.clone();\n    }\n\n    public static MethodProxy CGLIB$findMethodProxy(Signature var0) {\n        String var10000 = var0.toString();\n        switch(var10000.hashCode()) {\n        case -1097399887:\n            if (var10000.equals(\"log()V\")) {\n                return CGLIB$log$0$Proxy;\n            }\n            break;\n        case -508378822:\n            if (var10000.equals(\"clone()Ljava/lang/Object;\")) {\n                return CGLIB$clone$4$Proxy;\n            }\n            break;\n        case 1826985398:\n            if (var10000.equals(\"equals(Ljava/lang/Object;)Z\")) {\n                return CGLIB$equals$1$Proxy;\n            }\n            break;\n        case 1913648695:\n            if (var10000.equals(\"toString()Ljava/lang/String;\")) {\n                return CGLIB$toString$2$Proxy;\n            }\n            break;\n        case 1984935277:\n            if (var10000.equals(\"hashCode()I\")) {\n                return CGLIB$hashCode$3$Proxy;\n            }\n        }\n\n        return null;\n    }\n\n    public Target$$EnhancerByCGLIB$$1d0dbdbc() {\n        CGLIB$BIND_CALLBACKS(this);\n    }\n\n    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {\n        CGLIB$THREAD_CALLBACKS.set(var0);\n    }\n\n    public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) {\n        CGLIB$STATIC_CALLBACKS = var0;\n    }\n\n    private static final void CGLIB$BIND_CALLBACKS(Object var0) {\n        Target$$EnhancerByCGLIB$$1d0dbdbc var1 = (Target$$EnhancerByCGLIB$$1d0dbdbc)var0;\n        if (!var1.CGLIB$BOUND) {\n            var1.CGLIB$BOUND = true;\n            Object var10000 = CGLIB$THREAD_CALLBACKS.get();\n            if (var10000 == null) {\n                var10000 = CGLIB$STATIC_CALLBACKS;\n                if (var10000 == null) {\n                    return;\n                }\n            }\n\n            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];\n        }\n\n    }\n\n    public Object newInstance(Callback[] var1) {\n        CGLIB$SET_THREAD_CALLBACKS(var1);\n        Target$$EnhancerByCGLIB$$1d0dbdbc var10000 = new Target$$EnhancerByCGLIB$$1d0dbdbc();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n        return var10000;\n    }\n\n    public Object newInstance(Callback var1) {\n        CGLIB$SET_THREAD_CALLBACKS(new Callback[]{var1});\n        Target$$EnhancerByCGLIB$$1d0dbdbc var10000 = new Target$$EnhancerByCGLIB$$1d0dbdbc();\n        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n        return var10000;\n    }\n\n    public Object newInstance(Class[] var1, Object[] var2, Callback[] var3) {\n        CGLIB$SET_THREAD_CALLBACKS(var3);\n        Target$$EnhancerByCGLIB$$1d0dbdbc var10000 = new Target$$EnhancerByCGLIB$$1d0dbdbc;\n        switch(var1.length) {\n        case 0:\n            var10000.<init>();\n            CGLIB$SET_THREAD_CALLBACKS((Callback[])null);\n            return var10000;\n        default:\n            throw new IllegalArgumentException(\"Constructor not found\");\n        }\n    }\n\n    public Callback getCallback(int var1) {\n        CGLIB$BIND_CALLBACKS(this);\n        MethodInterceptor var10000;\n        switch(var1) {\n        case 0:\n            var10000 = this.CGLIB$CALLBACK_0;\n            break;\n        default:\n            var10000 = null;\n        }\n\n        return var10000;\n    }\n\n    public void setCallback(int var1, Callback var2) {\n        switch(var1) {\n        case 0:\n            this.CGLIB$CALLBACK_0 = (MethodInterceptor)var2;\n        default:\n        }\n    }\n\n    public Callback[] getCallbacks() {\n        CGLIB$BIND_CALLBACKS(this);\n        return new Callback[]{this.CGLIB$CALLBACK_0};\n    }\n\n    public void setCallbacks(Callback[] var1) {\n        this.CGLIB$CALLBACK_0 = (MethodInterceptor)var1[0];\n    }\n\n    static {\n        CGLIB$STATICHOOK1();\n    }\n}\n\n```\n\n具体实现细节类似`JDK`动态代理，通过某种方式生成字节码文件。\n\n## `Spring`使用`AOP`\n\n通过`BeanPostProcessor`返回动态代理的`bean`,\n\n```java\n@Component\npublic class Target {\n    public void log() {\n        System.out.println(\"target\");\n    }\n}\n```\n\n```java\n@Component\npublic class AOPBeanPostProcessor implements BeanPostProcessor {\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        System.out.println(\"bean = \" + bean);\n        if(bean instanceof  Target){\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(bean.getClass());\n        enhancer.setCallback((MethodInterceptor) (target, method, args, methodProxy) -> {\n            System.out.println(\"BeanPostProcessor\");\n            return methodProxy.invokeSuper(target, args);\n        });\n        return enhancer.create();\n        }\n        return bean;\n    }\n}\n```\n","categories":["java"],"tags":["spring","aop"]},{"title":"redis","url":"/2019/09/02/redis/","content":"\n1. {% post_link redis集群 %}\n2. {% post_link redis管道 %}\n3. {% post_link redis发布订阅 %}\n4. {% post_link redis-script %}\n5. {% post_link redis-过期时间 %}\n6. {% post_link redis事务 %}\n7. {% post_link redis-清除策略 %}\n8. {% post_link redis-分区 %}\n9. {% post_link redis-主从复制 %}\n10. {% post_link redis-持久化 %}\n\n## 安装\n\n在 centos 上使用 yum 安装\n\n```shell\n# 安装源\nsudo yum install epel-release yum-utils\nsudo yum install http://rpms.remirepo.net/enterprise/remi-release-7.rpm\nsudo yum-config-manager --enable remi\n\nsudo yum install redis\n\n\n```\n\n## 单点启动\n\n```shell\nsudo systemctl start redis\nsudo systemctl enable redis\n\n\n# 查看启动状态\nsudo systemctl status redis\n```\n\n**_可通过查看 redis 日志来查看启动过程或者运行过程中的各种问题_**\n\n日志开启需要在`redis.conf`配置\n\n```conf\nlogfile /var/log/redis/redis.log\n```\n\n## 配置\n\n在 redis 客户端可以使用`config set`设定临时配置，该配置仅临时有效，可通过`config rewrite`将临时配置写入到`redis.conf`中使其永久有效\n\n1. maxmemory 设定最大内存使用\n\n   ```conf\n   # 设置为5m\n   maxmemory 5m\n   ```\n\n2. maxmemory_policy 过期策略\n\n## 使用\n\nredis 的备份文件 dump.db 在启动 redis-server 的目录下直接生成\n\n使用`shell`执行`redis`命令\n\n```shell\necho keys '*'|redis-cli -h '127.0.0.1' -p 6379 -a 'password'\n\n# 逐行批量执行\ncat commands.txt|redis-cli -h '127.0.0.1' -p 6379 -a 'password'\n\n```\n\n查询所有`key`，以及过期时间,省略`ip`，端口，密码\n\n```shell\necho keys '*' |redis-cli |awk '{print \"echo -n \"$1\" && echo ttl \" $1 \" |redis-cli\"}'|sh\n```\n\n## 布隆过滤器\n\n本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。\n\n相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。\n\n布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：\n![redis_2020-05-08-13-46-02.png](./images/redis_2020-05-08-13-46-02.png)\n如果我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1，比如针对值`geeks`进行三个 hash 函数分布生成 hash 值 1,4,7,则上图变成如下\n![redis_2020-05-08-13-46-53.png](./images/redis_2020-05-08-13-46-53.png)\n而当我们需要查询 `geeks` 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 `geeks` 存在了么？答案是不可以，只能是 `geeks` 这个值可能存在。\n传统的布隆过滤器并不支持删除操作。\n\n如何选择哈希函数个数和布隆过滤器长度\n\n很显然，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。\n\n另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。\n\nRedis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。\n\n拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。\n\n## 问题集锦\n\n### 访问`redis`集群\n\n访问集群报错\n\n> Connection refused: /127.0.0.1:7000\n\n需要对 redis 集群配置对外访问的 ip 地址，更改每个节点下的`redis.conf`配置，修改或增加配置\n\n```conf\nbind  xxx.xxx.xxx.xxx\n```\n\n### `del`的相关问题\n\n在使用`redis-cli`连接`redis`集群，进行数据操作时，有报错\n\n> (error) MOVED 5798 192.24.54.2:6379\n\n这种情况一般是因为启动`redis-cli`时没有设置集群模式所导致。启动时使用`-c`参数来启动集群模式，命令如下：\n\n```shell\nredis-cli -c\n```\n\n### 启动时没有启动成功\n\n> (error) CLUSTERDOWN Hash slot not served\n\n需要重新分配 `hash槽`\n\n### 重启时\n\n> Node 127.0.0.1:7000 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.\n\n因为`hash槽`已经分配过了，无需重新分配。若要重新分配，将每个节点对应的`node.conf`删除掉再重新执行即可。\n","categories":["db"],"tags":["redis"]},{"title":"log4j相关","url":"/2019/08/27/log4j%E7%9B%B8%E5%85%B3/","content":"\n## DEBUG 模式运行\n\n`log4j`的配置文件中配置`log4j.debug=true`即可开启\n\n## 概述\n\n`log4j`的`looger`是层级结构的，例如`com.li`是`com.li.springboot`的父类`logger`  \n可使用如下方式取出`logger`\n\n```java\npackage com.li.springboot.advice.log4j;\n\n\nimport org.apache.log4j.Logger;\n\npublic class LevelTest {\n    Logger logger= Logger.getLogger(LevelTest.class);\n    Logger logger= Logger.getLogger(\"com.li.springboot.advice.log4j.LevelTest\");\n}\n\n```\n\n`getLogger`根据参数`name`，在任意处取出的`logger`都是同一个\n`root logger`是所有`logger`的父类，一定存在但是它不能直接使用`getLogger`通过`name`取出。可使用如下方式取出\n\n```java\nLogger.getRootLogger()\n```\n\n可使用的日志级别`org.apache.log4j.Level`\n\n> `TRACE`,`DEBUG`,`INFO`,`WARN`,`ERROR` and `FATAL`\n\n当指定`name`的`logger`日志请求时，同时会将该请求转发至父类`logger`\n当`logger`没有对应的配置时，会找最近的父类配置，默认情况下`logger`配置会继承父类的配置，可通过设置`log4j.additivity.xxx=false`使其不继承(xxx 是 logger 的 name)\n\n## 配置\n\n1. 初始化 Logger 容器 Hierarchy,设置根节点为 RootLogger\n\n2. 初始 LoggerRepositorySelector(容器选择器)为默认的 DefaultRepositorySelector,容器为 Hierarchy\n\n3. 读取系统属性 log4j.defaultInitOverride,如果没有设置或者为 false 进行初始化,否则跳过初始化\n\n4. 读取系统属性 log4j.configuration(log4j 文件路径配置),如果存在对应的文件,则得到 URL.如果没有对应的文件,首先检查是否存在 log4j.xml 文件,如果存在,得到 Log4j 配置文件 URL,如果不存在 log4j.xml,继续检查是否存在 log4j.properties 文件,如果存在该文件,得到 log4j 配置文件的 URL,否则提示没有发现配置文件。\n\n5. 读取系统属性 log4j.configuratorClass(自定义 Configurator 配置类全路径,一般不自定义)\n\n6. 调用 OptionConverter.selectAndConfigure(url, configuratorClassName,LogManager.getLoggerRepository()),初始化 logger 容器\n\n### 扩展配置\n\n可使用`BasicConfigurator.resetConfiguration()`重置配置\n可使用`PropertyConfigurator.configure`指定其他配置文件\n\n### `tomcat`下的`log4j`\n\n当`log4j`的`jar`包在`tomcat`目录下的时候，使用`BasicConfigurator.resetConfiguration()`重置配置时，会修改`tomcat`下所有应用的日志打印，一般情况下\n我们在主应用里做配置，忽略其他应用的配置即可。但是当你发布其他应用时，触发`log4j`的初始化配置，则会影响到主应用，可能造成主应用日志不打印。这个时候我们通过`HierarchyEventListener`来监听`log4j`的配置是否被修改，来在其他应用重置配置时，重新触发主应用的配置加载过程即可。\n\n```java\nstatic {\n    Logger.getRootLogger().getLoggerRepository().addHierarchyEventListener(new HierarchyEventListener() {\n        @Override\n        public void addAppenderEvent(Category cat, Appender appender) {\n            LogLog.debug(\"add \" + cat.getName() + \"  \" + appender);\n            flag = false;\n        }\n        @Override\n        public void removeAppenderEvent(Category cat, Appender appender) {\n            //log4j配置被移除前的回调，此时配置还是生效的，所以这里重新加载是无效的，回调后就\n            //被重置了，所以需要在外面去重新加载，这里仅打一个标记\n            LogLog.debug(\"remove \" + cat.getName() + \"  \" + appender);\n            flag = true;\n        }\n    });\n}\n\npublic static void initLog4j() {\n    BasicConfigurator.resetConfiguration();\n    Properties properties = new Properties();\n    try {\n        properties.load(ClassLoader.getSystemResourceAsStream(\"mylog4j.properties\"));\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    PropertyConfigurator.configure(properties);\n}\n\nfor (int i = 0; i < cycle; i++) {\n    Thread.sleep(RandomUtils.nextInt(500, 1500));\n        if (flag) {\n            initLog4j();\n        }\n    logger.debug(\"123\");\n}\n```\n\n### `MDC`\n\n打造日志链路，`MDC`类似`ThreadLocal`类，根据线程存入一些数据，以供打印日志的时候输出(`%X{name}`)\n\n```java\nMDC.clear();\nMDC.put(\"session\", \"xxxx\");\n\n```\n\n```properties\nlog4j.appender.consoleAppender.layout.ConversionPattern=%X{session}}%m%n\n```\n","categories":["java"],"tags":["log4j"]},{"title":"spring循环依赖","url":"/2019/08/26/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/","content":"\n## 概述\n\n一般只应用于单例模式,主要原理是将 bean 先缓存在 beanfactory,`prototype`无法解决循环依赖问题。\n示例代码\n\n```java\n@Component\n@Order(Ordered.HIGHEST_PRECEDENCE)\npublic class A {\n\n    @Autowired\n    B b;\n\n    public A() {\n        System.out.println(\"-------------A------------------\");\n    }\n    @PostConstruct\n    public void log(){\n\n        System.out.println(\"-------------B PostConstruct------------------\");\n    }\n}\n\n@Component\npublic class B {\n\n    @Autowired\n    A a;\n    public B() {\n        System.out.println(\"-------------A------------------\");\n    }\n    @PostConstruct\n    public void log(){\n\n        System.out.println(\"-------------B PostConstruct------------------\");\n    }\n}\n\n```\n\n`getBean(A)`->`instance(A)`->`autowired(B)`->`getBean(B)`->`instance(B)`->`autowired(A)`->循环依赖\n\n解决方案： 1.`A`首先调用构造函数`newInstance`，此时`A`的引用值已确定\n\n2.  将`A`的引用缓存，创建`B`时直接使用缓存的`A`的引用\n\n则实际实例化过程大致如下：\n\n`getBean(A)`->`instance(A)`->`cache reference(A)`->`autowired(B)`->`getBean(B)`->`instance(B)`->`autowired(A)`->`get reference(A)`->`postConstruct(B)`->`postConstruct(A)`\n\n## 源码分析\n\n以`AnnotationConfigApplicationContext`的加载来举例\n\n`AppConfig`为配置类，不重要\n\n```java\nAnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n```\n\n省略其他过程直接看刷新\n\n```java\npublic AnnotationConfigApplicationContext(Class<?>... annotatedClasses) {\n    this();\n    register(annotatedClasses);\n    refresh();\n}\n```\n\n省略扫描过程，直接看 bean 加载的过程\n\n```java\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized (this.startupShutdownMonitor) {\n        // Prepare this context for refreshing.\n        prepareRefresh();\n\n        // Tell the subclass to refresh the internal bean factory.\n        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n        // Prepare the bean factory for use in this context.\n        prepareBeanFactory(beanFactory);\n\n        try {\n            // Allows post-processing of the bean factory in context subclasses.\n            postProcessBeanFactory(beanFactory);\n\n            // Invoke factory processors registered as beans in the context.\n            invokeBeanFactoryPostProcessors(beanFactory);\n\n            // Register bean processors that intercept bean creation.\n            registerBeanPostProcessors(beanFactory);\n\n            // Initialize message source for this context.\n            initMessageSource();\n\n            // Initialize event multicaster for this context.\n            initApplicationEventMulticaster();\n\n            // Initialize other special beans in specific context subclasses.\n            onRefresh();\n\n            // Check for listener beans and register them.\n            registerListeners();\n\n            // 加载所有单例非懒加载的bean\n            finishBeanFactoryInitialization(beanFactory);\n\n            // Last step: publish corresponding event.\n            finishRefresh();\n        }\n```\n\n```java\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n    // Initialize conversion service for this context.\n    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\n            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n        beanFactory.setConversionService(\n                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n    }\n\n    // Register a default embedded value resolver if no bean post-processor\n    // (such as a PropertyPlaceholderConfigurer bean) registered any before:\n    // at this point, primarily for resolution in annotation attribute values.\n    if (!beanFactory.hasEmbeddedValueResolver()) {\n        beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));\n    }\n\n    // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.\n    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\n    for (String weaverAwareName : weaverAwareNames) {\n        getBean(weaverAwareName);\n    }\n\n    // Stop using the temporary ClassLoader for type matching.\n    beanFactory.setTempClassLoader(null);\n\n    // Allow for caching all bean definition metadata, not expecting further changes.\n    beanFactory.freezeConfiguration();\n\n    // 通过debug，一般情况下使用DefaultListableBeanFactory类\n    beanFactory.preInstantiateSingletons();\n}\n```\n\n`DefaultListableBeanFactory`类`preInstantiateSingletons`代码片段\n\n```java\nfor (String beanName : beanNames) {\n    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n    //非抽象类，单例，非延迟加载\n    if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n        if (isFactoryBean(beanName)) {\n            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);\n            if (bean instanceof FactoryBean) {\n                final FactoryBean<?> factory = (FactoryBean<?>) bean;\n                boolean isEagerInit;\n                if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n                    isEagerInit = AccessController.doPrivileged((PrivilegedAction<Boolean>)\n                                    ((SmartFactoryBean<?>) factory)::isEagerInit,\n                            getAccessControlContext());\n                }\n                else {\n                    isEagerInit = (factory instanceof SmartFactoryBean &&\n                            ((SmartFactoryBean<?>) factory).isEagerInit());\n                }\n                if (isEagerInit) {\n                    getBean(beanName);\n                }\n            }\n        }\n        else {\n            getBean(beanName);\n        }\n    }\n}\n```\n\n通过`getBean`方法可以追踪到`org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)`,然后\n`org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean`\n\n```java\nprotected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,\n                            @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException\n\n    final String beanName = transformedBeanName(name);\n    Object bean;\n\n    //  单例的bean通过该方法获取\n    Object sharedInstance = getSingleton(beanName);\n```\n\n`DefaultSingletonBeanRegistry`\n\n```java\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);\n\npublic Object getSingleton(String beanName) {\n    return getSingleton(beanName, true);\n}\n\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n    //我们可以清晰的看到singleton的bean简单的bean存储在ConcurrentHashMap中\n    Object singletonObject = this.singletonObjects.get(beanName);\n    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n        synchronized (this.singletonObjects) {\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            if (singletonObject == null && allowEarlyReference) {\n                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n                    singletonObject = singletonFactory.getObject();\n                    this.earlySingletonObjects.put(beanName, singletonObject);\n                    this.singletonFactories.remove(beanName);\n                }\n            }\n        }\n    }\n    return singletonObject;\n}\n```\n\n首次创建`A`时，`singletonObject`肯定为`null`,`isSingletonCurrentlyInCreation`的代码很简单\n\n```java\npublic boolean isSingletonCurrentlyInCreation(String beanName) {\n    return this.singletonsCurrentlyInCreation.contains(beanName);\n}\n```\n\n我们只需要了解`singletonsCurrentlyInCreation`是何时被`add`，通过查看调用关系，最终可以发现`org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean`中\n\n```java\nif (mbd.isSingleton()) {\n    //getSingleton代码里调用beforeSingletonCreation方法将beanName加入singletonsCurrentlyInCreation\n    //lambda表达式createBean则创建bean\n    sharedInstance = getSingleton(beanName, () -> {\n        try {\n            return createBean(beanName, mbd, args);\n        } catch (BeansException ex) {\n            destroySingleton(beanName);\n            throw ex;\n        }\n    });\n    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n}\n```\n\n继续回到`A`的创建，在`getSingleton`中未取到缓存是，`A`尝试`createBean`，也就是上述代码部分。\n追踪调用关系可以知道最终调用`org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])`后进入`org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean`\n\n节选片段\n\n```java\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n        throws BeanCreationException {\n\n    // 初始化bean\n    BeanWrapper instanceWrapper = null;\n    if (mbd.isSingleton()) {\n        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n    }\n    if (instanceWrapper == null) {\n        instanceWrapper = createBeanInstance(beanName, mbd, args);\n    }\n    final Object bean = instanceWrapper.getWrappedInstance();\n    Class<?> beanType = instanceWrapper.getWrappedClass();\n    if (beanType != NullBean.class) {\n        mbd.resolvedTargetType = beanType;\n    }\n\n    // Allow post-processors to modify the merged bean definition.\n    synchronized (mbd.postProcessingLock) {\n        if (!mbd.postProcessed) {\n            try {\n                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n            }\n            catch (Throwable ex) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"Post-processing of merged bean definition failed\", ex);\n            }\n            mbd.postProcessed = true;\n        }\n    }\n\n    boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n            isSingletonCurrentlyInCreation(beanName));\n    if (earlySingletonExposure) {\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Eagerly caching bean '\" + beanName +\n                    \"' to allow for resolving potential circular references\");\n        }\n        //将bean的引用缓存\n        addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n    }\n...\n```\n\n我们查看下`addSingletonFactory`的细节\n\n```java\nprotected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {\n    Assert.notNull(singletonFactory, \"Singleton factory must not be null\");\n    synchronized (this.singletonObjects) {\n        if (!this.singletonObjects.containsKey(beanName)) {\n            //根据beanName缓存可以取出bean的lambda中\n            this.singletonFactories.put(beanName, singletonFactory);\n            this.earlySingletonObjects.remove(beanName);\n            this.registeredSingletons.add(beanName);\n        }\n    }\n}\n```\n\n到这里`bean`通过构造器创建实例的过程结束了，但是`bean`在`spring`容器中的生命周期还未结束，后续发现`A`依赖`B`，则会去创建`B`，`B`在实例化后加载依赖时，会去创建`A`,不同的是在调用`DefaultSingletonBeanRegistry`的`getSingleton`时判断条件`isSingletonCurrentlyInCreation`时`A`已在创建过程中，那么就会去执行\n\n```java\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n    //我们可以清晰的看到singleton的bean简单的bean存储在ConcurrentHashMap中\n    Object singletonObject = this.singletonObjects.get(beanName);\n    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n        synchronized (this.singletonObjects) {\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            if (singletonObject == null && allowEarlyReference) {\n                //根据前面的分析我们知道A的引用被缓存在此处。\n                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n                    singletonObject = singletonFactory.getObject();\n                    this.earlySingletonObjects.put(beanName, singletonObject);\n                    this.singletonFactories.remove(beanName);\n                }\n            }\n        }\n    }\n    return singletonObject;\n}\n```\n\n此时`B`顺利完成整个`Spring`生命周期，从而`A`也完成了整个生命周期\n","categories":["spring"],"tags":["spring","源码"]},{"title":"spring-ioc 源码","url":"/2019/08/26/spring-ioc-%E6%BA%90%E7%A0%81/","content":"\n## `BeanDefinition`\n\n`BeanDefinition`是`Spring`用来定义一个类的元数据，它定义了\n\n    1. 如何创建一个`Bean`\n\n    2. `Bean`的生命周期\n\n    3. `Bean`的依赖关系\n\n详细属性值如下图所示：\n\n![BeanDefinition](./images/spring-ioc-源码_BeanDefinition.png)\n\n`Spring`在扫描类后将类的`BeanDefiniton`元数据存储在`BeanFactory`中，当需要时，`BeanFactory`根据`BeanDefinition`信息生成`Bean`\n","categories":["spring"],"tags":["源码","ioc"]},{"title":"Spring上传文件","url":"/2019/08/21/Spring%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/","content":"\n## MultipartResolver\n\n`DispatcherServlet`用于处理所有请求\b，\b`doDispatch`方法中会判断请求参数中是否包含文件。\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null;\n    boolean multipartRequestParsed = false;\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n    try {\n        ModelAndView mv = null;\n        Exception dispatchException = null;\n\n        try {\n            processedRequest = checkMultipart(request);\n            multipartRequestParsed = (processedRequest != request);\n\n            // Determine handler for the current request.\n            mappedHandler = getHandler(processedRequest);\n            if (mappedHandler == null) {\n                noHandlerFound(processedRequest, response);\n                return;\n            }\n\n    ...\n}\n```\n\n查看`checkMultipart`细节\n\n```java\nprotected HttpServletRequest checkMultipart(HttpServletRequest request) throws MultipartException {\n    if (this.multipartResolver != null && this.multipartResolver.isMultipart(request)) {\n        if (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) != null) {\n            if (request.getDispatcherType().equals(DispatcherType.REQUEST)) {\n                logger.trace(\"Request already resolved to MultipartHttpServletRequest, e.g. by MultipartFilter\");\n            }\n        }\n        else if (hasMultipartException(request)) {\n            logger.debug(\"Multipart resolution previously failed for current request - \" +\n                    \"skipping re-resolution for undisturbed error rendering\");\n        }\n        else {\n            try {\n                return this.multipartResolver.resolveMultipart(request);\n            }\n            catch (MultipartException ex) {\n                if (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != null) {\n                    logger.debug(\"Multipart resolution failed for error dispatch\", ex);\n                    // Keep processing error dispatch with regular request handle below\n                }\n                else {\n                    throw ex;\n                }\n            }\n        }\n    }\n    // If not returned before: return original request.\n    return request;\n}\n```\n\n首先我们了解下`this.multipartResolver`是如何被加载的\n\n我们可以看到`DispatcherServlet`的方法中有初始化\n\n```java\nprivate void initMultipartResolver(ApplicationContext context) {\n    try {\n        this.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Detected \" + this.multipartResolver);\n        }\n        else if (logger.isDebugEnabled()) {\n            logger.debug(\"Detected \" + this.multipartResolver.getClass().getSimpleName());\n        }\n    }\n    catch (NoSuchBeanDefinitionException ex) {\n        // Default is no multipart resolver.\n        this.multipartResolver = null;\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"No MultipartResolver '\" + MULTIPART_RESOLVER_BEAN_NAME + \"' declared\");\n        }\n    }\n}\n```\n\n通过查看`MultipartResolver`的实现类，我们可以看到如下两个实现类\n\n1. `CommonsMultipartResolver`\n2. `StandardServletMultipartResolver`\n\n其中`StandardServletMultipartResolver`在下述自动配置类中有被加载\n\n```java\npackage org.springframework.boot.autoconfigure.web.servlet;\n\nimport javax.servlet.MultipartConfigElement;\nimport javax.servlet.Servlet;\n\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.multipart.MultipartResolver;\nimport org.springframework.web.multipart.commons.CommonsMultipartResolver;\nimport org.springframework.web.multipart.support.StandardServletMultipartResolver;\nimport org.springframework.web.servlet.DispatcherServlet;\n\n@Configuration\n@ConditionalOnClass({ Servlet.class, StandardServletMultipartResolver.class, MultipartConfigElement.class })\n@ConditionalOnProperty(prefix = \"spring.servlet.multipart\", name = \"enabled\", matchIfMissing = true)\n@ConditionalOnWebApplication(type = Type.SERVLET)\n@EnableConfigurationProperties(MultipartProperties.class)\npublic class MultipartAutoConfiguration {\n\nprivate final MultipartProperties multipartProperties;\n\n    public MultipartAutoConfiguration(MultipartProperties multipartProperties) {\n        this.multipartProperties = multipartProperties;\n    }\n\n    @Bean\n    @ConditionalOnMissingBean({ MultipartConfigElement.class, CommonsMultipartResolver.class })\n    public MultipartConfigElement multipartConfigElement() {\n        return this.multipartProperties.createMultipartConfig();\n    }\n\n    @Bean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)\n    @ConditionalOnMissingBean(MultipartResolver.class)\n    public StandardServletMultipartResolver multipartResolver() {\n        StandardServletMultipartResolver multipartResolver = new StandardServletMultipartResolver();\n        multipartResolver.setResolveLazily(this.multipartProperties.isResolveLazily());\n        return multipartResolver;\n    }\n\n}\n\n```\n\n可以看出若没有指定`MultipartResolver`时，会默认加载`StandardServletMultipartResolver`。我们查看其`isMultipart`放过可知\n当请求`ContentType`类型以`multipart/`则会认为是文件上传操作。\n\n```java\n@Override\npublic boolean isMultipart(HttpServletRequest request) {\n    return StringUtils.startsWithIgnoreCase(request.getContentType(), \"multipart/\");\n}\n```\n\n## 解决上传文件大小限制\n\n同时我们也可以得出，若没有指定的`MultipartConfigElement`时，会使用默认的`this.multipartProperties.createMultipartConfig()`\n\n通过查看`this.multipartProperties`\n\n```java\n@ConfigurationProperties(prefix = \"spring.servlet.multipart\", ignoreUnknownFields = false)\npublic class MultipartProperties {\n    ...\n}\n```\n\n`MultipartProperties`被自动`EnableConfigurationProperties`所引用\n\n```java\n@Configuration\n@ConditionalOnClass({ Servlet.class, StandardServletMultipartResolver.class, MultipartConfigElement.class })\n@ConditionalOnProperty(prefix = \"spring.servlet.multipart\", name = \"enabled\", matchIfMissing = true)\n@ConditionalOnWebApplication(type = Type.SERVLET)\n@EnableConfigurationProperties(MultipartProperties.class)\npublic class MultipartAutoConfiguration {\n}\n```\n\n则可通过修改对应`SpringBoot`可以配置`application.yml`\n\n```yaml\nspring:\n  servlet:\n    multipart:\n      max-file-size: 150MB\n      max-request-size: 150MB\n```\n\n## `EnableConfigurationProperties`原理\n\n通过查看注解`EnableConfigurationProperties`被调用处，即查找`EnableConfigurationProperties.class`出现处。我们可以看到在`EnableConfigurationPropertiesImportSelector`的方法\n\n```java\nprivate List<Class<?>> getTypes(AnnotationMetadata metadata) {\n        MultiValueMap<String, Object> attributes = metadata\n                .getAllAnnotationAttributes(EnableConfigurationProperties.class.getName(), false);\n        return collectClasses((attributes != null) ? attributes.get(\"value\") : Collections.emptyList());\n    }\n```\n\n所有注解了`EnableConfigurationProperties`的类被自动注入到容器中了。\n\n```java\n@Override\npublic void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n    getTypes(metadata).forEach((type) -> register(registry, (ConfigurableListableBeanFactory) registry, type));\n}\n```\n\n```java\nprivate void register(BeanDefinitionRegistry registry, ConfigurableListableBeanFactory beanFactory,\n            Class<?> type) {\n        String name = getName(type);\n        if (!containsBeanDefinition(beanFactory, name)) {\n            registerBeanDefinition(registry, name, type);\n        }\n    }\n\n```\n\n一步一步回溯可以最终可以看到被`AbstractApplicationContext`的`refresh`方法调用。\n","categories":["spring"],"tags":["上传文件","resttemplate","EnableConfigurationProperties"]},{"title":"静态内部类的泛型与建造者模式","url":"/2019/08/20/%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","content":"\n静态内部类的泛型和外部类的泛型没有任何关系，即使使用同一个字母。\n\n```java\npackage com.li.springboot.bean;\n\nimport java.util.List;\n\npublic class LayuiResponse<T> {\n\n    private final int code;\n    private final String msg;\n    private final List<T> data;\n    private final Integer count;\n\n    public int getCode() {\n        return code;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n\n    public List<T> getData() {\n        return data;\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    public static <T> Builder<T> builder() {\n        return new Builder<T>();\n    }\n\n    private LayuiResponse(Builder<T> builder) {\n        this.code = builder.code;\n        this.msg = builder.msg;\n        this.data = builder.data;\n        this.count = builder.count;\n    }\n\n    public static class Builder<R> {\n        private int code;\n        private String msg;\n        private List<R> data;\n        private Integer count;\n\n        public Builder<R> code(int code) {\n            this.code = code;\n            return this;\n        }\n\n        public Builder<R> msg(String msg) {\n            this.msg = msg;\n            return this;\n        }\n\n        public Builder<R> data(List<R> data) {\n            this.data = data;\n            return this;\n        }\n\n        public Builder<R> count(int count) {\n            this.count = count;\n            return this;\n        }\n\n        public LayuiResponse<R> build() {\n            return new LayuiResponse<>(this);\n        }\n    }\n}\n\n```\n\n使用时，需指定内部类的泛型\n\n```java\n List<String> list = new ArrayList<>();\nlist.add(\"123\");\nLayuiResponse<String> ok = LayuiResponse.<String>builder().code(0).msg(\"ok\").data(list).build();\n```\n\n使用构造器模式，主要是为了使属性在构建时一次性初始化好，不允许中间过程去设置属性，保持`bean`的状态一致性。同时也是为了清晰化构建过程。推荐使用`final`来修饰被构建对象的属性值，\n确保成员属性不会被赋值。\n","categories":["设计模式"],"tags":["build","generic"]},{"title":"SpringBoot自定义扫描器","url":"/2019/08/18/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%AB%E6%8F%8F%E5%99%A8/","content":"\n实现自定义注解扫描器，将被`JsonBean`注解的类，注入到`spring`容器中，当由`spring`生成时，自动根据对应的`json`文件自动生成。\n\n首先是两个注解\n\n```java\n\nimport java.lang.annotation.*;\n\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface JsonBean {\n    String value();\n}\n\n\n\nimport com.li.ivr.test.scanner.JsonBeanRegistrar;\nimport org.springframework.context.annotation.Import;\n\nimport java.lang.annotation.*;\n\n@Target( ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(JsonBeanRegistrar.class)\npublic @interface JsonBeanScanner {\n    String value();\n}\n\n```\n\n被注解类\n\n```java\npackage com.li.ivr.test.expression;\n\n\nimport com.li.ivr.test.annotation.JsonBean;\n\nimport java.util.Map;\n\n@JsonBean(\"/data.json\")\npublic class Session {\n\n    private Map<String,?> avaya;\n\n    public Map<String, ?> getAvaya() {\n        return avaya;\n    }\n\n    public void setAvaya(Map<String, ?> avaya) {\n        this.avaya = avaya;\n    }\n\n    @Override\n    public String toString() {\n        return \"Session{\" +\n            \"avaya=\" + avaya +\n            '}';\n    }\n}\n\n```\n\n核心代码,即`JsonBeanScanner`中`import`的类`JsonBeanRegistrar`\n\n```java\npackage com.li.ivr.test.scanner;\n\nimport com.li.ivr.test.advise.ProxyFactoryBean;\nimport com.li.ivr.test.annotation.JsonBean;\nimport com.li.ivr.test.annotation.JsonBeanScanner;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;\nimport org.springframework.context.annotation.ImportBeanDefinitionRegistrar;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.core.type.filter.AnnotationTypeFilter;\n\nimport java.util.Objects;\n\npublic class JsonBeanRegistrar implements ImportBeanDefinitionRegistrar {\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n        String path =\n            (String) Objects.requireNonNull(importingClassMetadata.getAnnotationAttributes(JsonBeanScanner.class.getName())).get(\n                \"value\");\n        createComponentScanner().findCandidateComponents(path).forEach(beanDefinition -> {\n            beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(Objects.requireNonNull(beanDefinition.getBeanClassName()));\n            beanDefinition.setBeanClassName(ProxyFactoryBean.class.getName());\n            registry.registerBeanDefinition(Objects.requireNonNull(beanDefinition.getBeanClassName()), beanDefinition);\n        });\n\n    }\n\n    private ClassPathScanningCandidateComponentProvider createComponentScanner() {\n        // Don't pull default filters (@Component, etc.):\n        ClassPathScanningCandidateComponentProvider provider\n            = new ClassPathScanningCandidateComponentProvider(false);\n        provider.addIncludeFilter(new AnnotationTypeFilter(JsonBean.class));\n        return provider;\n    }\n}\n\n```\n\n其中`ProxyFactoryBean`为生成`bean`的工厂类，代码如下\n\n```java\npackage com.li.ivr.test.advise;\n\nimport com.google.gson.Gson;\nimport com.li.ivr.test.annotation.JsonBean;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.util.StreamUtils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\npublic class ProxyFactoryBean<T> implements FactoryBean {\n    private Class<T> interfaceClass;\n\n    public ProxyFactoryBean(Class<T> interfaceClass) {\n        this.interfaceClass = interfaceClass;\n    }\n\n    @Override\n    public T getObject() throws IOException {\n        JsonBean annotation = interfaceClass.getAnnotation(JsonBean.class);\n        InputStream in = ProxyFactoryBean.class.getResourceAsStream(annotation.value());\n        String json = StreamUtils.copyToString(in, StandardCharsets.UTF_8);\n        return new Gson().fromJson(json, interfaceClass);\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return interfaceClass;\n    }\n}\n```\n\n我们在任意配置类中设置扫描路径即可\n\n```java\n@@Configuration\n@JsonBeanScanner(\"com.li\")\npublic class Application {\n}\n```\n","categories":["spring"],"tags":["scanner","自定义扫描器"]},{"title":"java中使用js","url":"/2019/08/18/java%E4%B8%AD%E4%BD%BF%E7%94%A8js/","content":"\n\n## 背景\n\n使用`SpringBoot`构建的项目\n\n注入`js`代码\n\n```js\nfunction objectToString(obj) {\n  try {\n    var result = \"\";\n    result += getobjectprops(\"\", obj);\n    if (result.charAt(0) == '|') {\n      result = result.substring(1);\n    }\n  } catch (errMsg) {\n    return (\"undefined\");\n  }\n  return result;\n}\n\nfunction getArray(arrayName, item) {\n  try {\n    var len = eval(arrayName + '.length;');\n    var result = \"\";\n    for (var i = 0; i < len; i++) {\n      if (i > 0) {\n        result += \" |\";\n      }\n      var temp = arrayName + \"[\" + i + \"].\" + item;\n      result += eval(temp);\n    }\n    return result;\n  } catch (errMsg) {\n    return ('unknown');\n  }\n}\n\nfunction getRedirect(item) {\n  return (getArray('session.connection.redirect', item));\n}\n\nf\n```\n\n```java\npackage com.li.ivr.test.expression;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.core.io.Resource;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StreamUtils;\n\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\n/**\n *\n */\n@Component\npublic class JS {\n\n    @Value(\"classpath:rootxml.js\")\n    private Resource js;\n\n    @Bean\n    public ScriptEngine scriptEngine() throws IOException, ScriptException {\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"javascript\");\n        engine.eval(StreamUtils.copyToString(js.getInputStream(), StandardCharsets.UTF_8));\n        return engine;\n    }\n}\n\n```\n\n测试\n\n```java\npackage com.li.ivr.test.expression;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptException;\nimport java.io.IOException;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest\npublic class JSTest {\n\n    @Autowired\n    ScriptEngine js;\n\n    @Test\n    public void test() throws ScriptException, IOException {\n        Object eval = js.eval(\"objectToString(1)\");\n        System.out.println(eval);\n    }\n}\n```\n","categories":["java"],"tags":["js"]},{"title":"gradle入门","url":"/2019/08/18/gradle%E5%85%A5%E9%97%A8/","content":"\n## 刷新依赖\n\n```shell\ngradle build --refresh-dependencies\n```\n","categories":["java"],"tags":["build","gradle"]},{"title":"vim","url":"/2019/08/11/vim/","content":"\nc 与 d 命令功能类似，c 会进入插入模式\n\n`%`  \n匹配对应的括号  \n`(`  \n光标移至句首,)反向  \n`:%s/vivian/sky/g`  \n替换每一行中所有 vivian 为 sky  \n`:1,$ s/$/WORLD/g`  \n替换行尾  \n`:1,$ s/^/HELLO/g`  \n替换行首  \n`:1,10d`  \n命令解释：删除第一行到第 10 行  \n`:f`  \n在命令模式下，用于显示当前的文件名、光标所在行的行号以及显示比例；  \n`:g/^s*$/d`  \n删除所有空格  \n`:s/vivian/sky/g`  \n替换当前行所有 vivian 为 sky  \n`b`  \n光标左移一个字至字首,跳过空格  \n`caw ciw`  \n更改当前光标所在字符的单词并进入插入模式  \n`ct`  \n删除到某个单词并进入插入模式,T 反向  \n`c`  \n和其它命令组合,和 d 模式基本相同，进入插入模式  \n`C`  \n删除直到行尾并进入插入模式  \n`Ctrl+b`  \n向文件首翻一屏；  \n`Ctrl+d`  \n向文件尾翻半屏；  \n`Ctrl+f`  \n向文件尾翻一屏；  \n`Ctrl+u`  \n向文件首翻半屏；  \n`f`  \n跳转到指定字符  \n`t`  \n跳转到指定字符前  \n`D`  \n删除直到行尾  \n`diw`  \n删除当前单词,和其它组合，如 di{,di(,di\"  \n`daw`  \n删除当前单词,和其它组合，如 di{,di(,di\",同时删除组合  \n`dt`  \n删除知道某个单词 仅限当前行,T 反向  \n`e`  \n光标右移一个字至字尾,跳过空格  \n`gd`  \n高亮显示光标所属单词，\"n\" 查找！  \n`ge`  \n光标左移一个字至字尾,跳过空格  \n`gU`  \n转换大写到 需配合 w,b 等移动命令，类似 t  \n`gu`  \n转换小写到 需配合 w,b 等移动命令，类似 t  \n`H`  \n光标移至屏幕顶行  \n`L`  \n光标移至屏幕最后行  \n`M`  \n光标移至屏幕中间行  \n`R`  \n进入替换模式，直到按下 esc  \n`s`  \n删除当前字符并进入插入模式  \n`S`  \n删除当前行，并进入插入模式  \n`vi{`  \n选中大括号内,小括号等同理  \n`w`  \n光标右移一个字至字首,跳过空格  \n`ZZ`  \n命令模式下保存当前文件所做的修改后退出 vi；  \n`{`  \n转到上一个空行 }反向  \n`＃`  \n普通模式下输入＃寻找游标所在处的单词,＊是反向  \n`ma`  \nmark currrent position  \n`da`  \ndelete everything from the marked position to here  \n\\`a\ngo back to the marked position  \n`''`  \n跳转到光标上次停靠的地方, 是两个', 而不是一个\"  \n`gD`  \n跳转到局部变量的定义处  \n`:E`  \n浏览当前目录\n\n## 配置文件\n\nvim 的配置在`~/.vimrc`中。\n\n- set paste 进入 paste 模式以后，可以在插入模式下粘贴内容，不会有任何变形,解决粘贴乱行问题\n\n## 宏模式\n\n在命令模式下按下`qa`开始记录，指导在命令模式下再次按下`q`结束记录。\n可通过`@a`，重复执行命令，`n@a`重复执行`n`次。\n\n## 替换空格为换行\n\n```shell\n:%s/ /\\r/g\n```\n\n## 查看颜色代码\n\n```shell\n:hi\n```\n\n例如\n![vim_2020-06-03-11-36-27.png](./images/vim_2020-06-03-11-36-27.png)\n\n其中关于搜索高亮的颜色是配置项 `Search`,我们可以临时修改\n\n```shell\n:hi Search term=reverse ctermfg=0 ctermbg=3 guifg=#000000 guibg=#FFE792\n```\n\n也可在`.vimrc`中配置,使其永久生效\n\n```properties\nhi Search term=reverse ctermfg=0 ctermbg=3 guifg=#000000 guibg=#FFE792\n```\n","categories":["linux"],"tags":["vim"]},{"title":"tomcat","url":"/2019/08/10/tomcat/","content":"\n## 配置 JNDI\n\n确保 tomcat 下有相关`jar`\n\ntomcat 目录下`/conf/context.xml`中增加配置\n\n```xml\n<Resource name = \"jdbc/mysql\"\n      auth = \"Container\"\n      type = \"javax.sql.DataSource\"\n      driverClassName = \"com.mysql.jdbc.Driver\"\n      url = \"jdbc:mysql://localhost:3306/app\"\n      factory=\"com.li.jndi.EncryptedDataSourceFactory\"\n      username = \"root\"\n      password = \"xxxx\"\n      maxActive = \"200\"\n      maxIdle = \"30\"\n      maxWait = \"5000\"\n/>\n```\n\n确保 tomcat 目录下有`driver`的`jar`包\n\n> `/lib/mysql-connector-java-8.0.16.jar`\n\n`factory`标签是指定`BasicDataSourceFactory`工厂类，可以用来解密`password`密文。需要如下依赖\n\n```xml\n<dependency>\n    <groupId>commons-dbcp</groupId>\n    <artifactId>commons-dbcp</artifactId>\n    <version>1.2.2</version>\n</dependency>\n```\n\n`EncryptedDataSourceFactory`代码如下\n\n```java\npackage com.li.jndi;\n\nimport org.apache.commons.dbcp.BasicDataSourceFactory;\nimport org.apache.naming.ResourceRef;\n\nimport javax.naming.*;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\n\npublic class EncryptedDataSourceFactory extends BasicDataSourceFactory {\n\n    @Override\n    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment) throws Exception {\n        if (obj instanceof ResourceRef) {\n            decode(\"password\", (Reference) obj);\n        }\n        return super.getObjectInstance(obj, name, nameCtx, environment);\n    }\n\n    private String decode(String old) throws Exception {\n        return \"root\";\n    }\n\n    private int find(String addrType, Reference ref) throws Exception {\n        Enumeration enu = ref.getAll();\n        for (int i = 0; enu.hasMoreElements(); i++) {\n            RefAddr addr = (RefAddr) enu.nextElement();\n            if (addr.getType().compareTo(addrType) == 0) {\n                return i;\n            }\n        }\n        throw new Exception(\"The \\\"\" + addrType\n            + \"\\\" name/value pair was not found\"\n            + \" in the Reference object. The reference Object is\" + \" \"\n            + ref.toString());\n    }\n\n    private void decode(String refType, Reference ref) throws Exception {\n        int index = find(refType, ref);\n        RefAddr refAddr = ref.get(index);\n        Object content = refAddr.getContent();\n        if (content instanceof String) {\n            ref.remove(index);\n            ref.add(index, new StringRefAddr(refType, decode((String) content)));\n        }\n    }\n\n}\n\n```\n\n使用`jndi`服务\n\n```java\npackage com.li.jndi;\n\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\npublic class DBConn {\n\n    private static DataSource dataSource;\n\n    static {\n        try {\n            Context context = new InitialContext();\n            dataSource = (DataSource)context.lookup(\"java:comp/env/jdbc/mysql\");\n        }\n        catch (NamingException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## tomcat 类加载顺序\n\ntomcat 优先加载应用内的 jar 包，然后在加载共享 lib 目录下的 jar 包\n","categories":["java"],"tags":["datasource","tomcat","jndi"]},{"title":"java-bridge-method","url":"/2019/08/09/java-bridge-method/","content":"\n## 桥接方法\n\n泛型类型擦除的影响，以及 bridge 方法介绍\n\n```java\npublic class Node<T> {\n\n    public T data;\n\n    public Node(T data) { this.data = data; }\n\n    public void setData(T data) {\n        System.out.println(\"Node.setData\");\n        this.data = data;\n    }\n}\n\npublic class MyNode extends Node<Integer> {\n    public MyNode(Integer data) { super(data); }\n\n    public void setData(Integer data) {\n        System.out.println(\"MyNode.setData\");\n        super.setData(data);\n    }\n}\n```\n\n当做如下使用时\n\n```java\nNode node = new MyNode(5);\nn.setData(\"Hello\");\n```\n\n我们的子类中实际是没有 setData(Object.class)的方法的，`java`编译器在进行类型擦除的时候会自动生成一个`synthetic`方法，也叫`bridge`方法,我们通过生成的字节码可以看到实际`bridge`方法，首先校验类型是否为`Integer`，然后在调用`setData(Integer.class)`因此，上述代码会抛出`ClassCastException`\n\n```java\npublic void setData(java.lang.Integer);\n    descriptor: (Ljava/lang/Integer;)V\n    flags: ACC_PUBLIC\n    Code:\n        stack=2, locals=2, args_size=2\n            0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n            3: ldc           #3                  // String MyNode.setNode\n            5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n            8: aload_0\n            9: aload_1\n            10: invokespecial #5                  // Method com/li/springboot/bridge/Node.setData:(Ljava/lang/Object;)V\n            13: return\n        LineNumberTable:\n        line 11: 0\n        line 12: 8\n        line 13: 13\n        LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      14     0  this   Lcom/li/springboot/bridge/MyNode;\n            0      14     1 integer   Ljava/lang/Integer;\n    MethodParameters:\n        Name                           Flags\n        integer\n\n\npublic void setData(java.lang.Object);\n    descriptor: (Ljava/lang/Object;)V\n    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC\n    Code:\n        stack=2, locals=2, args_size=2\n            0: aload_0\n            1: aload_1\n            2: checkcast     #11                 // class java/lang/Integer\n            5: invokevirtual #12                 // Method setData:(Ljava/lang/Integer;)V\n            8: return\n        LineNumberTable:\n        line 3: 0\n        LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       9     0  this   Lcom/li/springboot/bridge/MyNode;\n    MethodParameters:\n        Name                           Flags\n        integer                        synthetic\n\n```\n\n## 桥接子类获取泛型\n\n父类泛型可以使用\n\n```java\nParameterizedTypeImpl type = (ParameterizedTypeImpl) MyNode.class.getGenericSuperclass();\n//具体每个泛型\ntype.getActualTypeArguments()\n```\n\n接口泛型\n\n```java\nParameterizedTypeImpl[] types = (ParameterizedTypeImpl[]) MyNode.class.getGenericInterfaces();\n\n```\n\n## Spring 注入桥接子类注意\n\n```java\npublic interface Generic<T,R> {}\n@Component\npublic class G1 implements Generic<Object, Collection> {}\npublic class G2 implements Generic<Object, List> {}\npublic class G3<T> implements Generic<T, List> {}\npublic class G4 implements Generic<String, List> {}\n```\n\n```java\n\n   @Autowired\n   List<Generic> generics; //G1 G2 G3 G4\n   @Autowired\n   List<Generic<?, ? extends Collection>> generics; //G1 G2 G3 G4\n   @Autowired\n   List<Generic<?, Collection>> generics;//G1\n   @Autowired\n   List<Generic<Object, ? extends Collection>> generics; //G1 G2 G3\n   @Autowired\n   List<Generic<Object, Collection>> generics; //G1 G2\n```\n","categories":["java"],"tags":["泛型"]},{"title":"restTemplate使用","url":"/2019/08/09/restTemplate%E4%BD%BF%E7%94%A8/","content":"\n## 基础\n\n推荐使用`RestTemplateBuilder`构建`RestTemplate`\n\n我们看下`RestTemplate`的基础成员变量\n\n`requestFactory: ClientHttpRequestFactory`\n`defaultUriVariables: Map<String, ?>`\n`uriTemplateHandler: UriTemplateHandler`\n`interceptors: List<ClientHttpRequestInterceptor>`\n`messageConverters: List<HttpMessageConverter<?>>`\n`errorHandler: ResponseErrorHandler`\n\n下面我们主要针对这些属性做一些分析\n\n## requestFactory\n\n指定使用的`HTTP`请求方式，\n设置`http`请求工厂类，处理超时，线程，异常处理等情况。\n\n```java\nRestTemplate restTemplate() {\n    return new RestTemplateBuilder().requestFactory(requestFactory()).build();\n}\n\nprivate Supplier<ClientHttpRequestFactory> requestFactory() {\n    return () -> {\n        HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n        requestFactory.setConnectionRequestTimeout(3000);\n        requestFactory.setConnectTimeout(3000);\n        requestFactory.setReadTimeout(8000);\n        requestFactory.setHttpClient(httpClient());\n        return requestFactory;\n    };\n}\n\nprivate HttpClient httpClient() {\n    HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();\n    httpClientBuilder.setMaxConnTotal(50);\n    httpClientBuilder.setMaxConnPerRoute(5);\n    return HttpClientBuilder.create().build();\n}\n```\n\n## defaultUriVariables\n\n当被赋值时就不能使用自定义`uriTemplateHandler`。这是就使用默认的`uriTemplateHandler`即`DefaultUriBuilderFactory`。\n假设现在`defaultUriVariables`包含`default=demo`。\n\n例如：\n\n```java\nString url = \"http://localhost:8080/{default}/{replace}\"\n\nMap<String,String> uriVariables = new HashMap<>();\nuriVariables.put(\"replace\",\"someuri\");\n\npublic <T> T postForObject(String url, @Nullable Object request, Class<T> responseType,\n        Map<String, ?> uriVariables)\n```\n\n在实际请求时:\n`{default}`会被替换为`demo`  \n`{replace}`会被替换为`someuri`  \n 替换后的值中包含`/`会无法正常解析。\n\n## uriTemplateHandler\n\n默认的 uriTemplateHandler 会将 uriVariables 中的 value 进行转译，因此无法'/'会被解析为 ascii 符号。根据需要，生成满足自己需要的 URI。\n\n```java\npublic interface UriTemplateHandler {\n    URI expand(String uriTemplate, Map<String, ?> uriVariables);\n    URI expand(String uriTemplate, Object... uriVariables);\n}\n```\n\n返回的 URI 经过自定义处理器会将`{xxx}`,替换为`uriVariables`中对应的值，这个可以正常解析`/`\n\n```java\nRestTemplate rest = restTemplate();\n    rest.setUriTemplateHandler(new UriTemplateHandler() {\n        @Override\n        public URI expand(String uriTemplate, Map<String, ?> uriVariables) {\n            return new UriTemplate(uriTemplate).expand(uriVariables);\n        }\n\n        @Override\n        public URI expand(String uriTemplate, Object... uriVariables) {\n            return new UriTemplate(uriTemplate).expand(uriVariables);\n        }\n    });\n\n    Map<String, Object> uriVariables = new HashMap<>();\n    uriVariables.put(\"replace\", \"response/test\");\n    String hello = rest.postForObject(\"http://localhost:8080/{replace}\", \"\", String.class, uriVariables);\n```\n\n## interceptors\n\n类似`AOP`切面，在`HTTP`请求前后进行拦截，比如统一加`headers\n\n```java\npublic interface ClientHttpRequestInterceptor {\n\n    ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution)\n            throws IOException;\n}\n\n ClientHttpRequestInterceptor interceptor = (request, body, execution) -> {\n            return execution.execute(request, body);\n        };\n```\n\n## messageConverters\n\n与`SpringMVC`的`messageConverters`原理是一样的。\b`HTTP`交易时数据传递是通过二进制`byte`传递的。而我们使用`RestTemplate`时，一般请求返回都使用`javaBean`,那就需要`messageConverters`来统一处理。\n\n我们看下`RestTemplate`的静态方法\n\n```java\nprivate static boolean romePresent;\n\nprivate static final boolean jaxb2Present;\n\nprivate static final boolean jackson2Present;\n\nprivate static final boolean jackson2XmlPresent;\n\nprivate static final boolean jackson2SmilePresent;\n\nprivate static final boolean jackson2CborPresent;\n\nprivate static final boolean gsonPresent;\n\nprivate static final boolean jsonbPresent;\n\nstatic {\n    ClassLoader classLoader = RestTemplate.class.getClassLoader();\n    romePresent = ClassUtils.isPresent(\"com.rometools.rome.feed.WireFeed\", classLoader);\n    jaxb2Present = ClassUtils.isPresent(\"javax.xml.bind.Binder\", classLoader);\n    jackson2Present =\n            ClassUtils.isPresent(\"com.fasterxml.jackson.databind.ObjectMapper\", classLoader) &&\n                    ClassUtils.isPresent(\"com.fasterxml.jackson.core.JsonGenerator\", classLoader);\n    jackson2XmlPresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.xml.XmlMapper\", classLoader);\n    jackson2SmilePresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.smile.SmileFactory\", classLoader);\n    jackson2CborPresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.cbor.CBORFactory\", classLoader);\n    gsonPresent = ClassUtils.isPresent(\"com.google.gson.Gson\", classLoader);\n    jsonbPresent = ClassUtils.isPresent(\"javax.json.bind.Jsonb\", classLoader);\n}\n```\n\n再看下`RestTemplate`构造器，当`classpath`中有对应的`class`时，可以看到`RestTemplate`会自动加载\n\n```java\npublic RestTemplate() {\n    this.messageConverters.add(new ByteArrayHttpMessageConverter());\n    this.messageConverters.add(new StringHttpMessageConverter());\n    this.messageConverters.add(new ResourceHttpMessageConverter(false));\n    try {\n        this.messageConverters.add(new SourceHttpMessageConverter<>());\n    }\n    catch (Error err) {\n        // Ignore when no TransformerFactory implementation is available\n    }\n    this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());\n\n    if (romePresent) {\n        this.messageConverters.add(new AtomFeedHttpMessageConverter());\n        this.messageConverters.add(new RssChannelHttpMessageConverter());\n    }\n\n    if (jackson2XmlPresent) {\n        this.messageConverters.add(new MappingJackson2XmlHttpMessageConverter());\n    }\n    else if (jaxb2Present) {\n        this.messageConverters.add(new Jaxb2RootElementHttpMessageConverter());\n    }\n\n    if (jackson2Present) {\n        this.messageConverters.add(new MappingJackson2HttpMessageConverter());\n    }\n    else if (gsonPresent) {\n        this.messageConverters.add(new GsonHttpMessageConverter());\n    }\n    else if (jsonbPresent) {\n        this.messageConverters.add(new JsonbHttpMessageConverter());\n    }\n\n    if (jackson2SmilePresent) {\n        this.messageConverters.add(new MappingJackson2SmileHttpMessageConverter());\n    }\n    if (jackson2CborPresent) {\n        this.messageConverters.add(new MappingJackson2CborHttpMessageConverter());\n    }\n\n    this.uriTemplateHandler = initUriTemplateHandler();\n}\n```\n\n## errorHandler\n\n仅在`HTTP`成功返回后才会被执行，决定当前`HTTP`请求是否成功。`hasError`返回`true`时才会调用`handleError`方法。\n\n```java\npublic interface ResponseErrorHandler {\n    boolean hasError(ClientHttpResponse response) throws IOException;\n    void handleError(ClientHttpResponse response) throws IOException;\n    default void handleError(URI url, HttpMethod method, ClientHttpResponse response) throws IOException {\n        handleError(response);\n    }\n}\n```\n\n## rootUri\n\n通过`RestTemplateBuilder`设置`rootUri`,进行`HTTP`请求时，若非`http`开头，则会自动加上`rootUri`\n\n```java\nRestTemplate rest = new RestTemplateBuilder().rootUri(\"http://localhost:8080\").build();\nrest.postForObject(\"/test\", \"\", String.class, variables);\n```\n\n## POST 请求参数\n\n上传文件的请求模拟\n\n```java\nRestTemplate restTemplate = new RestTemplate();\nMultiValueMap multiValueMap = new LinkedMultiValueMap();\nFileSystemResource resource = new FileSystemResource(new File(\"/Users/li/Documents/Blog/db.json\"));\nmultiValueMap.add(\"file\",resource);\nString msg = restTemplate.postForObject(\"http://localhost:8082/upload/any\", multiValueMap, String.class);\n```\n\n## 上传文件的错误\n\n错误信息\n\n> The request was rejected because no multipart boundary was found\n\n通过查找该报错信息打印处可以定位\n\n```java\nFileItemIteratorImpl(RequestContext ctx)\n        throws FileUploadException, IOException {\n    if (ctx == null) {\n        throw new NullPointerException(\"ctx parameter\");\n    }\n\n    String contentType = ctx.getContentType();\n    if ((null == contentType)\n            || (!contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART))) {\n        throw new InvalidContentTypeException(String.format(\n                \"the request doesn't contain a %s or %s stream, content type header is %s\",\n                MULTIPART_FORM_DATA, MULTIPART_MIXED, contentType));\n    }\n\n\n    final long requestSize = ((UploadContext) ctx).contentLength();\n\n    InputStream input; // N.B. this is eventually closed in MultipartStream processing\n    if (sizeMax >= 0) {\n        if (requestSize != -1 && requestSize > sizeMax) {\n            throw new SizeLimitExceededException(String.format(\n                    \"the request was rejected because its size (%s) exceeds the configured maximum (%s)\",\n                    Long.valueOf(requestSize), Long.valueOf(sizeMax)),\n                    requestSize, sizeMax);\n        }\n        // N.B. this is eventually closed in MultipartStream processing\n        input = new LimitedInputStream(ctx.getInputStream(), sizeMax) {\n            @Override\n            protected void raiseError(long pSizeMax, long pCount)\n                    throws IOException {\n                FileUploadException ex = new SizeLimitExceededException(\n                String.format(\"the request was rejected because its size (%s) exceeds the configured maximum (%s)\",\n                        Long.valueOf(pCount), Long.valueOf(pSizeMax)),\n                        pCount, pSizeMax);\n                throw new FileUploadIOException(ex);\n            }\n        };\n    } else {\n        input = ctx.getInputStream();\n    }\n\n    String charEncoding = headerEncoding;\n    if (charEncoding == null) {\n        charEncoding = ctx.getCharacterEncoding();\n    }\n\n    boundary = getBoundary(contentType);\n    if (boundary == null) {\n        IOUtils.closeQuietly(input); // avoid possible resource leak\n        throw new FileUploadException(\"the request was rejected because no multipart boundary was found\");\n    }\n\n    notifier = new MultipartStream.ProgressNotifier(listener, requestSize);\n    try {\n        multi = new MultipartStream(input, boundary, notifier);\n    } catch (IllegalArgumentException iae) {\n        IOUtils.closeQuietly(input); // avoid possible resource leak\n        throw new InvalidContentTypeException(\n                String.format(\"The boundary specified in the %s header is too long\", CONTENT_TYPE), iae);\n    }\n    multi.setHeaderEncoding(charEncoding);\n\n    skipPreamble = true;\n    findNextItem();\n}\n```\n\n通过查看`getBoundary`\n\n```java\nprotected byte[] getBoundary(String contentType) {\n    ParameterParser parser = new ParameterParser();\n    parser.setLowerCaseNames(true);\n    // Parameter parser can handle null input\n    Map<String,String> params =\n            parser.parse(contentType, new char[] {';', ','});\n    //Content-Type中包含boundary=xxx字段\n    String boundaryStr = params.get(\"boundary\");\n\n    if (boundaryStr == null) {\n        return null;\n    }\n    byte[] boundary;\n    boundary = boundaryStr.getBytes(StandardCharsets.ISO_8859_1);\n    return boundary;\n}\n```\n\n根据上一节的说明，我们知道上送文件是使用`MultiValueMap`来上送的，那么我们只要知道`MultiValueMap`请求的`Content-Type`是什么即可。\n\n根据前面章节`messageConverters`的加载介绍，我们知道`RestTemplate`会选择一个合适的处理器来处理，\n其中`AllEncompassingFormHttpMessageConverter`的父类`FormHttpMessageConverter`\n\n```java\npublic void doWithRequest(ClientHttpRequest httpRequest) throws IOException {\n    super.doWithRequest(httpRequest);\n    Object requestBody = this.requestEntity.getBody();\n    if (requestBody == null) {\n        HttpHeaders httpHeaders = httpRequest.getHeaders();\n        HttpHeaders requestHeaders = this.requestEntity.getHeaders();\n        if (!requestHeaders.isEmpty()) {\n            requestHeaders.forEach((key, values) -> httpHeaders.put(key, new LinkedList<>(values)));\n        }\n        if (httpHeaders.getContentLength() < 0) {\n            httpHeaders.setContentLength(0L);\n        }\n    }\n    else {\n        //request的类型需要继承自MultiValueMap或者HttpEntity<MultiValueMap>\n        Class<?> requestBodyClass = requestBody.getClass();\n        Type requestBodyType = (this.requestEntity instanceof RequestEntity ?\n                ((RequestEntity<?>)this.requestEntity).getType() : requestBodyClass);\n        HttpHeaders httpHeaders = httpRequest.getHeaders();\n        HttpHeaders requestHeaders = this.requestEntity.getHeaders();\n        MediaType requestContentType = requestHeaders.getContentType();\n        for (HttpMessageConverter<?> messageConverter : getMessageConverters()) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                GenericHttpMessageConverter<Object> genericConverter =\n                        (GenericHttpMessageConverter<Object>) messageConverter;\n                if (genericConverter.canWrite(requestBodyType, requestBodyClass, requestContentType)) {\n                    if (!requestHeaders.isEmpty()) {\n                        requestHeaders.forEach((key, values) -> httpHeaders.put(key, new LinkedList<>(values)));\n                    }\n                    logBody(requestBody, requestContentType, genericConverter);\n                    genericConverter.write(requestBody, requestBodyType, requestContentType, httpRequest);\n                    return;\n                }\n            }\n            //requestContentType需满足如下之一\n            // null\n            // multipart/form-data\n            // */*\n            //application/x-www-form-urlencoded\n            else if (messageConverter.canWrite(requestBodyClass, requestContentType)) {\n                if (!requestHeaders.isEmpty()) {\n                    requestHeaders.forEach((key, values) -> httpHeaders.put(key, new LinkedList<>(values)));\n                }\n                logBody(requestBody, requestContentType, messageConverter);\n                ((HttpMessageConverter<Object>) messageConverter).write(\n                        requestBody, requestContentType, httpRequest);\n                return;\n            }\n        }\n        String message = \"No HttpMessageConverter for \" + requestBodyClass.getName();\n        if (requestContentType != null) {\n            message += \" and content type \\\"\" + requestContentType + \"\\\"\";\n        }\n        throw new RestClientException(message);\n    }\n}\n```\n\n查看具体`FormHttpMessageConverter`的`write`方法\n\n```java\npublic void write(MultiValueMap<String, ?> map, @Nullable MediaType contentType, HttpOutputMessage outputMessage)\n        throws IOException, HttpMessageNotWritableException {\n    //上送文件肯定使用的writeMultipart\n    if (!isMultipart(map, contentType)) {\n        writeForm((MultiValueMap<String, Object>) map, contentType, outputMessage);\n    }\n    else {\n        writeMultipart((MultiValueMap<String, Object>) map, outputMessage);\n    }\n}\n```\n\n```java\nprivate void writeMultipart(final MultiValueMap<String, Object> parts, HttpOutputMessage outputMessage)\n        throws IOException {\n\n    final byte[] boundary = generateMultipartBoundary();\n    Map<String, String> parameters = new LinkedHashMap<>(2);\n    if (!isFilenameCharsetSet()) {\n        parameters.put(\"charset\", this.charset.name());\n    }\n    //这里我们可以看到生成的boundary信息\n    parameters.put(\"boundary\", new String(boundary, StandardCharsets.US_ASCII));\n\n    MediaType contentType = new MediaType(MediaType.MULTIPART_FORM_DATA, parameters);\n    HttpHeaders headers = outputMessage.getHeaders();\n    headers.setContentType(contentType);\n\n    if (outputMessage instanceof StreamingHttpOutputMessage) {\n        StreamingHttpOutputMessage streamingOutputMessage = (StreamingHttpOutputMessage) outputMessage;\n        streamingOutputMessage.setBody(outputStream -> {\n            writeParts(outputStream, parts, boundary);\n            writeEnd(outputStream, boundary);\n        });\n    }\n    else {\n        writeParts(outputMessage.getBody(), parts, boundary);\n        writeEnd(outputMessage.getBody(), boundary);\n    }\n}\n```\n\n所以我们定位一下具体发生错误的情况下使用的是何种`messageConverter`即可\n\n## `messageConverter`有关问题\n\n当请求的`api`返回的`content-type`不是标准的`application/json`时，默认的`messageConverter`不支持处理\n\n```java\nList<HttpMessageConverter<?>> messageConverters = new ArrayList<HttpMessageConverter<?>>();\n//Add the Jackson Message converter\nMappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();\n\n// Note: here we are making this converter to process any kind of response,\n// not only application/*json, which is the default behaviour\nconverter.setSupportedMediaTypes(Collections.singletonList(MediaType.ALL));\nmessageConverters.add(converter);\nrestTemplate.setMessageConverters(messageConverters);\n```\n","categories":["spring"],"tags":["spring","restTemplate"]},{"title":"spring自定义注解改变方法","url":"/2019/08/09/spring%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E6%94%B9%E5%8F%98%E6%96%B9%E6%B3%95/","content":"\n## 版本说明\n\n`jdk`:1.8.0_131  \n`springboot`:2.1.6.RELEAS  \n`maven`:3.6.1  \n`lombok插件`  \n\n## 概述\n\n仅仅示范简单用法不涉及源码介绍，仅仅是一些实现方式，不一定是最优实现方式。这里仅仅只做打印参数，不做其他特殊操作，\n可以根据需要，可以实现的包括异步调用，远程调用，缓存等等。\n\n标记注解类\n\n```java\nimport org.slf4j.event.Level;\n\nimport java.lang.annotation.*;\n\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface LogAnnotation {\n    Level value() default Level.DEBUG;\n}\n```\n\n被注解bean\n\n```java\n\nimport org.slf4j.event.Level;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class LogBean {\n    @LogAnnotation\n    public void debug() {\n\n    }\n\n    @LogAnnotation(Level.ERROR)\n    public void error() {\n\n    }\n\n    public void normal(){\n\n    }\n}\n```\n\n## 方案一\n\n使用`BeanPostProcessor`，扫描方法或类是否有`LogAnnotation`注解，如果有，则替换bean为代理类。\n\n```java\nimport lombok.extern.slf4j.Slf4j;\nimport org.slf4j.event.Level;\nimport org.springframework.aop.support.AopUtils;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.core.annotation.AnnotatedElementUtils;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Arrays;\n\n@Component\n@Order(Integer.MAX_VALUE)\n@Slf4j\npublic class LogBeanPostProcessor implements BeanPostProcessor {\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\n    Class<?> targetClass = AopUtils.getTargetClass(bean);\n    //判断类是否有注解LogAnnotation\n    if (AnnotatedElementUtils.findMergedAnnotation(targetClass, LogAnnotation.class) != null || Arrays.stream(targetClass.getMethods()).anyMatch(method -> AnnotatedElementUtils.findMergedAnnotation(method, LogAnnotation.class) != null)) {\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(targetClass);\n        //注册切面方法\n        enhancer.setCallback((MethodInterceptor) (o, method, args, methodProxy) -> {\n            LogAnnotation annotation = AnnotatedElementUtils.findMergedAnnotation(targetClass, LogAnnotation.class);\n            if (annotation == null) {\n                annotation = AnnotatedElementUtils.findMergedAnnotation(method, LogAnnotation.class);\n            }\n            if (annotation == null) {\n                return method.invoke(bean, args);\n            }\n            //包含有注解的方法，或者类上有注解的方法，打印日志\n            Level level = annotation.value();\n            if (log.isDebugEnabled()) {\n                log.debug(\"[\" + level + \"]\" + method.getName() + \" \" + Arrays.toString(args));\n            } else if (log.isErrorEnabled()) {\n                log.debug(\"[\" + level + \"]\" + method.getName() + \" \" + Arrays.toString(args));\n            }\n            return method.invoke(bean, args);\n        });\n        //生成代理类\n        return enhancer.create();\n    }\n    return bean;\n}\n}\n\n```\n\n## 方案二\n\n使用`spring`提供的切面功能，针对被注解的类进行切面\n\n```java\npackage com.li.springboot.other;\n\nimport com.li.springboot.advice.MyPointcutAdvisor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.aopalliance.aop.Advice;\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.slf4j.event.Level;\nimport org.springframework.aop.Pointcut;\nimport org.springframework.aop.framework.AbstractAdvisingBeanPostProcessor;\nimport org.springframework.aop.support.AbstractPointcutAdvisor;\nimport org.springframework.aop.support.AopUtils;\nimport org.springframework.aop.support.ComposablePointcut;\nimport org.springframework.aop.support.annotation.AnnotationMatchingPointcut;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryAware;\nimport org.springframework.core.BridgeMethodResolver;\nimport org.springframework.core.annotation.AnnotatedElementUtils;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.ClassUtils;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\n\n@Component\n@Order(Integer.MAX_VALUE)\n@Slf4j\npublic class LogBeanAdvisingBeanPostProcessor extends AbstractAdvisingBeanPostProcessor implements BeanFactoryAware {\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n        setBeforeExistingAdvisors(true);\n        MyPointcutAdvisor advisor = new MyPointcutAdvisor();\n        this.advisor = new AbstractPointcutAdvisor() {\n            @Override\n            public Advice getAdvice() {\n                return (MethodInterceptor) invocation -> {\n                    //获取目标类\n                    Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);\n                    //获取指定方法\n                    Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass);\n                    //获取真正执行的方法,可能存在桥接方法\n                    final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);\n                    //获取方法上注解\n                    LogAnnotation annotation = AnnotatedElementUtils.findMergedAnnotation(userDeclaredMethod,\n                        LogAnnotation.class);\n                    if (annotation == null) {\n                        annotation = AnnotatedElementUtils.findMergedAnnotation(targetClass, LogAnnotation.class);\n                    }\n                    //包含注解则打印参数\n                    if (annotation != null) {\n                        Level level = annotation.value();\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"[\" + level + \"]\" + specificMethod.getName() + \" \" + Arrays.toString(invocation.getArguments()));\n                        } else if (log.isErrorEnabled()) {\n                            log.debug(\"[\" + level + \"]\" + specificMethod.getName() + \" \" + Arrays.toString(invocation.getArguments()));\n                        }\n                    }\n                    //执行具体业务逻辑\n                    return invocation.proceed();\n                };\n            }\n\n            @Override\n            public Pointcut getPointcut() {\n                ComposablePointcut result = null;\n                //类级别\n                Pointcut cpc = new AnnotationMatchingPointcut(LogAnnotation.class, true);\n                //方法级别\n                Pointcut mpc = AnnotationMatchingPointcut.forMethodAnnotation(LogAnnotation.class);\n                //对于类和方法上都可以添加注解的情况\n                //类上的注解,最终会将注解绑定到每个方法上\n                result = new ComposablePointcut(cpc);\n                return result.union(mpc);\n            }\n        };\n    }\n}\n```\n","categories":["spring"],"tags":["spring","自定义注解"]},{"title":"spring ControllerAdvice源码分析","url":"/2019/08/06/spring-ControllerAdvice%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","content":"\n## 版本说明\n\n`jdk`:1.8.0_131  \n`springboot`:2.1.6.RELEAS  \n`maven`:3.6.1  \n`database`:mysql-5.7.14  \n`lombok插件`\n\n## 源码分析\n\n仅仅针对被`@ControllerAdvice`注解的且实现接口`ResponseBodyAdvice`的类，进行源码分析，了解一下当`controller`中被`@ResponseBody`注解的方法的返回值，是如何被解析成前端需要的值的。\n至于`RequestBodyAdvice`和`@ExceptionHandler`等实现原理是差不多的。\n\n根据{% post_link Spring自定义ReturnValueHandlers %}中的分析，我们了解了实际调用`controller`类中的被`@ResponseBody`注解方法时，实际使用`RequestResponseBodyMethodProcessor`处理器去处理。\n\n我们查看下`RequestResponseBodyMethodProcessor`的`handleReturnValue`\n\n```java\n@Override\npublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)\n        throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n\n    mavContainer.setRequestHandled(true);\n    ServletServerHttpRequest inputMessage = createInputMessage(webRequest);\n    ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);\n\n    writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);\n}\n```\n\n`writeWithMessageConverters`节选片段\n\n```java\nif (selectedMediaType != null) {\n        selectedMediaType = selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter<?> converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ?\n                    (GenericHttpMessageConverter<?>) converter : null);\n            if (genericConverter != null ?\n                    ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :\n                    converter.canWrite(valueType, selectedMediaType)) {\n                body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,\n                        (Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n                        inputMessage, outputMessage);\n                if (body != null) {\n                    Object theBody = body;\n                    LogFormatUtils.traceDebug(logger, traceOn ->\n                            \"Writing [\" + LogFormatUtils.formatValue(theBody, !traceOn) + \"]\");\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter != null) {\n                        genericConverter.write(body, targetType, selectedMediaType, outputMessage);\n                    }\n                    else {\n                        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                    }\n                }\n                else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Nothing to write: null body\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n\n```\n\n`this.messageConverters`的循环调用，其实就是用合适的`HttpMessageConverter`来解析返回报文，默认情况下我们用的就是`SpringBoot`内容的`MappingJackson2HttpMessageConverter`处理器\n\n`MappingJackson2HttpMessageConverter`的`canWrite`就是查看`MediaType`是否满足\n\n```java\nprotected boolean canWrite(@Nullable MediaType mediaType) {\n    if (mediaType == null || MediaType.ALL.equalsTypeAndSubtype(mediaType)) {\n        return true;\n    }\n    for (MediaType supportedMediaType : getSupportedMediaTypes()) {\n        if (supportedMediaType.isCompatibleWith(mediaType)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n重点的是`getAdvice()`的加载\n\n```java\nRequestResponseBodyAdviceChain getAdvice() {\n    return this.advice;\n}\n```\n\n用`Debug`模式一步步回溯最终发现`RequestMappingHandlerAdapter`中\n\n```java\npublic void afterPropertiesSet() {\n    //扫描所有@ControllerAdvice\n    initControllerAdviceCache();\n\n    if (this.argumentResolvers == null) {\n        //\n        List<HandlerMethodArgumentResolver> resolvers = getDefaultArgumentResolvers();\n        this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);\n    }\n    if (this.initBinderArgumentResolvers == null) {\n        List<HandlerMethodArgumentResolver> resolvers = getDefaultInitBinderArgumentResolvers();\n        this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);\n    }\n    if (this.returnValueHandlers == null) {\n        List<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();\n        this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);\n    }\n}\n```\n\n节选`initControllerAdviceCache`\n\n```java\nList<ControllerAdviceBean> adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());\n...\nif (!requestResponseBodyAdviceBeans.isEmpty()) {\n    this.requestResponseBodyAdvice.addAll(0, requestResponseBodyAdviceBeans);\n}\n\n```\n\n节选方法`getDefaultArgumentResolvers`细节\n\n```java\nresolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));\n\n```\n\n`RequestResponseBodyMethodProcessor`构造方法最终指向父类`AbstractMessageConverterMethodArgumentResolver`,那么我们看到`@ControllerAdvice`注解的且实现接口`ResponseBodyAdvice`的类被加载到`this.advice`中\n\n```java\npublic AbstractMessageConverterMethodArgumentResolver(List<HttpMessageConverter<?>> converters,\n        @Nullable List<Object> requestResponseBodyAdvice) {\n\n    Assert.notEmpty(converters, \"'messageConverters' must not be empty\");\n    this.messageConverters = converters;\n    this.allSupportedMediaTypes = getAllSupportedMediaTypes(converters);\n    this.advice = new RequestResponseBodyAdviceChain(requestResponseBodyAdvice);\n}\n```\n\n那么我们看下`this.advice`的类`RequestResponseBodyAdviceChain`方法`beforeBodyWrite`细节\n\n```java\n@Override\n@Nullable\npublic Object beforeBodyWrite(@Nullable Object body, MethodParameter returnType, MediaType contentType,\n        Class<? extends HttpMessageConverter<?>> converterType,\n        ServerHttpRequest request, ServerHttpResponse response) {\n\n    return processBody(body, returnType, contentType, converterType, request, response);\n}\n\n    private <T> Object processBody(@Nullable Object body, MethodParameter returnType, MediaType contentType,\n        Class<? extends HttpMessageConverter<?>> converterType,\n        ServerHttpRequest request, ServerHttpResponse response) {\n\n    for (ResponseBodyAdvice<?> advice : getMatchingAdvice(returnType, ResponseBodyAdvice.class)) {\n        //决定自定义@ControllerAdvice是否启用\n        if (advice.supports(returnType, converterType)) {\n            //调用我们的返回值处理类\n            body = ((ResponseBodyAdvice<T>) advice).beforeBodyWrite((T) body, returnType,\n                    contentType, converterType, request, response);\n        }\n    }\n    return body;\n}\n```\n\n最后贴下`@ControllerAdvice`实现类\n\n```java\npackage com.li.springboot.controller;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.server.ServerHttpRequest;\nimport org.springframework.http.server.ServerHttpResponse;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;\n\n@ControllerAdvice\n@Slf4j\npublic class MyControllerAdvice implements ResponseBodyAdvice{\n   @Override\n   public boolean supports(MethodParameter returnType, Class converterType) {\n       return true;\n   }\n\n   @Override\n   public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {\n       log.debug(\"MyControllerAdvice beforeBodyWrite\");\n       return body;\n   }\n}\n```\n","categories":["spring"],"tags":["springboot","ControllerAdvice"]},{"title":"java tips","url":"/2019/08/06/java-tips/","content":"\n### 将常量放在接口中，通过继承该接口，调用常量\n\n```java\npublic interface ClassConstants{\n   int CONSUMER = 1;//接口中变量默认为 static final\n   int DISPLAY = 2;\n}\n```\n\n### 查看 Class 是否是基本类型\n\n```java\nclasz.isPrimitive();\n```\n\n### 查看类是否为基本类型或包装类型\n\n```java\nimport org.apache.commons.lang3.ClassUtils;\nClassUtils.isPrimitiveOrWrapper(klass)\n```\n\n### 读取 properties 中文乱码解决\n\n```java\nproperties.load(new InputStreamReader(AutoConfig.class.getResourceAsStream(\"/application.properties\"),\"utf-8\"));\n```\n\n### 判断类是否为数组\n\n```java\nklass.isArray();\n```\n\n### 判断类是否继承自\n\n```java\nFather.class.isAssignableFrom(Son.class)\n```\n\n### 获取当前执行的方法名,通过方法内的内部类来实现的\n\n```java\nnew Object(){}.getClass().getEnclosingMethod().getName();\n```\n\n### 使用 shell\n\n```java\n//获取当前系统名称，可根据不同系统调用不同的命令\nString os = System.getProperty(\"os.name\");\n//命令行的参数\nString [] para = new String[]{\"-l\"}\n//执行命令\nProcess ls = Runtime.getRuntime().exec(\"ls\",para, new File(\"/Users/li/Downloads\"));\n\n\n\n//获取命令执行结果的inputstream流\nString getLs = new BufferedReader(new InputStreamReader(ls.getInputStream())).lines().collect(Collectors.joining(System.lineSeparator()));\n\n//在目录下执行具体的命令\n//因为java执行shell无法进行连续性的交互命令，通过封装的bash或者python脚本执行一系列命令是比较好的选择\nProcess process = Runtime.getRuntime().exec(\"python test.py\", null, new File(\"/Users/li/Downloads\"));\n// 部分os需要先输出outputStream流，才能正确取得shell执行结果\nOutputstream out = process.getOutputStream();\nout.flush();\nout.close();\n\n//使用构造器模式\nProcessBuilder builder = new ProcessBuilder();\nbuilder.command(\"more\",\"test.py\");\nbuilder.directory(new File(\"/Users/li/Downloads\"));\n//重定向错误流，即System.Err\nbuilder.redirectErrorStream(true);\nProcess process = builder.start();\n```\n\n### 基本类型零值\n\n对基本数据类型来说，对于类变量`static`和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，可以根据这个特性，直接用静态类常量来获取基本变量的初始值\n\n```java\npublic class Primitive {\n  public static int i; //默认值0\n  public static char c; //默认值'\\u0000'\n}\n```\n\n### 反射工具类\n\n第三方反射工具类\n\n```xml\n<dependency>\n    <groupId>org.reflections</groupId>\n    <artifactId>reflections</artifactId>\n    <version>0.9.10</version>\n</dependency>\n```\n\n扫描类在某个包下的所有子类\n\n```java\nReflections reflections = new Reflections(\"my.project\");\nSet<Class<? extends SomeType>> subTypes = reflections.getSubTypesOf(SomeType.class);\n\n```\n\n扫描在某个包下的被注解了某个注解的所有类\n\n```java\nSet<Class<?>> annotated = reflections.getTypesAnnotatedWith(SomeAnnotation.class);\n```\n\n### `Comparator.comparing`\n\n可是使用 lambda 快速实现`comparable`\n\n```java\nComparator<Player> byRanking\n = (Player player1, Player player2) -> player1.getRanking() - player2.getRanking();\n```\n\n类似`Collectors`提供了快捷的`Comparator`方法\n\n```java\nComparator<Player> byRanking = Comparator\n  .comparing(Player::getRanking);\nComparator<Player> byAge = Comparator\n  .comparing(Player::getAge);\n```\n\n### 批量反编译 jar 包\n\n```shell\nls *.jar|xargs -I {} jadx {} -d src\n```\n","categories":["java"],"tags":["tips","java"]},{"title":"Spring自定义ReturnValueHandlers","url":"/2019/08/05/Spring%E8%87%AA%E5%AE%9A%E4%B9%89ReturnValueHandlers/","content":"\n## 版本说明\n\n`jdk`:1.8.0_131  \n`springboot`:2.1.6.RELEAS  \n`maven`:3.6.1  \n`database`:mysql-5.7.14  \n`lombok插件`\n\n## 源码分析\n\n省略构建项目，junit 测试等步骤，只分析代码与实现。\n根据{% post_link spring静态资源加载源码浅析 %}中的分析,我们可以知道 \u001b`DispatcherServlet`会拦截所有请求，寻找合适的`mappedHandler`去处理请求，并根据`mappedHandler`去找对应的适配器`HandlerAdapter`来实际请求`controller`的方法，针对接口来说一般使用的是`RequestMappingHandlerAdapter`\n\n具体调用`controller`方法的细节我们不需要关注，这里我们仅仅关注`RequestMappingHandlerAdapter`是如何处理方法的返回值的。\n节选部分`DispatcherServlet`的`doDispatch`方法\n\n```java\n// 根据mappedHandler查找合适的适配器\nHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n// Process last-modified header, if supported by the handler.\nString method = request.getMethod();\nboolean isGet = \"GET\".equals(method);\nif (isGet || \"HEAD\".equals(method)) {\n    long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n    if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n        return;\n    }\n}\n\nif (!mappedHandler.applyPreHandle(processedRequest, response)) {\n    return;\n}\n\n// 实际调用controller方法的地方\nmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n```\n\n`RequestMappingHandlerAdapter`的`handle`方法调用了内部的`handleInternal`方法\n\n```java\n@Override\nprotected ModelAndView handleInternal(HttpServletRequest request,\n        HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n    ModelAndView mav;\n    checkRequest(request);\n\n    // Execute invokeHandlerMethod in synchronized block if required.\n    if (this.synchronizeOnSession) {\n        HttpSession session = request.getSession(false);\n        if (session != null) {\n            Object mutex = WebUtils.getSessionMutex(session);\n            synchronized (mutex) {\n                mav = invokeHandlerMethod(request, response, handlerMethod);\n            }\n        }\n        else {\n            // No HttpSession available -> no mutex necessary\n            mav = invokeHandlerMethod(request, response, handlerMethod);\n        }\n    }\n    else {\n        // No synchronization on session demanded at all...\n        mav = invokeHandlerMethod(request, response, handlerMethod);\n    }\n\n    if (!response.containsHeader(HEADER_CACHE_CONTROL)) {\n        if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {\n            applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);\n        }\n        else {\n            prepareResponse(response);\n        }\n    }\n\n    return mav;\n}\n\n```\n\n我们再查看`invokeHandlerMethod`实现细节\n\n```java\nprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n        HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n    ServletWebRequest webRequest = new ServletWebRequest(request, response);\n    try {\n        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);\n        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);\n\n        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n        if (this.argumentResolvers != null) {\n            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n        }\n        //这里我们要注意下，后面实现的自定义MyResponseType注解就和这里有关\n        if (this.returnValueHandlers != null) {\n            invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n        }\n        invocableMethod.setDataBinderFactory(binderFactory);\n        invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);\n\n        ModelAndViewContainer mavContainer = new ModelAndViewContainer();\n        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));\n        modelFactory.initModel(webRequest, mavContainer, invocableMethod);\n        mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);\n\n        AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);\n        asyncWebRequest.setTimeout(this.asyncRequestTimeout);\n\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n        asyncManager.setTaskExecutor(this.taskExecutor);\n        asyncManager.setAsyncWebRequest(asyncWebRequest);\n        asyncManager.registerCallableInterceptors(this.callableInterceptors);\n        asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);\n\n        if (asyncManager.hasConcurrentResult()) {\n            Object result = asyncManager.getConcurrentResult();\n            mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];\n            asyncManager.clearConcurrentResult();\n            LogFormatUtils.traceDebug(logger, traceOn -> {\n                String formatted = LogFormatUtils.formatValue(result, !traceOn);\n                return \"Resume with async result [\" + formatted + \"]\";\n            });\n            invocableMethod = invocableMethod.wrapConcurrentResult(result);\n        }\n        //实际调用的地方\n        invocableMethod.invokeAndHandle(webRequest, mavContainer);\n        if (asyncManager.isConcurrentHandlingStarted()) {\n            return null;\n        }\n\n        return getModelAndView(mavContainer, modelFactory, webRequest);\n    }\n    finally {\n        webRequest.requestCompleted();\n    }\n}\n```\n\n我们查看下`invocableMethod.invokeAndHandle`的细节\n\n```java\npublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n        Object... providedArgs) throws Exception {\n\n    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n    setResponseStatus(webRequest);\n\n    if (returnValue == null) {\n        if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {\n            disableContentCachingIfNecessary(webRequest);\n            mavContainer.setRequestHandled(true);\n            return;\n        }\n    }\n    else if (StringUtils.hasText(getResponseStatusReason())) {\n        mavContainer.setRequestHandled(true);\n        return;\n    }\n\n    mavContainer.setRequestHandled(false);\n    Assert.state(this.returnValueHandlers != null, \"No return value handlers\");\n    try {\n        //处理返回结果\n        this.returnValueHandlers.handleReturnValue(\n                returnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n    }\n    catch (Exception ex) {\n        if (logger.isTraceEnabled()) {\n            logger.trace(formatErrorForReturnValue(returnValue), ex);\n        }\n        throw ex;\n    }\n}\n```\n\n`this.returnValueHandlers.handleReturnValue`的实现细节类`HandlerMethodReturnValueHandlerComposite`\n\n```java\n@Override\npublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n        ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n    //查找合适的处理器\n    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);\n    if (handler == null) {\n        throw new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName());\n    }\n    //处理器执行\n    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);\n}\n\n@Nullable\nprivate HandlerMethodReturnValueHandler selectHandler(@Nullable Object value, MethodParameter returnType) {\n    boolean isAsyncValue = isAsyncReturnValue(value, returnType);\n    //遍历所有处理器，只要找到就直接返回，所以得考虑下优先级关系\n    for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {\n        if (isAsyncValue && !(handler instanceof AsyncHandlerMethodReturnValueHandler)) {\n            continue;\n        }\n        if (handler.supportsReturnType(returnType)) {\n            return handler;\n        }\n    }\n    return null;\n}\n```\n\n默认的返回值处理器有以下\n\n![返回值处理器](./images/Spring自定义ReturnValueHandlers_返回值处理器.jpg)\n\n我们查看下典型的`@ResponseBody`的处理器`RequestResponseBodyMethodProcessor`的方法`supportsReturnType`就明白`selectHandler`是如何起作用的\n\n```java\n@Override\npublic boolean supportsReturnType(MethodParameter returnType) {\n    return (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||\n            returnType.hasMethodAnnotation(ResponseBody.class));\n}\n```\n\n因为我们自定义的处理器是模仿`@ResponseBody`,那么我们只需要在`returnValueHandlers`中`RequestResponseBodyMethodProcessor`位置处插入我们自定义的处理器即可\n\n那么首先我们需要了解下`HandlerMethodReturnValueHandlerComposite`的属性`returnValueHandlers`是如何被加载赋值的，通过查看调用关系，我们发现 returnValueHandlers 赋值的方法为`addHandlers`,此方法被两处调用\n\n第一处,这里是加载 bean 时的初始化方法，即默认`returnValueHandlers`为`getDefaultReturnValueHandlers`的返回值\n\n```java\n@Override\npublic void afterPropertiesSet() {\n    // Do this first, it may add ResponseBody advice beans\n    initControllerAdviceCache();\n\n    if (this.argumentResolvers == null) {\n        List<HandlerMethodArgumentResolver> resolvers = getDefaultArgumentResolvers();\n        this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);\n    }\n    if (this.initBinderArgumentResolvers == null) {\n        List<HandlerMethodArgumentResolver> resolvers = getDefaultInitBinderArgumentResolvers();\n        this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);\n    }\n    if (this.returnValueHandlers == null) {\n        List<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();\n        this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);\n    }\n}\n```\n\n第二处\n\n```java\npublic void setReturnValueHandlers(@Nullable List<HandlerMethodReturnValueHandler> returnValueHandlers) {\n    if (returnValueHandlers == null) {\n        this.returnValueHandlers = null;\n    }\n    else {\n        this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite();\n        this.returnValueHandlers.addHandlers(returnValueHandlers);\n    }\n}\n```\n\n明显我们无法改变`afterPropertiesSet`的实现细节，那么继承`WebMvcConfigurationSupport`,重写`RequestMappingHandlerAdapter`方法，手动调用`setReturnValueHandlers`方法即可注入我们自定义的处理器。\n但是我们需要取出默认的返回值处理器，避免其他返回值处理器不起作用，`getDefaultReturnValueHandlers`是私有方法，所以我们需要使用反射取值。然后将自定义处理器插入到`RequestResponseBodyMethodProcessor`之前即可,\n这种方式会使`@ControllerAdvice`失效，慎用，更好的方式通过`@ControllerAdvice`实现同样的效果\n\n```java\npackage com.li.springboot.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodReturnValueHandler;\nimport org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor;\n\nimport java.lang.reflect.Method;\nimport java.util.List;\n\n@Configuration\npublic class WebMvc extends WebMvcConfigurationSupport {\n\n    @Override\n    public RequestMappingHandlerAdapter requestMappingHandlerAdapter() {\n        RequestMappingHandlerAdapter requestMappingHandlerAdapter = super.requestMappingHandlerAdapter();\n        try {\n            Method method = RequestMappingHandlerAdapter.class.getDeclaredMethod(\"getDefaultReturnValueHandlers\");\n            method.setAccessible(true);\n            List<HandlerMethodReturnValueHandler> returnValueHandlers = (List<HandlerMethodReturnValueHandler>) method.invoke(requestMappingHandlerAdapter);\n            System.out.println(\"invoke \" + returnValueHandlers);\n            int i = 0;\n            for (HandlerMethodReturnValueHandler handlerMethodReturnValueHandler : returnValueHandlers) {\n                if (handlerMethodReturnValueHandler instanceof RequestResponseBodyMethodProcessor) {\n                    returnValueHandlers.add(i, new MyReturnValueHandler(getMessageConverters()));\n                    break;\n                }\n                i++;\n            }\n            requestMappingHandlerAdapter.setReturnValueHandlers(returnValueHandlers);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return requestMappingHandlerAdapter;\n    }\n}\n\npackage com.li.springboot.config;\n\nimport com.li.springboot.annotation.MyResponseBody;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.http.converter.HttpMessageConverter;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.support.WebDataBinderFactory;\nimport org.springframework.web.context.request.NativeWebRequest;\nimport org.springframework.web.method.support.ModelAndViewContainer;\nimport org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@Component\npublic class MyReturnValueHandler extends AbstractMessageConverterMethodProcessor {\n    protected MyReturnValueHandler(List<HttpMessageConverter<?>> converters) {\n        super(converters);\n    }\n\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        //不需要支持请求参数\n        return false;\n    }\n\n    @Override\n    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n        return null;\n    }\n\n    @Override\n    public boolean supportsReturnType(MethodParameter returnType) {\n        //有注解@MyResponseBody的使用该处理器\n        return returnType.getMethodAnnotation(MyResponseBody.class) != null;\n    }\n\n    @Override\n    public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n        mavContainer.setRequestHandled(true);\n        Map map = new HashMap();\n        map.put(\"data\",returnValue);\n        //替换返回值\n        writeWithMessageConverters(map, returnType, webRequest);\n    }\n}\n\n```\n\n实现后我们可以看到返回值处理器的集合变化\n![返回值处理器2](./images/Spring自定义ReturnValueHandlers_返回值处理器2.jpg)\n","categories":["spring"],"tags":["spring","springboot","ReturnValueHandlers"]},{"title":"idea debug","url":"/2019/08/04/idea-debug/","content":"\n> IDEA 开发 web 项目时，建议使用`debug`启动模式，这样可以随时打断点调试项目\n\n## 1. 使用异常类型断点，在抛出异常时快速进入报错点\n\n## 2. 断点设置`condition`，仅当满足条件时触发断点\n\n## 3. 断点可设置依赖关系，仅在前置断点触发后再触发\n\n## 4. `evaluate Expression`可编写代码进行测试\n\n## 5. 使用`watches`监听属性的变化\n\n## 6. `variables`直接修改属性值，进行调试\n\n## 7. 指定线程下触发断点\n\n## 8. 移动到下个断点\n\n## option + 左键 查看变量值\n","categories":["tips"],"tags":["tips","idea","debug"]},{"title":"spring静态资源加载源码浅析","url":"/2019/08/04/spring%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/","content":"\n## 自定义资源处理器\n\n`DispatcherServlet`会拦截所有请求，针对`js`,`css`等静态资源文件，我们不期望被`controller`拦截，通过重写`WebMvcConfigurationSupport`的`addResourceHandlers`方法，由拦截指定规则的请求 url。代码如下\n\n```java\npackage com.li.springboot.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n\n@Configuration\n@EnableWebMvc\npublic class WebMvc extends WebMvcConfigurationSupport {\n    @Override\n    protected void addResourceHandlers(ResourceHandlerRegistry registry) {\n        registry.addResourceHandler(\"/static\").addResourceLocations(\"classpath:/static\");\n    }\n}\n```\n\n## 源码分析\n\n`SpringBoot`拦截 url，根据`HandlerMapping`找到对应的`Handler`去执行相关操作。\n\n`DispatcherServlet`初始化时会调用初始化方法时会加载`HandlerMapping`\n\n```java\nprivate void initHandlerMappings(ApplicationContext context) {\n    this.handlerMappings = null;\n\n    if (this.detectAllHandlerMappings) {\n        // 查找所有HandlerMapping实现类\n        Map<String, HandlerMapping> matchingBeans =\n                BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);\n        if (!matchingBeans.isEmpty()) {\n            this.handlerMappings = new ArrayList<>(matchingBeans.values());\n            // We keep HandlerMappings in sorted order.\n            AnnotationAwareOrderComparator.sort(this.handlerMappings);\n        }\n    }\n...\n```\n\n`WebMvcConfigurationSupport`的方法`resourceHandlerMapping`中注解了`@Bean`，所以自定义的资源处理器类得以被加载\n\n```java\n@Bean\n@Nullable\npublic HandlerMapping resourceHandlerMapping() {\n    Assert.state(this.applicationContext != null, \"No ApplicationContext set\");\n    Assert.state(this.servletContext != null, \"No ServletContext set\");\n\n    ResourceHandlerRegistry registry = new ResourceHandlerRegistry(this.applicationContext,\n            this.servletContext, mvcContentNegotiationManager(), mvcUrlPathHelper());\n    // 我们重写的方法\n    addResourceHandlers(registry);\n\n    AbstractHandlerMapping handlerMapping = registry.getHandlerMapping();\n    if (handlerMapping == null) {\n        return null;\n    }\n    handlerMapping.setPathMatcher(mvcPathMatcher());\n    handlerMapping.setUrlPathHelper(mvcUrlPathHelper());\n    handlerMapping.setInterceptors(getInterceptors());\n    handlerMapping.setCorsConfigurations(getCorsConfigurations());\n    return handlerMapping;\n}\n\n```\n\n重写的方法`new`了`ResourceHandlerRegistration`\n\n```java\npublic ResourceHandlerRegistration addResourceHandler(String... pathPatterns) {\n    ResourceHandlerRegistration registration = new ResourceHandlerRegistration(pathPatterns);\n    this.registrations.add(registration);\n    return registration;\n}\n```\n\n返回到`WebMvcConfigurationSupport`方法`resourceHandlerMapping`的`registry.getHandlerMapping()`中，\n\n```java\nprotected AbstractHandlerMapping getHandlerMapping() {\n    if (this.registrations.isEmpty()) {\n        return null;\n    }\n\n    Map<String, HttpRequestHandler> urlMap = new LinkedHashMap<>();\n    for (ResourceHandlerRegistration registration : this.registrations) {\n        for (String pathPattern : registration.getPathPatterns()) {\n            //找到实际handler\n            ResourceHttpRequestHandler handler = registration.getRequestHandler();\n            if (this.pathHelper != null) {\n                handler.setUrlPathHelper(this.pathHelper);\n            }\n            if (this.contentNegotiationManager != null) {\n                handler.setContentNegotiationManager(this.contentNegotiationManager);\n            }\n            handler.setServletContext(this.servletContext);\n            handler.setApplicationContext(this.applicationContext);\n            try {\n                handler.afterPropertiesSet();\n            }\n            catch (Throwable ex) {\n                throw new BeanInitializationException(\"Failed to init ResourceHttpRequestHandler\", ex);\n            }\n            urlMap.put(pathPattern, handler);\n        }\n    }\n\n    SimpleUrlHandlerMapping handlerMapping = new SimpleUrlHandlerMapping();\n    handlerMapping.setOrder(this.order);\n    handlerMapping.setUrlMap(urlMap);\n    return handlerMapping;\n}\n```\n\n`ResourceHandlerRegistration`的`getRequestHandler`\n\n```java\nprotected ResourceHttpRequestHandler getRequestHandler() {\n    ResourceHttpRequestHandler handler = new ResourceHttpRequestHandler();\n    if (this.resourceChainRegistration != null) {\n        handler.setResourceResolvers(this.resourceChainRegistration.getResourceResolvers());\n        handler.setResourceTransformers(this.resourceChainRegistration.getResourceTransformers());\n    }\n    handler.setLocationValues(this.locationValues);\n    if (this.cacheControl != null) {\n        handler.setCacheControl(this.cacheControl);\n    }\n    else if (this.cachePeriod != null) {\n        handler.setCacheSeconds(this.cachePeriod);\n    }\n    return handler;\n}\n```\n\n那么我们现在只需要搞清楚`ResourceHttpRequestHandler`中的方法是如何被调用即可。\n\n`SpringBoot`或者`SpringMVC`的请求由`DispatcherServlet`拦截所有请求，实现了`Servlet`标准。那么我们从`service`方法入口即可\n\n`DispatcherServlet`的父类`FrameworkServlet`重写了`service`方法\n\n```java\nprotected void service(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException, IOException {\n\n    HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());\n    if (httpMethod == HttpMethod.PATCH || httpMethod == null) {\n        //\n        processRequest(request, response);\n    }\n    else {\n        super.service(request, response);\n    }\n}\n```\n\n`processRequest`方法中，实际由`DispatcherServlet`实现的方法`doService`去处理。而`doService`最终调用`doDispatch`方法\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null;\n    boolean multipartRequestParsed = false;\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n    try {\n        ModelAndView mv = null;\n        Exception dispatchException = null;\n\n        try {\n            processedRequest = checkMultipart(request);\n            multipartRequestParsed = (processedRequest != request);\n\n            //查找合适的handlerMapping\n            mappedHandler = getHandler(processedRequest);\n            if (mappedHandler == null) {\n                noHandlerFound(processedRequest, response);\n                return;\n            }\n\n            // Determine handler adapter for the current request.\n            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n            // Process last-modified header, if supported by the handler.\n            String method = request.getMethod();\n            boolean isGet = \"GET\".equals(method);\n            if (isGet || \"HEAD\".equals(method)) {\n                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n                if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n                    return;\n                }\n            }\n\n            if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n                return;\n            }\n\n            // ha实际使用HttpRequestHandlerAdapter，mappedHandler.getHandler()则为ResourceHttpRequestHandler\n            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n            if (asyncManager.isConcurrentHandlingStarted()) {\n                return;\n            }\n\n            applyDefaultViewName(processedRequest, mv);\n            mappedHandler.applyPostHandle(processedRequest, response, mv);\n        }\n        catch (Exception ex) {\n            dispatchException = ex;\n        }\n        catch (Throwable err) {\n            // As of 4.3, we're processing Errors thrown from handler methods as well,\n            // making them available for @ExceptionHandler methods and other scenarios.\n            dispatchException = new NestedServletException(\"Handler dispatch failed\", err);\n        }\n        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n    }\n    catch (Exception ex) {\n        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n    }\n    catch (Throwable err) {\n        triggerAfterCompletion(processedRequest, response, mappedHandler,\n                new NestedServletException(\"Handler processing failed\", err));\n    }\n    finally {\n        if (asyncManager.isConcurrentHandlingStarted()) {\n            // Instead of postHandle and afterCompletion\n            if (mappedHandler != null) {\n                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n            }\n        }\n        else {\n            // Clean up any resources used by a multipart request.\n            if (multipartRequestParsed) {\n                cleanupMultipart(processedRequest);\n            }\n        }\n    }\n}\n```\n\n我们查看具体查找`mappedHandler`的具体实现,\n\n```java\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    //handlerMappings的加载在上文中有详细解释，这里就加载了ResourceHttpRequestHandler\n    if (this.handlerMappings != null) {\n        for (HandlerMapping mapping : this.handlerMappings) {\n            HandlerExecutionChain handler = mapping.getHandler(request);\n            if (handler != null) {\n                return handler;\n            }\n        }\n    }\n    return null;\n}\n```\n\n接着我们查看查找具体`handlerAdapter`的具体实现\n\n```java\nprotected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {\n    //和handlerMappings的加载代码细节一样，这里加载了HttpRequestHandlerAdapter\n    if (this.handlerAdapters != null) {\n        for (HandlerAdapter adapter : this.handlerAdapters) {\n            if (adapter.supports(handler)) {\n                return adapter;\n            }\n        }\n    }\n    throw new ServletException(\"No adapter for handler [\" + handler +\n            \"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\");\n}\n```\n\n`handlerAdapter`调用`handle`,对于`HttpRequestHandlerAdapter`来说，\n\n```java\n@Override\n@Nullable\npublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n        throws Exception {\n\n    ((HttpRequestHandler) handler).handleRequest(request, response);\n    return null;\n}\n```\n\n那么根据`doDispatch`中传入的`handler`即则为`ResourceHttpRequestHandler`,我们可以看到资源文件的具体加载过程。\n\n```java\n@Override\npublic void handleRequest(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException, IOException {\n\n    // For very general mappings (e.g. \"/\") we need to check 404 first\n    Resource resource = getResource(request);\n    if (resource == null) {\n        logger.debug(\"Resource not found\");\n        response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        return;\n    }\n\n    if (HttpMethod.OPTIONS.matches(request.getMethod())) {\n        response.setHeader(\"Allow\", getAllowHeader());\n        return;\n    }\n\n    // Supported methods and required session\n    checkRequest(request);\n\n    // Header phase\n    if (new ServletWebRequest(request, response).checkNotModified(resource.lastModified())) {\n        logger.trace(\"Resource not modified\");\n        return;\n    }\n\n    // Apply cache settings, if any\n    prepareResponse(response);\n\n    // Check the media type for the resource\n    MediaType mediaType = getMediaType(request, resource);\n\n    // Content phase\n    if (METHOD_HEAD.equals(request.getMethod())) {\n        setHeaders(response, resource, mediaType);\n        return;\n    }\n\n    ServletServerHttpResponse outputMessage = new ServletServerHttpResponse(response);\n    if (request.getHeader(HttpHeaders.RANGE) == null) {\n        Assert.state(this.resourceHttpMessageConverter != null, \"Not initialized\");\n        setHeaders(response, resource, mediaType);\n        this.resourceHttpMessageConverter.write(resource, mediaType, outputMessage);\n    }\n    else {\n        Assert.state(this.resourceRegionHttpMessageConverter != null, \"Not initialized\");\n        response.setHeader(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        ServletServerHttpRequest inputMessage = new ServletServerHttpRequest(request);\n        try {\n            List<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\n            this.resourceRegionHttpMessageConverter.write(\n                    HttpRange.toResourceRegions(httpRanges, resource), mediaType, outputMessage);\n        }\n        catch (IllegalArgumentException ex) {\n            response.setHeader(\"Content-Range\", \"bytes */\" + resource.contentLength());\n            response.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);\n        }\n    }\n}\n```\n","categories":["spring"],"tags":["springboot","源码","springmvc"]},{"title":"springboot静态资源定义mime类型","url":"/2019/08/02/springboot%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%AE%9A%E4%B9%89mime%E7%B1%BB%E5%9E%8B/","content":"\n## 问题描述\n\n项目中需要访问静态资源文件`xxx.ccxml`,这个文件不属于标准的文件格式。浏览器访问时，默认下载该文件。我们是期望可以直接在页面上查看的。\n\n## 背景知识\n\n> MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。\n\n详情可参考[MIME 参考文档](https://baike.baidu.com/item/MIME/2900607?fr=aladdin)\n\n## 解决方案\n\n我们注册关于`ccxml`扩展类型的默认打开方式即可。\n\n一般情况下，在`tomcat`目录下的`conf/web.xml`修改或新增\n\n```xml\n <mime-mapping>\n        <extension>ccxml</extension>\n        <mime-type>application/xml</mime-type>\n </mime-mapping>\n```\n\n针对于`SpringBoot`的内置容器，提供了接口以供修改\n\nSpring Boot 1:\n\n```java\n@Configuration\npublic class HbbtvMimeMapping implements EmbeddedServletContainerCustomizer {\n\n    @Override\n    public void customize(ConfigurableEmbeddedServletContainer container) {\n        MimeMappings mappings = new MimeMappings(MimeMappings.DEFAULT);\n        mappings.add(\"ccxml\", \"application/xml; charset=utf-8\");\n        container.setMimeMappings(mappings);\n    }\n\n}\n```\n\nSpring Boot 2:\n\n```java\n@Configuration\npublic class HbbtvMimeMapping implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {\n    @Override\n    public void customize(ConfigurableServletWebServerFactory factory) {\n        MimeMappings mappings = new MimeMappings(MimeMappings.DEFAULT);\n        mappings.add(\"ccxml\", \"application/xml; charset=utf-8\");\n        factory.setMimeMappings(mappings);\n    }\n}\n```\n\n## Spring 加载静态资源的`mime`源码分析\n\n针对`SpringBoot2`，一般我们使用的是`tomcat`容器,我们自定义的加载`mimeType`的类注入了`ConfigurableServletWebServerFactory`实现类中`TomcatServletWebServerFactory`，其方法`configureContext`将自定义的`mimeType`存储到集合中\n节选片段\n\n```java\nfor (MimeMappings.Mapping mapping : getMimeMappings()) {\n    //getMimeMappings即为用自定义添加的扩展\n    //context实现类StandardContext\n    context.addMimeMapping(mapping.getExtension(), mapping.getMimeType());\n}\n```\n\n`StandardContext`\n\n```java\n@Override\npublic void addMimeMapping(String extension, String mimeType) {\n\n    synchronized (mimeMappings) {\n        //对外暴露的接口findMimeMapping\n        mimeMappings.put(extension.toLowerCase(Locale.ENGLISH), mimeType);\n    }\n    fireContainerEvent(\"addMimeMapping\", extension);\n\n}\n```\n\n根据{% post_link spring静态资源加载源码浅析 %}中的分析，找到`ResourceHttpRequestHandler`，实际执行方法`handleRequest`节选代码片段\n\n```java\nMediaType mediaType = getMediaType(request, resource);\n\nif (METHOD_HEAD.equals(request.getMethod())) {\n    setHeaders(response, resource, mediaType);\n    return;\n}\n```\n\n我们先看下`MediaType`的加载，\n\n```java\nprotected MediaType getMediaType(HttpServletRequest request, Resource resource) {\n    return (this.contentNegotiationStrategy != null ?\n            this.contentNegotiationStrategy.getMediaTypeForResource(resource) : null);\n}\n```\n\n`this.contentNegotiationStrategy`有方法`initContentNegotiationStrategy`来加载\n\n```java\nprotected PathExtensionContentNegotiationStrategy initContentNegotiationStrategy() {\n    Map<String, MediaType> mediaTypes = null;\n    if (getContentNegotiationManager() != null) {\n        PathExtensionContentNegotiationStrategy strategy =\n                getContentNegotiationManager().getStrategy(PathExtensionContentNegotiationStrategy.class);\n        if (strategy != null) {\n            mediaTypes = new HashMap<>(strategy.getMediaTypes());\n        }\n    }\n    //可以看出一般情况下加载ServletPathExtensionContentNegotiationStrategy\n    return (getServletContext() != null ?\n            new ServletPathExtensionContentNegotiationStrategy(getServletContext(), mediaTypes) :\n            new PathExtensionContentNegotiationStrategy(mediaTypes));\n}\n```\n\n我们追踪`PathExtensionContentNegotiationStrategy`的`getMediaTypeForResource`方法中\n\n```java\npublic MediaType getMediaTypeForResource(Resource resource) {\n    MediaType mediaType = null;\n    //我们可以看到mimeType和servletcontext上下文有关\n    String mimeType = this.servletContext.getMimeType(resource.getFilename());\n    if (StringUtils.hasText(mimeType)) {\n        mediaType = MediaType.parseMediaType(mimeType);\n    }\n    if (mediaType == null || MediaType.APPLICATION_OCTET_STREAM.equals(mediaType)) {\n        MediaType superMediaType = super.getMediaTypeForResource(resource);\n        if (superMediaType != null) {\n            mediaType = superMediaType;\n        }\n    }\n    return mediaType;\n}\n\n```\n\n那么我们看下具体的`servletContext.getMimeType`实现，针对`SpringBoot2`，一般我们使用的是`tomcat`容器，\n我们可定位到`ApplicationContext`\n\n```java\n@Override\npublic String getMimeType(String file) {\n\n    if (file == null)\n        return null;\n    int period = file.lastIndexOf('.');\n    if (period < 0)\n        return null;\n    String extension = file.substring(period + 1);\n    if (extension.length() < 1)\n        return null;\n    //此处context既是一开始提到的StandardContext，即可得到上文中我们自定义添加的mimetype\n    return context.findMimeMapping(extension);\n\n}\n```\n\n最后可以看到`response`的`ContentType`和`mediaType`息息相关。\n\n```java\nprotected void setHeaders(HttpServletResponse response, Resource resource, @Nullable MediaType mediaType)\n        throws IOException {\n\n    long length = resource.contentLength();\n    if (length > Integer.MAX_VALUE) {\n        response.setContentLengthLong(length);\n    }\n    else {\n        response.setContentLength((int) length);\n    }\n\n    if (mediaType != null) {\n        //实际返回content-Type和MediaType有关\n        response.setContentType(mediaType.toString());\n    }\n    if (resource instanceof HttpResource) {\n        HttpHeaders resourceHeaders = ((HttpResource) resource).getResponseHeaders();\n        resourceHeaders.forEach((headerName, headerValues) -> {\n            boolean first = true;\n            for (String headerValue : headerValues) {\n                if (first) {\n                    response.setHeader(headerName, headerValue);\n                }\n                else {\n                    response.addHeader(headerName, headerValue);\n                }\n                first = false;\n            }\n        });\n    }\n    response.setHeader(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n}\n```\n","categories":["spring"],"tags":["springboot","mime","问题"]},{"title":"vscode相关","url":"/2019/08/01/vscode%E7%9B%B8%E5%85%B3/","content":"\n## vim 自动切换输入法\n\n安装软件\n\n```shell\ncurl -Ls https://raw.githubusercontent.com/daipeihust/im-select/master/install_mac.sh | sh\n```\n\n软件会默认安装到目录`/user/local/bin/`下, 无参数执行时就会输出默认输入法的字符\n\n```log\n/usr/local/bin$ im-select\ncom.apple.keylayout.ABC\n```\n\n打开`vscode`的默认配置文件`setting.json`,新增如下配置\n\n```json\n    \"vim.autoSwitchInputMethod.enable\": true,\n    \"vim.autoSwitchInputMethod.defaultIM\": \"com.apple.keylayout.ABC\",\n    \"vim.autoSwitchInputMethod.obtainIMCmd\": \"/usr/local/bin/im-select\",\n    \"vim.autoSwitchInputMethod.switchIMCmd\": \"/usr/local/bin/im-select {im}\"\n```\n\n其中默认`defaultIM`的值为你需要自动切换的默认输入法\n\n## 保存后自动运行\n\n1.安装[Code Runner](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner)\n\n在`settings.json`中配置\n\n```json\n \"code-runner.executorMapByFileExtension\": {\n     \".scm\": \"scheme --quiet<\",\n }\n```\n\n有些情况下可能需要添加如下配置才生效\n\n```json\n\"code-runner.executorMap\": {\n    \"scheme\": \"scheme --quiet< \\\"$dir$fileName\\\"\"\n}\n```\n\n2.安装[Run on Save](https://marketplace.visualstudio.com/items?itemName=pucelle.run-on-save)\n\n在`settings.json`中配置\n\n```json\n\"runOnSave.commands\": [\n    {\n        \"match\": \"\\\\.scm$\",\n        \"command\": \"scheme --quiet < ${file}\",\n        \"runIn\": \"backend\"\n    }\n]\n```\n\n具体详情配置可参考插件的文档\n\n## 最近打开文件\n\nopen recent file `⌃ R`\n\n## 括号匹配色\n\n彩虹括号\n使用 [Bracket Pair Colorizer2](https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer-2)\n\n颜色方案(使用黑色主题)使用如下在`settings.json`中配置\n\n```json\n\"bracket-pair-colorizer-2.colors\": [\n\n        \"#289CF4\",\n        \"#FED02F\",\n        \"#2CDD18\",\n        \"#FF5FFF\",\n        \"#D10000\",\n        \"#D05355\",\n        \"#fff\",\n    ]\n\n```\n\n## 是否显示侧边栏\n\n`Toggle activitiy Bar Visibility` 带图标的侧边工具栏\n\n`Toggle side Bar Visibility`快捷键`⌘b` 具体工具栏的实际内容\n\n## 合并当前行\n\njoin line `⌃ R`\n\n## 自定义代码片段\n\n1. `Configure user Snippets`\n2. 选择生效的语言\n3. 进行配置\n\nscope 不是文件扩展名\n\n```json\n\"Print to console\": {\n    \"scope\": \"scheme\",\n    \"prefix\": \"log\",\n    \"body\": [\n        \"(write-line ($0))\",\n    ],\n    \"description\": \"Log output to console\"\n}\n```\n\n我们可以使用`$name`，取变量的值，若没有值，可以使用`${name:defaultText}`默认值\n\n1）文档相关：\n\n| 变量             | 变量含义                       |\n| :--------------- | :----------------------------- |\n| TM_SELECTED_TEXT | 当前选定的文本或空字符串       |\n| TM_CURRENT_LINE  | 当前行的内容                   |\n| TM_CURRENT_WORD  | 光标下的单词内容或空字符串     |\n| TM_LINE_INDEX    | 基于零索引的行号               |\n| TM_LINE_NUMBER   | 基于单索引的行号               |\n| TM_FILENAME      | 当前文档的文件名               |\n| TM_FILENAME_BASE | 当前文档没有扩展名的文件名     |\n| TM_DIRECTORY     | 当前文档的目录                 |\n| TM_FILEPATH      | 当前文档的完整文件路径         |\n| CLIPBOARD        | 剪贴板的内容                   |\n| WORKSPACE_NAME   | 已打开的工作空间或文件夹的名称 |\n\n2 ）当前日期和时间：\n\n| 变量                     | 变量含义                                        |\n| :----------------------- | :---------------------------------------------- |\n| CURRENT_YEAR             | 当前年份                                        |\n| CURRENT_YEAR_SHORT       | 当前年份的最后两位数                            |\n| CURRENT_MONTH            | 月份为两位数（例如'02'）                        |\n| CURRENT_MONTH_NAME       | 月份的全名（例如'June'）（中文语言对应六月）    |\n| CURRENT_MONTH_NAME_SHORT | 月份的简称（例如'Jun'）（中文语言对应是 6 月）  |\n| CURRENT_DATE             | 这个月的哪一天                                  |\n| CURRENT_DAY_NAME         | 当天是星期几（例如'星期一'）                    |\n| CURRENT_DAY_NAME_SHORT   | 当天是星期几的简称（例如'Mon'）（中文对应周一） |\n| CURRENT_HOUR             | 24 小时时钟格式的当前小时                       |\n| CURRENT_MINUTE           | 当前分                                          |\n| CURRENT_SECOND           | 当前秒                                          |\n\n## `markdown`图片插件\n\n使用[Paste Image](https://marketplace.visualstudio.com/items?itemName=mushan.vscode-paste-image)\n\n```json\n//图片的默认名称，当选中文字时，文字会作为默认的名称\n\"pasteImage.defaultName\": \"${currentFileNameWithoutExt}\",\n\"pasteImage.namePrefix\": \"${currentFileNameWithoutExt}_\",\n\"pasteImage.path\": \"${projectRoot}/source/images\",\n\"pasteImage.basePath\": \"${projectRoot}/source\",\n\"pasteImage.forceUnixStyleSeparator\": true,\n\"pasteImage.prefix\": \"/\",\n//插入markdown的语法\n\"pasteImage.insertPattern\": \"![${imageFileName}](./images/${imageFileName})\"\n```\n\n## 快捷键\n\n`ctrl + tab`切换窗口\n","categories":["vscode"],"tags":["vscode","插件"]},{"title":"gson使用手册","url":"/2019/08/01/gson%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","content":"\n## 基本类型\n\n```java\n// Serialization\nGson gson = new Gson();\ngson.toJson(1);            // ==> 1\ngson.toJson(\"abcd\");       // ==> \"abcd\"\ngson.toJson(new Long(10)); // ==> 10\nint[] values = { 1 };\ngson.toJson(values);       // ==> [1]\n\n// Deserialization\nint one = gson.fromJson(\"1\", int.class);\nInteger one = gson.fromJson(\"1\", Integer.class);\nLong one = gson.fromJson(\"1\", Long.class);\nBoolean false = gson.fromJson(\"false\", Boolean.class);\nString str = gson.fromJson(\"\\\"abc\\\"\", String.class);\nString[] anotherStr = gson.fromJson(\"[\\\"abc\\\"]\", String[].class);\n```\n\n## 类\n\n```java\nclass BagOfPrimitives {\n  private int value1 = 1;\n  private String value2 = \"abc\";\n  private transient int value3 = 3;\n  BagOfPrimitives() {\n    // no-args constructor\n  }\n}\n\n// Serialization\nBagOfPrimitives obj = new BagOfPrimitives();\nGson gson = new Gson();\nString json = gson.toJson(obj);\n\n// ==> json is {\"value1\":1,\"value2\":\"abc\"}\n```\n\n注意事项\n\n1. 类的属性推荐使用`private`\n2. 默认情况下被`transient`修饰的属性会被忽略\n3. 序列化时为值`null`的属性将会被忽略\n4. 反序列化时，值`null`的属性将会被赋值为`零值`\n\n## 数组\n\n```java\nGson gson = new Gson();\nint[] ints = {1, 2, 3, 4, 5};\nString[] strings = {\"abc\", \"def\", \"ghi\"};\n\n// Serialization\ngson.toJson(ints);     // ==> [1,2,3,4,5]\ngson.toJson(strings);  // ==> [\"abc\", \"def\", \"ghi\"]\n\n// Deserialization\nint[] ints2 = gson.fromJson(\"[1,2,3,4,5]\", int[].class);\n// ==> ints2 will be same as ints\n```\n\n## 集合\n\n```java\nGson gson = new Gson();\nCollection<Integer> ints = Lists.immutableList(1,2,3,4,5);\n\n// Serialization\nString json = gson.toJson(ints);  // ==> json is [1,2,3,4,5]\n\n// Deserialization\nType collectionType = new TypeToken<Collection<Integer>>(){}.getType();\nCollection<Integer> ints2 = gson.fromJson(json, collectionType);\n// ==> ints2 is same as ints\n```\n\n## 泛型\n\n```java\nclass Foo<T> {\n  T value;\n}\nGson gson = new Gson();\n\nFoo<Bar> foo = new Foo<Bar>();\nType fooType = new TypeToken<Foo<Bar>>() {}.getType();\ngson.toJson(foo, fooType);\n\ngson.fromJson(json, fooType);\n```\n\n使用`TypeToken`可指定泛型\n\n## 内置解析器\n\n`java.net.URL`可以匹配如下格式的值`\"https://github.com/google/gson/\"`\n`java.net.URI` 可以匹配如下格式的值`\"/google/gson/\"`\n\n```java\nGson gson = new Gson();\nString json = \"{\\\"url\\\": \\\"https://github.com/google/gson/\\\",\\\"uri\\\": \\\"/google/gson/\\\"}\";\nTestUrl testUrl = gson.fromJson(json, TestUrl.class);\n// toString -->  GsonTest.TestUrl(url=https://github.com/google/gson/, uri=/google/gson/)\n\n@Data\npublic static class TestUrl{\n    private URL url;\n    private URI uri;\n}\n```\n\n## 自定义序列化与反序列化\n\n需要序列化的类`UserBean`\n\n```java\n@Data\npublic class UserBean {\n    private String name;\n}\n```\n\n序列化处理器，泛型为`UserBean`\n\n```java\n public class UserJsonSerializer implements JsonSerializer<UserBean>{\n\n    @Override\n    public JsonElement serialize(UserBean src, Type typeOfSrc, JsonSerializationContext context) {\n        //src 即是待序列化的实例对象\n        JsonObject userJson= new JsonObject();\n        userJson.addProperty(\"__name__\",src.getName());\n        return userJson;\n    }\n}\n```\n\n反序列化处理器，泛型为`UserBean`\n\n```java\n public class UserJsonDeserializer implements JsonDeserializer<UserBean>{\n\n    @Override\n    public UserBean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {\n        UserBean userBean = new UserBean();\n        //json 即为待反序列化的字符串生成的json对象\n        JsonObject asJsonObject = json.getAsJsonObject();\n        if(asJsonObject.has(\"__name__\")){\n            userBean.setName(String.valueOf(asJsonObject.get(\"__name__\")));\n        }\n        return userBean;\n    }\n}\n```\n\n测试程序，注册`UserBean`的`TypeToken`的序列化与反序列化处理器\n\n```java\nGsonBuilder gsonBuilder = new GsonBuilder();\nType type= new TypeToken<UserBean>() {}.getType();\ngsonBuilder.registerTypeAdapter(type,new UserJsonSerializer());\ngsonBuilder.registerTypeAdapter(type,new UserJsonDeserializer());\nGson gson = gsonBuilder.create();\nUserBean userBean = new UserBean();\nuserBean.setName(\"123\");\nString json = gson.toJson(userBean);\n// {\"__name__\":\"123\"}\nuserBean = gson.fromJson(json, UserBean.class);\n//UserBean(name=\"123\")\n```\n\n## 使用 JsonSerializer 统一处理 null\n\n```java\npackage com.leaderli.demo.util;\n\nimport com.google.gson.*;\nimport org.junit.jupiter.api.Test;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\n\npublic class GsonTest {\n\n    private static class MapJsonSerializer implements JsonSerializer {\n\n        @Override\n        public JsonElement serialize(Object o, Type type, JsonSerializationContext jsonSerializationContext) {\n            return serialize(o,(Class)type);\n        }\n\n\n        private <T> JsonElement serialize(Object o, Class<T> type) {\n            if (Map.class.isAssignableFrom(type)) {\n                JsonObject jsonObject = new JsonObject();\n                Map<?, ?> map = (Map) o;\n                map.forEach((k, v) -> {\n                    if (k == null) {\n                        return;\n                    }\n                    String key = String.valueOf(k);\n                    if (v == null) {\n                        jsonObject.add(key, new JsonPrimitive(\"\"));\n                    } else {\n                        jsonObject.add(key, serialize(v, v.getClass()));\n                    }\n\n                });\n                return jsonObject;\n            } else if (Iterable.class.isAssignableFrom(type)) {\n                Iterable<?> iterable = (Iterable) o;\n                JsonArray array = new JsonArray();\n                iterable.forEach(e -> {\n                    if (e == null) {\n                        array.add(new JsonPrimitive(\"\"));\n                    } else {\n\n                        array.add(serialize(e, e.getClass()));\n                    }\n\n                });\n                return array;\n            } else {\n\n                return new JsonPrimitive(String.valueOf(o));\n            }\n        }\n    }\n\n    @Test\n    public void test() {\n\n        Gson gson = new GsonBuilder().registerTypeHierarchyAdapter(Map.class, new MapJsonSerializer()).create();\n\n        Map map = new HashMap();\n        map.put(\"str\",null);\n        map.put(\"set\",new HashSet<>());\n        ArrayList<Object> list = new ArrayList<>();\n        list.add(1);\n        list.add(null);\n        map.put(\"list\", list);\n        Map temp= new HashMap();\n        temp.put(\"temp\",null);\n        map.put(\"temp\",temp);\n\n        System.out.println(gson.toJson(map));\n\n\n    }\n}\n\n```\n\n> {\"str\":\"\",\"temp\":{\"temp\":\"\"},\"set\":[],\"list\":[\"1\",\"\"]}\n\n## 优化打印\n\n```java\nGson gson = new GsonBuilder().setPrettyPrinting().create();\nPerson person= new Person();\nperson.setAge(1);\nperson.setName(\"hello\");\nSystem.out.println(gson.toJson(person))\n```\n\n打印结果如下\n\n```json\n{\n  \"name\": \"hello\",\n  \"age\": 1\n}\n```\n","categories":["tips"],"tags":["tips","gson"]},{"title":"mybatis入门","url":"/2019/07/31/mybatis%E5%85%A5%E9%97%A8/","content":"\n## 版本说明\n\n`jdk`:1.8.0_131\n`springboot`:2.1.6.RELEAS\n`maven`:3.6.1\n`database`:mysql-5.7.1\n`mybatis`:3.5.2\n`lombok插件`\n\n## 概述\n\n基于[官方文档](http://www.mybatis.org/mybatis-3/getting-started.html)的学习笔记。项目基于`maven`构建,项目主要介绍`mybatis`的使用，因此基本不使用`Spring`的相关代码\n\n建表语句如下，建表语句来自[git-mybatis-3](https://github.com/mybatis/mybatis-3/tree/master/src/test/java/org/apache/ibatis/databases/blog)，针对`mysql`进行部分修改\n\n```sql\n-- create your own database\n\nDROP TABLE IF EXISTS comment;\nDROP TABLE IF EXISTS post_tag;\nDROP TABLE IF EXISTS tag;\nDROP TABLE IF EXISTS post;\nDROP TABLE IF EXISTS blog;\nDROP TABLE IF EXISTS author;\nDROP TABLE IF EXISTS node;\n\nCREATE TABLE author (\n  id                INT PRIMARY KEY AUTO_INCREMENT,\n  username          VARCHAR(255) NOT NULL,\n  password          VARCHAR(255) NOT NULL,\n  email             VARCHAR(255) NOT NULL,\n  bio               BLOB,\n  favourite_section VARCHAR(25)\n)\n  AUTO_INCREMENT = 10000;\n\nCREATE TABLE blog (\n  id        INT PRIMARY KEY AUTO_INCREMENT,\n  author_id INT NOT NULL,\n  title     VARCHAR(255)\n);\n\nCREATE TABLE post (\n  id         INT PRIMARY KEY AUTO_INCREMENT,\n  blog_id    INT,\n  author_id  INT          NOT NULL,\n  created_on TIMESTAMP,\n  section    VARCHAR(25)  NOT NULL,\n  subject    VARCHAR(255) NOT NULL,\n  body       BLOB         NOT NULL,\n  draft      INT          NOT NULL,\n  FOREIGN KEY (blog_id) REFERENCES blog (id)\n);\n\nCREATE TABLE tag (\n  id   INT PRIMARY KEY AUTO_INCREMENT,\n  name VARCHAR(255) NOT NULL\n);\n\nCREATE TABLE post_tag (\n  post_id INT NOT NULL,\n  tag_id  INT NOT NULL,\n  PRIMARY KEY (post_id, tag_id)\n);\n\nCREATE TABLE comment (\n  id      INT PRIMARY KEY AUTO_INCREMENT,\n  post_id INT      NOT NULL,\n  name    LONGTEXT NOT NULL,\n  comment LONGTEXT NOT NULL\n);\n\nCREATE TABLE node (\n  id        INT NOT NULL,\n  parent_id INT,\n  PRIMARY KEY (id)\n);\n\n\nINSERT INTO author (id, username, password, email, bio, favourite_section)\nVALUES (101, 'jim', '********', 'jim@ibatis.apache.org', '', 'NEWS');\nINSERT INTO author (id, username, password, email, bio, favourite_section)\nVALUES (102, 'sally', '********', 'sally@ibatis.apache.org', NULL, 'VIDEOS');\n\nINSERT INTO blog (id, author_id, title) VALUES (1, 101, 'Jim Business');\nINSERT INTO blog (id, author_id, title) VALUES (2, 102, 'Bally Slog');\n\nINSERT INTO post (id, blog_id, author_id, created_on, section, subject, body, draft) VALUES\n  (1, 1, 101, '2008-01-01 00:00:01', 'NEWS', 'Corn nuts',\n   'I think if I never smelled another corn nut it would be too soon...', 1);\nINSERT INTO `post` (id, blog_id, author_id, created_on, section, subject, body, draft)\nVALUES (2, 1, 101, '2008-01-12 00.00.00', 'VIDEOS', 'Paul Hogan on Toy Dogs', 'That''s not a dog.  THAT''s a dog!', 0);\nINSERT INTO post (id, blog_id, author_id, created_on, section, subject, body, draft)\nVALUES (3, 2, 102, '2007-12-05 00.00.00', 'PODCASTS', 'Monster Trucks', 'I think monster trucks are great...', 1);\nINSERT INTO post (id, blog_id, author_id, created_on, section, subject, body, draft) VALUES\n  (4, 2, 102, '2008-01-12 00.00.00', 'IMAGES', 'Tea Parties', 'A tea party is no place to hold a business meeting...',\n   0);\n\nINSERT INTO post (id, blog_id, author_id, created_on, section, subject, body, draft)\nVALUES (5, NULL, 101, '2008-01-12 00.00.00', 'IMAGES', 'An orphaned post', 'this post is orphaned', 0);\n\nINSERT INTO tag (id, name) VALUES (1, 'funny');\nINSERT INTO tag (id, name) VALUES (2, 'cool');\nINSERT INTO tag (id, name) VALUES (3, 'food');\n\nINSERT INTO post_tag (post_id, tag_id) VALUES (1, 1);\nINSERT INTO post_tag (post_id, tag_id) VALUES (1, 2);\nINSERT INTO post_tag (post_id, tag_id) VALUES (1, 3);\nINSERT INTO post_tag (post_id, tag_id) VALUES (2, 1);\nINSERT INTO post_tag (post_id, tag_id) VALUES (4, 3);\n\nINSERT INTO comment (id, post_id, name, comment) VALUES (1, 1, 'troll', 'I disagree and think...');\nINSERT INTO comment (id, post_id, name, comment) VALUES (2, 1, 'anonymous', 'I agree and think troll is an...');\nINSERT INTO comment (id, post_id, name, comment)\nVALUES (4, 2, 'another', 'I don not agree and still think troll is an...');\nINSERT INTO comment (id, post_id, name, comment) VALUES (3, 3, 'rider', 'I prefer motorcycles to monster trucks...');\n\n\nINSERT INTO node (id, parent_id) VALUES (1, NULL);\nINSERT INTO node (id, parent_id) VALUES (2, 1);\nINSERT INTO node (id, parent_id) VALUES (3, 1);\nINSERT INTO node (id, parent_id) VALUES (4, 2);\nINSERT INTO node (id, parent_id) VALUES (5, 2);\nINSERT INTO node (id, parent_id) VALUES (6, 3);\nINSERT INTO node (id, parent_id) VALUES (7, 3);\n\n```\n\npom 文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.li</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <dependencies>\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis</artifactId>\n      <version>3.5.2</version>\n    </dependency>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.11</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.projectlombok</groupId>\n      <artifactId>lombok</artifactId>\n      <version>1.18.4</version>\n    </dependency>\n  </dependencies>\n</project>\n```\n\n`mybatis`配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n    PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n    \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n  <properties resource=\"config.properties\">\n  </properties>\n  <typeAliases>\n    <package name=\"org.mybatis.example\"/>\n  </typeAliases>\n  <environments default=\"development\">\n    <environment id=\"development\">\n      <transactionManager type=\"JDBC\"/>\n      <dataSource type=\"POOLED\">\n        <property name=\"driver\" value=\"${driver}\"/>\n        <property name=\"url\" value=\"${url}\"/>\n        <property name=\"username\" value=\"${username}\"/>\n        <property name=\"password\" value=\"${password}\"/>\n      </dataSource>\n    </environment>\n    </environments>\n  <mappers>\n    <package  name=\"org.mybatis.example\"/>\n  </mappers>\n</configuration>\n```\n\n## properties\n\n定义配置文件地址，标签属性值可以`${xxx}`取配置文件的值\n\n## DataSource\n\n`dataSource`标签用来定义一个标准的`DataSource`标准，`mybatis`内置了三种类型的`DataSource`\n\n> `type=\"[UNPOOLED|POOLED|JNDI]\"`\n\n### `UNPOOLED`\n\n每一次数据操作都新建。可做如下配置\n\n> `driver`  \n> `url` > `username`  \n> `password`  \n> `defaultTransactionIsolationLevel`:数据库隔离级别  \n> `defaultNetworkTimeout`\n> 同时可以为`driver`设置属性`driver.encoding=UTF8`\n\n### `POOLED`\n\n使用连接池来管理数据源,除了`UNPOOLED`的配置还可做如下配置\n\n> `poolMaximumActiveConnections`  \n> `poolMaximumIdleConnections`  \n> `poolMaximumCheckoutTime`  \n> `poolTimeToWait`  \n> `poolMaximumLocalBadConnectionTolerance`  \n> `poolPingQuery`  \n> `poolPingEnabled`  \n> `poolPingConnectionsNotUsedFor`\n\n### `JNDI`\n\n`initial_context`\n`data_source`\n\n`env.`前缀的配置将被加载到`InitialContext`中\n`env.encoding=UTF8`\n\n```xml\n<dataSource type=\"JNDI\">\n  <property name=\"data_source\" value=\"java:/comp/env/jdbc/mysql\"/>\n</dataSource>\n```\n\n### 自定义类型\n\n`type`可指定为其他工厂类\n\n```xml\n<dataSource type=\"org.myproject.C3P0DataSourceFactory\">\n    <property name=\"driver\" value=\"${driver}\"/>\n    <property name=\"url\" value=\"${url}\"/>\n    <property name=\"username\" value=\"${username}\"/>\n    <property name=\"password\" value=\"${password}\"/>\n</dataSource>\n```\n\nenv.encoding=UTF8\n\n## mappers\n\n定位映射的`SQL`语句\n\n```xml\n<mappers>\n  <mapper url=\"file:/Users/BlogMapper.xml\"/>\n  <mapper class=\"org.mybatis.example.BlogMapper\"/>\n  <mapper resource=\"org.mybatis.example.BlogMapper.xml\"/>\n  <package  name=\"org.mybatis.example\"/>\n</mappers>\n```\n\n## typeAliases\n\n`mybatis`默认别名有如下\n\n|    别名    | class 类型 |\n| :--------: | :--------: |\n|   \\_byte   |    byte    |\n|   \\_long   |    long    |\n|  \\_short   |   short    |\n|   \\_int    |    int     |\n| \\_integer  |    int     |\n|  \\_double  |   double   |\n|  \\_float   |   float    |\n| \\_boolean  |  boolean   |\n|   string   |   String   |\n|    byte    |    Byte    |\n|    long    |    Long    |\n|   short    |   Short    |\n|    int     |  Integer   |\n|  integer   |  Integer   |\n|   double   |   Double   |\n|   float    |   Float    |\n|  boolean   |  Boolean   |\n|    date    |    Date    |\n|  decimal   | BigDecimal |\n| bigdecimal | BigDecimal |\n|   object   |   Object   |\n|    map     |    Map     |\n|  hashmap   |  HashMap   |\n|    list    |    List    |\n| arraylist  | ArrayList  |\n| collection | Collection |\n|  iterator  |  Iterator  |\n\n可指定其他别名\n\n```xml\n<typeAliases>\n  <typeAlias type=\"org.mybatis.example.Blog\" alias=\"blog\"/>\n  <package name=\"org.mybatis.example\"/>\n</typeAliases>\n```\n\n别名可供`resultType`或`parameterType`使用\n\n## typeHandlers\n\n每当 MyBatis 在 PreparedStatement 上设置参数或从 ResultSet 中检索值时，都会使用 TypeHandler 以适合 Java 类型的方式检索值。 下表描述了默认的 TypeHandlers。\n\n| Type Handler               | java Types                    | JDBC Types                                                                         |\n| :------------------------- | :---------------------------- | :--------------------------------------------------------------------------------- |\n| BooleanTypeHandler         | java.lang.Boolean, boolean    | Any compatible BOOLEAN                                                             |\n| ByteTypeHandler            | java.lang.Byte, byte          | Any compatible NUMERIC or BYTE                                                     |\n| ShortTypeHandler           | java.lang.Short, short        | Any compatible NUMERIC or SMALLINT                                                 |\n| IntegerTypeHandler         | java.lang.Integer, int        | Any compatible NUMERIC or INTEGER                                                  |\n| LongTypeHandler            | java.lang.Long, long          | Any compatible NUMERIC or BIGINT                                                   |\n| FloatTypeHandler           | java.lang.Float, float        | Any compatible NUMERIC or FLOAT                                                    |\n| DoubleTypeHandler          | java.lang.Double, double      | Any compatible NUMERIC or DOUBLE                                                   |\n| BigDecimalTypeHandler      | java.math.BigDecimal          | Any compatible NUMERIC or DECIMAL                                                  |\n| StringTypeHandler          | java.lang.String              | CHAR, VARCHAR                                                                      |\n| ClobReaderTypeHandler      | java.io.Reader                | -                                                                                  |\n| ClobTypeHandler            | java.lang.String              | CLOB, LONGVARCHAR                                                                  |\n| NStringTypeHandler         | java.lang.String              | NVARCHAR, NCHAR                                                                    |\n| NClobTypeHandler           | java.lang.String              | NCLOB                                                                              |\n| BlobInputStreamTypeHandler | java.io.InputStream           | -                                                                                  |\n| ByteArrayTypeHandler       | byte[]                        | Any compatible byte stream type                                                    |\n| BlobTypeHandler            | byte[]                        | BLOB, LONGVARBINARY                                                                |\n| DateTypeHandler            | java.util.Date                | TIMESTAMP                                                                          |\n| DateOnlyTypeHandler        | java.util.Date                | DATE                                                                               |\n| TimeOnlyTypeHandler        | java.util.Date                | TIME                                                                               |\n| SqlTimestampTypeHandler    | java.sql.Timestamp            | TIMESTAMP                                                                          |\n| SqlDateTypeHandler         | java.sql.Date                 | DATE                                                                               |\n| SqlTimeTypeHandler         | java.sql.Time                 | TIME                                                                               |\n| ObjectTypeHandler          | Any OTHER, or unspecified     |                                                                                    |\n| EnumTypeHandler            | Enumeration Type              | VARCHAR any string compatible type, as the code is stored (not index).             |\n| EnumOrdinalTypeHandler     | Enumeration Type              | Any compatible NUMERIC or DOUBLE, as the position is stored (not the code itself). |\n| SqlxmlTypeHandler          | java.lang.String              | SQLXML                                                                             |\n| InstantTypeHandler         | java.time.Instant             | TIMESTAMP                                                                          |\n| LocalDateTimeTypeHandler   | java.time.LocalDateTime       | TIMESTAMP                                                                          |\n| LocalDateTypeHandler       | java.time.LocalDate           | DATE                                                                               |\n| LocalTimeTypeHandler       | java.time.LocalTime           | TIME                                                                               |\n| OffsetDateTimeTypeHandler  | java.time.OffsetDateTime      | TIMESTAMP                                                                          |\n| OffsetTimeTypeHandler      | java.time.OffsetTime          | TIME                                                                               |\n| ZonedDateTimeTypeHandler   | java.time.ZonedDateTime       | TIMESTAMP                                                                          |\n| YearTypeHandler            | java.time.Year                | INTEGER                                                                            |\n| MonthTypeHandler           | java.time.Month               | INTEGER                                                                            |\n| YearMonthTypeHandler       | java.time.YearMonth           | VARCHAR or LONGVARCHAR                                                             |\n| JapaneseDateTypeHandler    | java.time.chrono.JapaneseDate | DATE                                                                               |\n\n你可以通过继承`org.apache.ibatis.type.TypeHandler`或者使用`org.apache.ibatis.type.BaseTypeHandler`来使用非标准的`TypeHandler`\n\n在配置文件`typeHandlers`中的`typeHandler`标签中配置`jdbcType`,可指定`sql`表字段类型，若实际`java`类注解了`@MappedJdbcTypes`，会无视配置文件  \n在配置文件`typeHandlers`中的`typeHandler`标签中配置`javaType`,可指定`javaBean`类型，若实际`java`类注解了`@MappedTypes`，会无视配置文件  \n示例如下：\n\n```java\npackage org.mybatis.example;\n\nimport org.apache.ibatis.type.BaseTypeHandler;\nimport org.apache.ibatis.type.JdbcType;\nimport org.apache.ibatis.type.MappedJdbcTypes;\n\nimport java.sql.CallableStatement;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n/**\n* includeNullJdbcType=true表示当sql字段类型未知也可使用\n*/\n@MappedJdbcTypes(value=JdbcType.VARCHAR,includeNullJdbcType=true)\n@MappedTypes(String.class)\npublic class ExampleTypeHandler extends BaseTypeHandler<String> {\n\n    @Override\n    public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {\n        ps.setString(i, parameter+\"_sql\");\n    }\n\n    @Override\n    public String getNullableResult(ResultSet rs, String columnName) throws SQLException {\n        return rs.getString(columnName)+\"_java\";\n    }\n\n    @Override\n    public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {\n        return rs.getString(columnIndex)+\":java\";\n    }\n\n    @Override\n    public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {\n        return cs.getString(columnIndex)+\"#java\";\n    }\n}\n\n```\n\n在`mybatis`配置文件中若配置了`<typehandlers>`将会替换默认的数据库类型为`VARCHAR`，`java`类型为`java.lang.String`的转换处理器\n\n```xml\n<typeHandlers>\n  <typeHandler handler=\"org.mybatis.example.ExampleTypeHandler\"/>\n  <!-- 扫描package目录下所有类型转换器-->\n  <package name=\"org.mybatis.example\"/>\n</typeHandlers>\n```\n\n也可临时指定\n\n```xml\n<resultMap id=\"blogMap\" type=\"blog\">\n  <result column=\"id\"  property=\"id\"/>\n  <result column=\"title\" typeHandler=\"exampleTypeHandler\" property=\"title\"/>\n</resultMap>\n```\n\n可使用泛型，通过配置文件`typeHandler`的`javaType`觉得处理的`java`类型\n\n```java\npublic class GenericTypeHandler<E extends MyObject> extends BaseTypeHandler<E> {\n\n  private Class<E> type;\n\n  public GenericTypeHandler(Class<E> type) {\n    if (type == null) throw new IllegalArgumentException(\"Type argument cannot be null\");\n    this.type = type;\n  }\n```\n\n```xml\n<typeHandlers>\n  <typeHandler handler=\"org.mybatis.example.ExampleTypeHandler\" javaType=\"String\"/>\n</typeHandlers>\n```\n\n## plugins\n\n`mybatis`可定义插件来对数据库操作的各个阶段以切面的方式进行处理。`mybatis`提供了四种类型的插件\n\n在`mybatis`中增加配置，`<property>`的值注入到具体插件的`setProperties`方法的参数\n\n```xml\n<plugins>\n  <plugin interceptor=\"org.mybatis.example.ExamplePlugin\">\n    <property name=\"someProperty\" value=\"100\"/>\n  </plugin>\n</plugins>\n```\n\n插件需要继承`org.apache.ibatis.plugin.Interceptor`，其中注解`Intercepts`的值，表示切面的位置\n\n`type`\n\n> `Executor` (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)  \n> `ParameterHandler` (getParameterObject, setParameters)  \n> `ResultSetHandler` (handleResultSets, handleOutputParameters)  \n> `StatementHandler` (prepare, parameterize, batch, update, query)\n\n`method`\n\n> `type`里的方法名\n\n`args`\n\n> `type`里的方法的参数类型\n\n`metdho`和`args`可以定位到一个具体的`java`方法。所以`method`和`args`的值参考`type`中的方法即可\n\n```java\npackage org.mybatis.example;\n\nimport org.apache.ibatis.cache.CacheKey;\nimport org.apache.ibatis.executor.Executor;\nimport org.apache.ibatis.mapping.BoundSql;\nimport org.apache.ibatis.mapping.MappedStatement;\nimport org.apache.ibatis.plugin.Interceptor;\nimport org.apache.ibatis.plugin.Intercepts;\nimport org.apache.ibatis.plugin.Invocation;\nimport org.apache.ibatis.plugin.Signature;\nimport org.apache.ibatis.session.ResultHandler;\nimport org.apache.ibatis.session.RowBounds;\n\nimport java.util.Properties;\n\n@Intercepts({\n    @Signature(type = Executor.class, method = \"query\", args = {MappedStatement.class, Object.class, RowBounds.class,\n        ResultHandler.class, CacheKey.class, BoundSql.class}),\n    @Signature(type = Executor.class, method = \"query\", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})\n})\npublic class ExamplePlugin implements Interceptor {\n    private Properties properties = new Properties();\n\n    public Object intercept(Invocation invocation) throws Throwable {\n        System.out.println(\"properties:\"+properties);\n        return invocation.proceed();\n    }\n\n    public void setProperties(Properties properties) {\n        this.properties = properties;\n    }\n}\n```\n\n通过自定义插件我们可以去分析下 `#{}`,`${}`的区别\n\n```java\n@Intercepts({\n    @Signature(type = Executor.class, method = \"query\", args = {MappedStatement.class, Object.class, RowBounds.class,\n        ResultHandler.class}),\n})\npublic class ExamplePlugin implements Interceptor {\n\n    public Object intercept(Invocation invocation) throws Throwable {\n        MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0];\n        BoundSql boundSql = mappedStatement.getBoundSql(Map.class);\n        System.out.println(\"boundSql:\" + boundSql.getSql());\n        return invocation.proceed();\n    }\n}\n```\n\n```java\nsqlSession.selectOne(\n            \"org.mybatis.example.BlogMapper.selectBlog\", 1 );\n```\n\n`#{}`,`${}`的实际输出，后者有被`sql`注入的可能性\n\n```sql\nboundSql:select *\n    from Blog\n    where id = ?\n```\n\n```sql\nboundSql:select *\n    from Blog\n    where id = 1\n```\n\n## transactionManager\n\n略，一般由`spring`去控制\n\n## environments\n\n可配置多环境的数据源\n\n```xml\n<environments default=\"development\">\n    <environment id=\"development\">\n    ...\n    </environment>\n</environments>\n```\n\n可指定`id`的数据源，若未指定则使用`default`的数据源\n\n```java\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);\n```\n\n## mapping xml\n\n详细信息科参考[官方文档](http://www.mybatis.org/mybatis-3/sqlmap-xml.html)\n`mybatis`的核心在于映射的`SQL`\n\n### SELECT\n\n```xml\n<select id=\"selectBlog\" parameterType=\"int\" resultType=\"hashmap\" >\n  select * from Blog where id = #{id}\n</select>\n```\n\n`#{id}`这个通知`mybatis`创建一个`PreparedStatement`参数，在预编译阶段实际`sql`语句会被替换为\n\n> `select * from Blog where id = ?`\n\n实际执行代码类型如下\n\n```java\nString selectPerson = \"SELECT * FROM PERSON WHERE ID=?\";\nPreparedStatement ps = conn.prepareStatement(selectPerson);\nps.setInt(1,id);\n```\n\n`id` `SQL`映射唯一标识  \n`parameterType` 请求参数`class`类型  \n`resultType` 返回结果集类型  \n`resultMap` 扩展的返回类型的`id`  \n`flushCache` 是否清空二级缓存，默认不清空  \n`useCache` 是否开启二级缓存，默认不缓存  \n`timeout` 请求超时时间  \n`fetchSize` 返回最大条数，默认不限制  \n`statementType` 可选`STATEMENT`,`PREPARED`或`CALLABLE`，决定使用的是 `Statement`,`PreparedStatement`或`CallableStatement`，默认的是`PREPARED`  \n`resultSetType`  \n`databaseId` `databaseIdProvider` 多种数据库引擎支持  \n`resultOrdered`  \n`resultSets`\n\n### insert, update and delete\n\n`id` `SQL`映射唯一标识  \n`parameterType` 请求参数`class`类型  \n`flushCache` 是否清空二级缓存，默认不清空  \n`timeout` 请求超时时间  \n`statementType` 可选`STATEMENT`,`PREPARED`或`CALLABLE`，决定使用的是 `Statement`,`PreparedStatement`或`CallableStatement`，默认的是`PREPARED`  \n`useGeneratedKeys` 是否使用数据库自增主键  \n`keyProperty` 用于指定传入的`java`成员变量  \n`keyColumn` 用于指定数据库表的主键字段  \n`databaseId` `databaseIdProvider` 多种数据库引擎支持\n\n#### 返回主键\n\n在配置了`useGeneratedKeys`时，如何取得返回的主键\n\n```xml\n  <insert id=\"insertBlog\" useGeneratedKeys=\"true\" keyProperty=\"java_id\" keyColumn=\"id\">\n   insert into blog( title,author_id) values (#{title},#{author_id})\n </insert>\n```\n\n```java\nSqlSession sqlSession = sqlSessionFactory.openSession();\nMap map = new HashMap();\nmap.put(\"title\", \"title3\");\nmap.put(\"author_id\", \"102\");\nint insert = sqlSession.insert(\"org.mybatis.example.BlogMapper.insertBlog\", map);\nSystem.out.println(map);\nsqlSession.commit();\n```\n\n> {title=title3, author_id=102, java_id=6}\n\n可以看到返回主键写入到请求的`pojo`中了\n\n`mybatis`还提供了其他方式进行主键的生成\n\n`<selectKey>`\n`keyProperty` 指定存储主键的字段\n`keyColumn` 用于指定数据库表的主键字段  \n`order` `Before`或者`After`,若是`Before`,则先生成主键，执行`insert`。而设置为`After`,则先`insert`,再讲返回的主键插入的写入请求的`pojo`中  \n`resultType` 返回主键类型  \n`statementType` 可选`STATEMENT`,`PREPARED`或`CALLABLE`，决定使用的是 `Statement`,`PreparedStatement`或`CallableStatement`，默认的是`PREPARED`\n\n#### 批量插入\n\n```xml\n <insert id=\"insertBlog\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n    insert into blog( title,author_id) values\n    <foreach item=\"item\" collection=\"list\" separator=\",\">\n    (#{item.title}, #{item.author_id})\n    </foreach>\n  </insert>\n```\n\n### SQL\n\n可被其他`SQL`映射语句重复使用\n\n```xml\n<sql id=\"userColumns\"> ${alias}.id,${alias}.username,${alias}.password </sql>\n\n<select id=\"selectUsers\" resultType=\"map\">\n  select\n    <include refid=\"userColumns\"><property name=\"alias\" value=\"t1\"/></include>,\n    <include refid=\"userColumns\"><property name=\"alias\" value=\"t2\"/></include>\n  from some_table t1\n    cross join some_table t2\n</select>\n```\n\n### Parameters\n\n#### `${}`或`#{}`\n\n`${}`会被直接替换为值，而`#{}`则进入`prepared`阶段\n\n使用介绍\n\n```java\n@Select(\"select * from user where ${column} = #{value}\")\nUser findByColumn(@Param(\"column\") String column, @Param(\"value\") String value);\n```\n\n#### `#{}`高阶\n\n可以指定某个属性使用独立的处理器，该处理器可以不用注册，但是需要使用全名，如果使用简称则需要已经注册的\n\n> `#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}`\n\n指定`double`的精度\n\n> `#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}`\n\n### ResultMap\n\n通过自定义映射关系来处理复杂的返回结果集\n\n属性\n`id` 主键\n`type` 返回`class`类型\n`autoMapping` 自动匹配的模式。查询的`ResultSet`转换`pojo`时，会自动查找同名属性(忽略大小写)\n\n> `NONE`表示不启用自动映射\n> `PARTIAL`表示只对非嵌套的 resultMap 进行自动映射\n> `FULL`表示对所有的 resultMap 都进行自动映射\n\n```xml\n<resultMap id=\"detailedBlogResultMap\" type=\"Blog\">\n  <constructor>\n    <idArg column=\"blog_id\" javaType=\"int\"/>\n  </constructor>\n  <result property=\"title\" column=\"blog_title\"/>\n  <association property=\"author\" javaType=\"Author\">\n    <id property=\"id\" column=\"author_id\"/>\n    <result property=\"username\" column=\"author_username\"/>\n    <result property=\"password\" column=\"author_password\"/>\n    <result property=\"email\" column=\"author_email\"/>\n    <result property=\"bio\" column=\"author_bio\"/>\n    <result property=\"favouriteSection\" column=\"author_favourite_section\"/>\n  </association>\n  <collection property=\"posts\" ofType=\"Post\">\n    <id property=\"id\" column=\"post_id\"/>\n    <result property=\"subject\" column=\"post_subject\"/>\n    <association property=\"author\" javaType=\"Author\"/>\n    <collection property=\"comments\" ofType=\"Comment\">\n      <id property=\"id\" column=\"comment_id\"/>\n    </collection>\n    <collection property=\"tags\" ofType=\"Tag\" >\n      <id property=\"id\" column=\"tag_id\"/>\n    </collection>\n    <discriminator javaType=\"int\" column=\"draft\">\n      <case value=\"1\" resultType=\"DraftPost\"/>\n    </discriminator>\n  </collection>\n</resultMap>\n```\n\n#### id & result\n\n映射基本类型，`id`表示主键\n\n> `property` `pojo`成员变量  \n> `column` 数据库字段  \n> `javaType` 成员变量`class`类型  \n> `jdbcType` 数据库字段类型  \n> `typeHandler` 使用具体的处理器去处理\n\n支持的数据库类型\n\n> `BIT` `FLOAT` `CHAR` `TIMESTAMP` `OTHER` `UNDEFINED` >`TINYINT` `REAL` `VARCHAR` `BINARY` `BLOB` `NVARCHAR` >`SMALLINT` `DOUBLE` `LONGVARCHAR` `VARBINARY` `CLOB` `NCHAR` >`INTEGER` `NUMERIC` `DATE` `LONGVARBINARY` `BOOLEAN` `NCLOB` >`BIGINT` `DECIMAL` `TIME` `NULL` `CURSOR` `ARRAY`\n\n#### constructor\n\n为`type`有参构造器传递参数，分为`<idArg>`（主键）和`<arg>`，默认构造器参数根据顺序进行传参。\n\n> `property` `pojo`成员变量  \n> `column` 数据库字段  \n> `javaType` 成员变量`class`类型  \n> `jdbcType` 数据库字段类型  \n> `typeHandler` 使用具体的处理器去处理\n> `select` 其他映射语句的 id，根据其查询值注入构造器参数中\n> `resultMap` 引入其他`resultMap` > `name` 根据名称指定具体参数值，无视参数顺序。\n\n#### association\n\n一定要注意集合类型的长度\n\n> `property` `pojo`成员变量  \n> `column` 数据库字段  \n> `javaType` 成员变量`class`类型  \n> `jdbcType` 数据库字段类型  \n> `typeHandler` 使用具体的处理器去处理\n> `select` 其他映射语句的 id，根据其查询值注入到成员变量中\n> `resultMap` 引入其他`resultMap` >`fetchType` 可设置为`lazy`或`eager`是否延迟加载\n> `columnPrefix` 当涉及到多表查询时，多表的字段相同，那么`sql`语句就需要使用`as`来区分字段。\n> 例如：\n\n```xml\n<select id=\"selectBlog\" resultMap=\"blogResult\">\n  select\n  B.id as blog_id,\n  B.title as blog_title,\n  B.author_id as blog_author_id,\n  P.id as post_id,\n  P.subject as post_subject,\n  P.body as post_body,\n  from Blog B\n  left outer join Post P on B.id = P.blog_id\n  where B.id = #{id}\n</select>\n```\n\n一般情况下我们\n\n```xml\n<resultMap id=\"blogResult\" type=\"Blog\">\n  <id property=\"id\" column=\"blog_id\" />\n  <result property=\"title\" column=\"blog_title\"/>\n  <collection property=\"posts\" ofType=\"Post\">\n    <id property=\"id\" column=\"post_id\"/>\n    <result property=\"subject\" column=\"post_subject\"/>\n    <result property=\"body\" column=\"post_body\"/>\n  </collection>\n</resultMap>\n```\n\n我们可以使用`columnPrefix`来处理\n\n```xml\n<resultMap id=\"blogResult\" type=\"Blog\">\n  <id property=\"id\" column=\"blog_id\" />\n  <result property=\"title\" column=\"blog_title\"/>\n  <collection property=\"posts\" ofType=\"Post\" resultMap=\"blogPostResult\" columnPrefix=\"post_\"/>\n</resultMap>\n\n<resultMap id=\"blogPostResult\" type=\"Post\">\n  <id property=\"id\" column=\"id\"/>\n  <result property=\"subject\" column=\"subject\"/>\n  <result property=\"body\" column=\"body\"/>\n</resultMap>\n```\n\n#### discriminator\n\n```xml\n<resultMap id=\"vehicleResult\" type=\"Vehicle\">\n  <id property=\"id\" column=\"id\" />\n  <result property=\"vin\" column=\"vin\"/>\n  <result property=\"year\" column=\"year\"/>\n  <result property=\"make\" column=\"make\"/>\n  <result property=\"model\" column=\"model\"/>\n  <result property=\"color\" column=\"color\"/>\n  <discriminator javaType=\"int\" column=\"vehicle_type\">\n    <case value=\"1\" resultMap=\"carResult\"/>\n    <case value=\"2\" resultMap=\"truckResult\"/>\n    <case value=\"3\" resultMap=\"vanResult\"/>\n    <case value=\"4\" resultMap=\"suvResult\"/>\n  </discriminator>\n</resultMap>\n```\n\n根据`column`的值决定哪种`<case>`执行\n\n### cache\n\n略过，由`spring`去控制\n\n## Dynamic SQL\n\n## SpringBoot\n\nmaven 依赖\n\n```xml\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.1.0</version>\n</dependency>\n```\n\n[官方文档](http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/)\n\n可在`springboot`配置文件`application.properties`(或`application.yml`).中配置`Mybatis`使用`mybatis`前缀作为配置\n\n`config-location` `mybatis`配置文件目录\n`mapper-locations` `mapper`文件目录地址\n`type-aliases-package` 别名包名，不同目录可用`,; \\t\\n`分割\n`type-handlers-package` 类型转换器包名，不同目录可用`,; \\t\\n`分割\n`configuration-properties` 指定`properties`配置文件，可被`mybatis`配置文件和`mapper`文件中作为占位符使用\n`configuration.*` 等同于`mybatis`配置文件中的`settings`\n\n可使用`ConfigurationCustomizer`来自定制细节\n\n```java\n@Configuration\npublic class MyBatisConfig {\n  @Bean\n  ConfigurationCustomizer mybatisConfigurationCustomizer() {\n    return new ConfigurationCustomizer() {\n      @Override\n      public void customize(Configuration configuration) {\n        // customize ...\n      }\n    };\n  }\n}\n```\n\n`mybatis`会自动检测继承`mybatis`接口的`bean`  \n`Interceptor`  \n`TypeHandler`  \n`LanguageDriver (Requires to use together with mybatis-spring 2.0.2+)`  \n`DatabaseIdProvider`\n\n```java\n@Configuration\npublic class MyBatisConfig {\n  @Bean\n  MyInterceptor myInterceptor() {\n    return MyInterceptor();\n  }\n  @Bean\n  MyTypeHandler myTypeHandler() {\n    return MyTypeHandler();\n  }\n}\n```\n","categories":["java"],"tags":["mysql","mybatis"]},{"title":"动态规划","url":"/2019/07/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"## 题目\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n注意：给定 n 是一个正整数。\n\n示例 1：\n>输入： 2\n输出： 2\n\n解释： 有两种方法可以爬到楼顶。\n\n> 1 阶 + 1 阶\n> 2 阶\n\n示例 2：\n>输入： 3\n输出： 3\n\n解释： 有三种方法可以爬到楼顶。\n\n>1 阶 + 1 阶 + 1 阶\n1 阶 + 2 阶\n2 阶 + 1 阶\n\n## 思路\n\n使用动态规划的思路去解决问题。对于指定n阶的楼梯，最后一次爬楼梯，要嘛是1阶，要嘛就是2阶，那么总共就有爬$n-1$阶和$n-2$阶的楼梯\n\n状态转移方程式\n\n$F(1) = 1$  \n$F(2) = 2$  \n$F(n) = F(n-1)+F(n-2)$  \n\n根据状态转移方程式，我们可以很容易的得出代码如下\n\n```java\n\nclass Solution {\n  \n  public int climbStairs(int n) {\n    if (n < 3) {\n      return n;\n    }\n    int f1 = 1;\n    int f2 = 2;\n    for (int i = 3; i <=n; i++) {\n      int t = f2;\n      f2 = f2 + f1;\n      f1 = t;\n    }\n    return f2;\n  }\n}\n```\n","categories":["算法"],"tags":["动态规划"]},{"title":"springboot-jpa","url":"/2019/07/30/springboot-jpa/","content":"\n## 版本说明\n\n`jdk`:1.8.0_131\n`springboot`:2.1.6.RELEAS\n`maven`:3.6.1\n`database`:mysql-5.7.14\n`lombok插件`\n\n## 概述\n\n项目基于 maven，pom 配置如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.1.6.RELEASE</version>\n    <relativePath/> <!-- lookup parent from repository -->\n  </parent>\n  <groupId>com.li</groupId>\n  <artifactId>springboot</artifactId>\n  <version>0.0.1-SNAPSHOT</version>\n  <name>springboot</name>\n  <description>Demo project for Spring Boot</description>\n\n  <properties>\n    <java.version>1.8</java.version>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-jdbc</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>com.github.ulisesbocchio</groupId>\n      <artifactId>jasypt-spring-boot</artifactId>\n      <version>2.1.1</version>\n    </dependency>\n    <dependency>\n      <groupId>log4j</groupId>\n      <artifactId>log4j</artifactId>\n      <version>1.2.17</version>\n    </dependency>\n    <dependency>\n      <groupId>org.projectlombok</groupId>\n      <artifactId>lombok</artifactId>\n      <optional>true</optional>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-test</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>javax.inject</groupId>\n      <artifactId>javax.inject</artifactId>\n      <version>1</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.aspectj</groupId>\n      <artifactId>aspectjweaver</artifactId>\n      <version>1.9.4</version>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.commons</groupId>\n      <artifactId>commons-lang3</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>com.google.code.gson</groupId>\n      <artifactId>gson</artifactId>\n      <version>2.8.5</version>\n    </dependency>\n  </dependencies>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n      </plugin>\n      <plugin>\n        <artifactId>maven-clean-plugin</artifactId>\n        <version>3.1.0</version>\n      </plugin>\n    </plugins>\n  </build>\n\n</project>\n```\n\n部分代码使用`lombok`进行简化\n\n表实体类\n\n```java\npackage com.li.springboot.bean;\n\nimport lombok.Data;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Id;\n\n@Proxy(lazy = false)\n@Entity(name = \"log\")\n@Data\npublic class Log {\n    @Id\n    private String id;\n    private String log;\n    private String time;\n    @Column(name = \"user_id\")\n    private String userID;\n}\n```\n\n`@Id`表示主键\n`@Entity`标记当前类为一个表，若指定属性`name`，则实际表名使用`name`的值，否则使用类名。\n`@Column`中的`name`同样也是指定表的字段名。\n\n表操作类\n\n```java\npackage com.li.springboot.dao;\n\nimport com.li.springboot.bean.Log;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface LogDao extends JpaRepository<Log, String> {\n}\n\n```\n\n```java\npackage com.li.springboot.controller;\n\nimport com.li.springboot.bean.Log;\nimport com.li.springboot.dao.LogDao;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class LogController {\n  @Autowired\n  LogDao logDao;\n\n  @RequestMapping(\"/{id}\")\n  public Log log(@PathVariable String id) {\n    return logDao.getOne(id);\n  }\n}\n```\n\n`JpaRepository`的泛型，分别指定表实体类和表主键,`JpaRepository`包含常用的数据库操作，`LogDao`可直接使用。\n\n数据库连接信息配置\n\n```yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/app\n    username: root\n    password: \"{cipher}cm9vdA\"\n    driver-class-name: com.mysql.cj.jdbc.Driver\n  jpa:\n    show-sql: true\nlogging:\n  level:\n    root: error\n    com:\n      li: debug\n```\n\n其他，略\n\n测试\n\n```java\npackage com.li.springboot.controller;\n\nimport com.google.gson.Gson;\nimport com.li.springboot.bean.Log;\nimport lombok.extern.slf4j.Slf4j;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\n@AutoConfigureMockMvc\n@Slf4j\npublic class LogControllerTest {\n    @Autowired\n    MockMvc mockMvc;\n\n    @Test\n    public void test() throws Exception {\n        mockMvc.perform(get(\"/1\")).andDo(print()).andExpect(result -> {\n            Log log = new Gson().fromJson(result.getResponse().getContentAsString(), Log.class);\n            assert log !=null;\n        });\n    }\n\n}\n```\n","categories":["spring"],"tags":["springboot","mysql","jpa"]},{"title":"简单逻辑学","url":"/2019/07/29/%E7%AE%80%E5%8D%95%E9%80%BB%E8%BE%91%E5%AD%A6/","content":"\n## 为什么学习逻辑学\n\n**提升口语表达能力**\n你所说的就是你所想的，若对事物没有一个清晰明了的认知，就更不可能用语言去精准的描述它。不要求说话说得多么好听，但求能够清楚有力的表达自己想要说的。\n\n**费曼学习法**\n能够用简单的语言向别人解释一个知识的时候，就是掌握知识的时候。而逻辑学就是关于如何精准描述事物的学科。\n\n## 如何学习逻辑学\n\n**思维导图**\n    思维导图是用简单的词语高度抽象概括知识的一个工具，而抽象的过程既是逻辑化的一个过程。\n**博客**\n    写作的过程即是讲自己所想所思转变为文字的过程，在编写博客的过程中，始终遵循简单逻辑学和金字塔原理的理论思想，不断加强自己的概括抽象能力。\n\n## 概述\n\n逻辑学是关于如何进行清晰有效的思维。逻辑学是揭露客观事实真相的一门学问。\n\n## 心里上的准备\n\n1. 保持注意力，世上没有两片相同的树叶，每个事务都是唯一的，我们需要保持警惕。\n\n2. 事实客观存在，不因人的主观认知而改变，而人的主观认知会随着对客观事实的理解加深而愈加接近客观事实。\n\n3. 主观认知愈加接近客观事实，就越容易清晰准确的用语言去描述它。\n\n4. 语言只能描述人的主观认知，而不是客观事实。\n\n## 如何进行有效的沟通\n\n1. 不要假设听众了解你的潜台词。\n\n2. 使用完整的语句表达自己的观点。\n\n3. 避免使用猜测，不准确的表述形式。\n\n4. 站在听众的角度，以他们能理解的方式去陈述。\n\n5. 避免使用歧义，模糊的表达。\n\n## 逻辑学第一原则\n\n1. 客观事实的定义，苹果就是苹果，不是橙子，不是香蕉，也不是梨子。\n\n2. 客观事实要嘛存在要嘛不存在，不存在中间状态\n\n3. 客观事实存在有充足的理由\n\n4. 在同样的角度下，不可能同时是同时不是\n\n## 其他原则\n\n1. 有些事务无法被清晰的定义。\n\n2. 有些事务我们不知道是如何发生的，但是我们知道一定是有原因的\n\n3. 尽量缩短逻辑链\n\n4. 区分主次\n\n5. 用自己的语言去解释\n\n6. 用明确的肯定的语言描述\n\n7. 抽象概括观点\n","categories":["逻辑学"],"tags":["逻辑学","学习"]},{"title":"docker基础","url":"/2019/07/22/docker%E5%9F%BA%E7%A1%80/","content":"\n## 指南\n\n### 安装\n\n[官方安装文档](https://docs.docker.com/install/)\n\n`docker --version` 查看版本号\n`docker info` 查看 docker 详细信息\n\n### 概述\n\n#### image\n\n容器是由镜像文件加载启动的。镜像是一个可执行文件，包含运行应用程序所需要的所有资源，包括\n代码，运行环境，环境变量，配置文件等。\n可通过`docker images`查看所有镜像\n\n```shell\nREPOSITORY                                             TAG                 IMAGE ID            CREATED             SIZE\njenkins/jenkins                                        2.138.4             b8efbb99cea6        7 months ago        701MB\nregistry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g   latest              3fa112fd3642        3 years ago         6.85GB\n```\n\n可通过`docker pull <image:TAG>`下载镜像，不显示指定`TAG`则下载`latest`版本的，当使用`docker run <image>`时若本地镜像没有则会自动下载远程镜像\n\n#### container\n\n容器是镜像的运行实例，容器共享宿主机的`kernel`内核，独立进程运行，不占用其他任何可执行文件的内存。\n\n部分命令\n\n```shell\n## List Docker CLI commands\ndocker\ndocker container --help\n\n## Display Docker version and info\ndocker --version\ndocker version\ndocker info\n\n## Execute Docker image\ndocker run hello-world\n\n## List Docker images\ndocker image ls\n\n## List Docker containers (running, all, all in quiet mode)\ndocker container ls\ndocker container ls --all\ndocker container ls -aq\n```\n\n## 容器\n\n### 创建自己的容器\n\n通过`Dockerfile`定义镜像\n新建一个空目录，`cd`进入目录，编辑`Dockerfile`文件\n\n```bash\n# Use an official Python runtime as a parent image\nFROM python:2.7-slim\n\n# Set the working directory to /app\nWORKDIR /app\n\n# Copy the current directory contents into the container at /app\nCOPY . /app\n\n# Install any needed packages specified in requirements.txt\nRUN pip install --trusted-host pypi.python.org -r requirements.txt\n\n# Make port 80 available to the world outside this container\nEXPOSE 80\n\n# Define environment variable\nENV NAME World\n\n# Run app.py when the container launches\nCMD [\"python\", \"app.py\"]\n```\n\n根据上述`Dockerfile`新建`requirements.txt`和`app.py`\n\n```txt\nFlask\nRedis\n```\n\n```python\nfrom flask import Flask\nfrom redis import Redis, RedisError\nimport os\nimport socket\n\n# Connect to Redis\nredis = Redis(host=\"redis\", db=0, socket_connect_timeout=2, socket_timeout=2)\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    try:\n        visits = redis.incr(\"counter\")\n    except RedisError:\n        visits = \"<i>cannot connect to Redis, counter disabled</i>\"\n\n    html = \"<h3>Hello {name}!</h3>\" \\\n           \"<b>Hostname:</b> {hostname}<br/>\" \\\n           \"<b>Visits:</b> {visits}\"\n    return html.format(name=os.getenv(\"NAME\", \"world\"), hostname=socket.gethostname(), visits=visits)\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port=80)\n```\n\n执行`docker build -t=friendlyhello .`\n等待编译完成后通过`docker image ls`可查看到已经编译好的镜像\n\n```bash\nREPOSITORY                                             TAG                 IMAGE ID            CREATED             SIZE\nfriendlyhello                                          latest              9f7c2034a1f3        27 seconds ago      148MB\npython                                                 2.7-slim            5caa018c2dc0        9 days ago          137MB\n```\n\n执行`docker run -d -p 4000:80 friendlyhello`，以后台进程的方式运行容器\n\n可通过[http://localhost:4000](http://localhost:4000)访问首页\n\n版本控制\n`docker tag image username/repository:tag`\n\n部分命令\n\n```bash\ndocker build -t friendlyhello .  # Create image using this directory's Dockerfile\ndocker run -p 4000:80 friendlyhello  # Run \"friendlyhello\" mapping port 4000 to 80\ndocker run -d -p 4000:80 friendlyhello         # Same thing, but in detached mode\ndocker container ls                                # List all running containers\ndocker container ls -a             # List all containers, even those not running\ndocker container stop <hash>           # Gracefully stop the specified container\ndocker container kill <hash>         # Force shutdown of the specified container\ndocker container rm <hash>        # Remove specified container from this machine\ndocker container rm $(docker container ls -a -q)         # Remove all containers\ndocker image ls -a                             # List all images on this machine\ndocker image rm <image id>            # Remove specified image from this machine\ndocker image rm $(docker image ls -a -q)   # Remove all images from this machine\ndocker login             # Log in this CLI session using your Docker credentials\ndocker tag <image> username/repository:tag  # Tag <image> for upload to registry\ndocker push username/repository:tag            # Upload tagged image to registry\ndocker run username/repository:tag                   # Run image from a registry\n```\n\n### 启动容器\n\n```bash\n#-p 映射端口    <宿主端口:容器端口>\ndocker run -p   4001:8080  friendlyhello\n#-d 以守护进程启动\ndocker run -d -p  4001:8080  friendlyhello\n```\n\n### 进入容器\n\n进入容器，并以`bash`作为`shell`\n`docker exec -it 6bcaf729d3d4 bash`\n\n`6bcaf729d3d4`容器 id，可通过`docker ps`查看\n\n```shell\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES\n6bcaf729d3d4        jenkins             \"/bin/tini -- /usr/l…\"   31 seconds ago      Up 29 seconds       50000/tcp, 0.0.0.0:8002->8080/tcp   jenkins\n```\n\n以 root 权限登录\n`sudo docker exec -ti -u root 6bcaf729d3d4 bash`\n\n### 删除容器\n\n```shell\ndocker container rm <containerID>\n#删除所有\ndocker container rm `docker container ls -a -q`\n```\n\n## 服务化\n\n## 下载镜像\n\n`docker pull name:tag`\n`name`镜像名\n`tag`镜像版本\n\n> 若速度较慢，可以配置阿里云镜像加速 [镜像加速参考文档](https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors)\n\n## 删除镜像\n\n`docker images`查看所有镜像\n`dockder rmi 'image_id'`删除镜像\n删除所有镜像\n\n```shell\ndocker rmi -f `docker images -q`\n```\n\n## 保存镜像\n\n当在镜像启动的容器中做了修改，比如下载了软件，做了配置等。我们可以将容器保存为镜像。\n`docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]`\n示例\n`docker commit a8eb6111cf26 li-ubuntu`\n后续我们就可以使用新的镜像名称来启动应用了\n`docker run -it li-ubuntu /bin/bash`\n\n## 导出镜像\n\n```shell\ndocker save -o update1.tar update\n```\n\n## 加载离线镜像\n\n```shell\ndocker load -i update1.tar\n```\n\n## 安装离线镜像\n\n```shell\n\n```\n\n## 查看日志\n\n```shell\ndocker logs [OPTIONS] CONTAINER\n  Options:\n        --details        显示更多的信息\n    -f, --follow         跟踪实时日志\n        --since string   显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）\n        --tail string    从日志末尾显示多少行日志， 默认是all\n    -t, --timestamps     显示时间戳\n        --until string   显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）\n```\n\n查看指定时间后的日志，只显示最后 100 行：\n\n```shell\ndocker logs -f -t --since=\"2018-02-08\" --tail=100 CONTAINER_ID`\n```\n\n查看最近 30 分钟的日志:\n\n```shell\ndocker logs --since 30m CONTAINER_ID\n```\n\n查看某时间之后的日志：\n\n```shell\ndocker logs -t --since=\"2018-02-08T13:23:37\" CONTAINER_ID\n```\n\n查看某时间段日志：\n\n```shell\ndocker logs -t --since=\"2018-02-08T13:23:37\" --until \"2018-02-09T12:23:37\" CONTAINER_ID\n```\n\n## 挂载宿主目录\n\n`-v`可重复使用，指定多个目录\n\n```shell\ndocker run -d -p 8002:8080 -v ~/jenkins:/var/jenkins_home -v /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home:/mnt/java -v /usr/local/Cellar/maven/3.6.1:/mnt/maven -v /Users/li/.m2:/mnt/.m2 --name jenkins --restart=always jenkins/jenkins:2.138.4\n\n```\n\n`/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home:/mnt/java`挂载`jdk`\n\n## 容器内 vim 安装\n\n进入容器中使用`vi`提示不存在\n\n`apt-get update`更新软件包管理工具,这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。\n`apt-get install vim`安装 vi\n\n## 开启`ssh`登录\n\n1. 安装服务端`apt-get install openssh-server`\n2. 启动`ssh`服务,使用命令`service ssh start`或者`/ect/init.d/ssh start`\n3. 关闭`ssh`服务，`service ssh stop`\n","categories":["docker"],"tags":["docker","基础教程"]},{"title":"jenkins远程发布","url":"/2019/07/22/jenkins%E8%BF%9C%E7%A8%8B%E5%8F%91%E5%B8%83/","content":"\n## 版本说明\n\n省略 docker 安装过程\n\n`docker version`\n\n```log\nClient:\n Version:           18.06.1-ce\n API version:       1.38\n Go version:        go1.10.3\n Git commit:        e68fc7a\n Built:             Tue Aug 21 17:21:31 2018\n OS/Arch:           darwin/amd64\n Experimental:      false\n\nServer:\n Engine:\n  Version:          18.06.1-ce\n  API version:      1.38 (minimum version 1.12)\n  Go version:       go1.10.3\n  Git commit:       e68fc7a\n  Built:            Tue Aug 21 17:29:02 2018\n  OS/Arch:          linux/amd64\n  Experimental:     true\n```\n\n`java -version`\n\n```log\njava version \"1.8.0_131\"\nJava(TM) SE Runtime Environment (build 1.8.0_131-b11)\nJava HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)\n```\n\n## 安装 Jenkins 镜像\n\n```shell\ndocker pull jenkins/jenkins:2.138.1-slim\n```\n\n拉取的是 2.138.1-slim 版本的 jenkins，可通过命令查看下载的版本\n\n`docker images`\n\n```log\nREPOSITORY                                             TAG                 IMAGE ID            CREATED             SIZE\njenkins                                                latest              cd14cecfdb3a        12 months ago       696MB\n```\n\n## 启动 Jenkins\n\n```shell\ndocker run -d -p 8002:8080 -v ~/jenkins:/var/jenkins_home -v /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home:/mnt/java -v /usr/local/Cellar/maven/3.6.1:/mnt/maven --name jenkins --restart=always jenkins/jenkins:2.138\n```\n\n`8002:8080` 本地 8002 端口映射容器 8080 端口\n\n查看启动日志\n`docker logs -f jenkins`\n可以看到`jenkins`的默认`admin`密码\n\n```log\nJenkins initial setup is required. An admin user has been created and a password generated.\nPlease use the following password to proceed to installation:\n\n8b34af422fa24794bdb86d3e299162bd\n\nThis may also be found at: /var/jenkins_home/secrets/initialAdminPassword\n```\n\n界面访问[`127.0.0.1:8002`](http://127.0.0.1:8002),自动跳转至登录界面,首次进线输入默认密码，登录后安装推荐插件。\n\njenkins 插件镜像\n\n页面依次点击/Manage Jenkins/Manage Plugins/Advanced\n镜像地址：\n\n```shell\nhttps://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json\n```\n\n![jenkins插件镜像](jenkins远程发布/jenkins插件镜像.jpg)\n","categories":["工具"],"tags":["docker","jenkins","tomact"]},{"title":"idea技巧","url":"/2019/07/21/idea%E6%8A%80%E5%B7%A7/","content":"\n## 调试\n\n1. `Evaluate Expression`,在`Debug`模式下使用，可以动态编写代码进行调试\n\n2. 右键`BreakPoint`可设置`condition`，即在指定条件下断点生效\n\n## 输入\n\n多尝试用自定义模板[官方自定义模板内容函数](https://www.jetbrains.com/help/idea/template-variables.html)\n\n## 快捷键\n\n==⇧⌘F12== 最小化工具窗口\n\n## `gradle`\n\n`gradle`编译特别慢，需要在`idea`设置中设置`HTTP Proxy`\n\n## 跳转源码\n\n`jump to source`快捷键为`⎋(esc)`或`⌘+↓`\n\n## 回到`Project`视图源码处\n\n`select in project view`默认没有快捷键\n\n## 自动分屏到右边\n\n`move right`\n\n## 在分屏中切换\n\n`⌥tab`\n\n## 切换 tab\n\n`switcher` 快捷键为`⌃⇥`\n\n`⇧⌘[`上个 tab\n`⇧⌘]`下个 tab\n\n## debug 模式下,开启变量提示\n\n`show values inline`\n\n## 当前行行数高亮\n\n`line number on caret row`\n\n## `live templates`\n\n`ifn`快速判断当前行数变量是否为 null\n\n```java\nif (var == null) {\n\n}\n```\n\n## `Hippie completion`\n\n自动输入前面或后面的单词`⌥/` `⌥⇧/`\n\n## `Smart Type`\n\n智能补全，比如说提示使用何种`lambda` `⇧ space`\n\n## 自动补全根据使用频率\n\n`sort suggestions alphabetically`\n\n## `quick Definitions`\n\n弹出窗口快速查看代码`⌥q`\n\n## `quick documentation`\n\n弹出窗口快速查看文档`⌥F1`\n\n## 为报错文件设置提醒色\n\n`File Color`\n\n## 使用`favorite`\n\n## `custome live template`\n\n可以选中代码后，抽取为`template`\n\n## `keymap abbrevation`\n\n添加快捷方式的缩写，方便使用`find action`查找\n\n## `recent location`\n\n最近访问的路径`⌘⇧e`\n\n## `paster form history`\n\n`idea`记录了最近复制过(`⌘c`)的文本\n\n## `adjust code style setting`\n\n选中代码后，使用可以查卡到选中代码所使用的格式选项，可以去调整它，``⌥⏎`\n\n## `breadcrumbs`\n\n使用面包屑导航显示代码类，方法\n\n## `隐藏目录`\n\n`Editor`|`File Types`|`Ignore files and folders`\n\n## `相关问题`\n\n> objc[1474]: Class JavaLaunchHelper is implemented in both /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/bin/java (0x10b59a4c0) and /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre/lib/libinstrument.dylib (0x10b6764e0). One of the two will be used. Which one is undefined.\n\n`IDEA`菜单`Help`>>`Edit Custom Properties`\n在打开的`idea.properties`里加上\n\n```properties\nidea.no.launcher=true\n```\n\n## 文件打开方式\n\nidea 若使用某种方式打开文件后，`file type`中的编辑器类型下，会有相关联的文件后缀。\n\n## 标记当前段落不格式化\n\ncode style|enable formatter markers in comments\n\n## 为了方便在各个平台使用，统一定义快捷键\n\nmac 上使用 command 键替代 alt\n\n可以自定义一组快捷命令，`Quick List`\n\n| 快捷键    | 解释                   |\n| :-------- | :--------------------- |\n| F1        | quick list             |\n| F2        | next highlight error   |\n| F3        | toggle bookmark        |\n| F4        | run                    |\n| F5        | debug                  |\n| ALT 1     | project view           |\n| ALT 2     | structure view         |\n| ALT 3     | favorite view          |\n| ALT 4     | run view               |\n| ALT 5     | debug view             |\n| ALT F3    | show bookmark          |\n| ALT b     | goto to declration     |\n| ALT n     | generate ,new file     |\n| ALT w     | close active tab       |\n| ALT up    | jump to navigation bar |\n| ALT down  | jump to source         |\n| ALT left  | goto previous splitter |\n| ALT right | goto next splitter     |\n| SHIFT F6  | rename                 |\n\n其他快捷方式\n\n1. 窗口视图回车键进入代码\n","categories":["tips"],"tags":["tips","idea","快捷键"]},{"title":"springboot数据库密码加密","url":"/2019/07/19/springboot%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/","content":"\n## 方案一\n\n`SpringBoot`在配置文件`application`中配置的关于数据库连接信息,在实际使用时是转换为`DataSource`类，那么只要将`SpringBoot`实现的`DataSource`继承类中，\n将实际密文解密即可。通过查看源码可得知，`SpringBoot`中`DataSource`实现类为`HikariDataSource`,那么我们通过`BeanPostProcessor`在实例化`HikariDataSource`时,\n替换密文即可。代码如下\n\n```yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/app\n    username: root\n    password: cm9vdA==\n    driver-class-name: com.mysql.jdbc.Driver\n```\n\n```java\n  @Bean\n  public static BeanPostProcessor beanPostProcessor() {\n    return new BeanPostProcessor() {\n      @Override\n      public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        if (bean instanceof HikariDataSource) {\n          HikariDataSource hikariDataSource = (HikariDataSource) bean;\n          hikariDataSource.setPassword(new String(Base64Utils.decode(hikariDataSource.getPassword().getBytes())));\n        }\n        return null;\n      }\n    };\n  }\n```\n\n## 方案二\n\n使用 jasypt\n\n```xml\n<dependency>\n    <groupId>com.github.ulisesbocchio</groupId>\n    <artifactId>jasypt-spring-boot-starter</artifactId>\n    <version>2.1.1</version>\n</dependency>\n```\n\n开启\n\n```java\n@EnableEncryptableProperties\npublic class SpringbootApplication {\n}\n```\n\n自定义处理器解密处理器\n\n```yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/app\n    username: root\n    password: \"{cipher}cm9vdA\"\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n```java\n\n  public static final String ENCODED_PASSWORD_HINT = \"{cipher}\";\n\n  @Bean\n  public static EncryptablePropertyDetector encryptablePropertyDetector() {\n    return new EncryptablePropertyDetector() {\n\n      @Override\n      public boolean isEncrypted(String s) {\n        if (null != s) {\n          return s.startsWith(ENCODED_PASSWORD_HINT);\n        }\n        return false;\n      }\n\n      @Override\n      public String unwrapEncryptedValue(String s) {\n        return s.substring(ENCODED_PASSWORD_HINT.length());\n      }\n    };\n  }\n\n  @Bean\n  public static EncryptablePropertyResolver encryptablePropertyResolver() {\n    return new EncryptablePropertyResolver() {\n      @Override\n      public String resolvePropertyValue(String s) {\n        if (null != s && s.startsWith(ENCODED_PASSWORD_HINT)) {\n          return new String(Base64Utils.decode(s.substring(ENCODED_PASSWORD_HINT.length()).getBytes()));\n        }\n        return s;\n      }\n    };\n  }\n```\n\n## 方案三\n\n根据方案二的实现原理，使用`BeanFactoryPostProcessor`实现一个自动解密配置文件的处理器\n\n```yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/app\n    username: root\n    password: \"{cipher}cm9vdA\"\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n```java\n @Bean\n  public static EncryptationAwarePropertyPlaceholderConfigurer enableEncryptablePropertySourcesPostProcessor(ConfigurableEnvironment environment) {\n    return new DecodeBeanFactoryPostProcessor(environment);\n  }\n```\n\n```java\npublic class DecodeBeanFactoryPostProcessor implements BeanFactoryPostProcessor {\n\n\n  private ConfigurableEnvironment environment;\n\n  public DecodeBeanFactoryPostProcessor(ConfigurableEnvironment environment) {\n    this.environment = environment;\n  }\n\n\n  @Override\n  public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n    MutablePropertySources propertySources = environment.getPropertySources();\n    StreamSupport.stream(propertySources.spliterator(), false).forEach(ps -> {\n      //示例代码，仅仅处理application.yml相关的解码操作\n      if (ps.getName().equals(\"applicationConfig: [classpath:/application.yml]\")) {\n        Map<Object, Object> source = (Map) ps.getSource();\n        source.keySet().forEach(k -> {\n          Object value = source.computeIfPresent(k, (key, v) -> {\n            String cipher = v.toString();\n            if (cipher.startsWith(\"{cipher}\")) {\n              return new String(Base64Utils.decode(cipher.substring(\"{cipher}\".length()).getBytes()));\n            }\n            return v;\n          });\n        });\n      }\n    });\n  }\n\n```\n\n其中需要注意的是，`DecodeBeanFactoryPostProcessor`的实例化需要在`ApplicationContext`加载成功后再去实例化，确保`ConfigurableEnvironment`已被正确初始化\n","categories":["spring"],"tags":["springboot","datasource","加密"]},{"title":"maven入门","url":"/2019/07/15/maven%E5%85%A5%E9%97%A8/","content":"\n省略下载安装过程\n\n## 配置\n\nmaven 默认目录在`${user.home}/.m2/`\n`settings.xml`配置文件为 maven 的全局配置\n\n### 镜像\n\nmaven 默认中央仓库访问速度较慢，可通过配置阿里云的镜像加速访问。当需要禁止访问中央仓库时，也可通过配置镜像将中央仓库指定为远程仓库\n\n阿里云镜像地址：\n\n> `http://maven.aliyun.com/nexus/content/groups/public/`\n\n在`${user.home}/.m2/settings.xml`中新增如下配置\n\n```xml\n<settings>\n  ...\n  <mirrors>\n    <mirror>\n      <id>UK</id>\n      <name>UK Central</name>\n      <url>http://uk.maven.org/maven2</url>\n      <mirrorOf>central</mirrorOf>\n    </mirror>\n  </mirrors>\n  ...\n</settings>\n```\n\n1. `<mirrorOf>central</mirrorOf>`\n   里是要替代的仓库的 id。\n2. `<mirrorOf>*</mirrorOf>`\n   匹配所有仓库\n3. `<mirrorOf>external:*</mirrorOf>`\n   匹配所有远程仓库，使用`localhost`的除外，使用`file://`协议的除外。也就是说，匹配所有不在本机上的远程仓库。\n4. `<mirrorOf>repo1,repo2</mirrorOf>`\n   匹配仓库 repo1 和 repo2，使用逗号分隔多个远程仓库。\n5. `<mirrorOf>*,!repo1</miiroOf>`\n   匹配所有远程仓库，repo1 除外，使用感叹号将仓库从匹配中排除。\n\n## POM\n\npom 是最基础的组件，是 maven 用来构建项目的基础配置文件，其中包括许多默认属性。\n\n### Super POM\n\n所有的 pom 文件都继承自`Super POM`，除非你设置了不继承。\n\n下面是 Maven 3.5.4 版本的`Super POM`摘要\n\n```xml\n<project>\n  <modelVersion>4.0.0</modelVersion>\n  <repositories>\n    <repository>\n      <id>central</id>\n      <name>Central Repository</name>\n      <url>https://repo.maven.apache.org/maven2</url>\n      <layout>default</layout>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n    </repository>\n  </repositories>\n  <pluginRepositories>\n    <pluginRepository>\n      <id>central</id>\n      <name>Central Repository</name>\n      <url>https://repo.maven.apache.org/maven2</url>\n      <layout>default</layout>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n      <releases>\n        <updatePolicy>never</updatePolicy>\n      </releases>\n    </pluginRepository>\n  </pluginRepositories>\n  <build>\n    <directory>${project.basedir}/target</directory>\n    <outputDirectory>${project.build.directory}/classes</outputDirectory>\n    <finalName>${project.artifactId}-${project.version}</finalName>\n    <testOutputDirectory>${project.build.directory}/test-classes</testOutputDirectory>\n    <sourceDirectory>${project.basedir}/src/main/java</sourceDirectory>\n    <scriptSourceDirectory>${project.basedir}/src/main/scripts</scriptSourceDirectory>\n    <testSourceDirectory>${project.basedir}/src/test/java</testSourceDirectory>\n    <resources>\n      <resource>\n        <directory>${project.basedir}/src/main/resources</directory>\n      </resource>\n    </resources>\n    <testResources>\n      <testResource>\n        <directory>${project.basedir}/src/test/resources</directory>\n      </testResource>\n    </testResources>\n    <pluginManagement>\n      <!-- NOTE: These plugins will be removed from future versions of the super POM -->\n      <!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) -->\n      <plugins>\n        <plugin>\n          <artifactId>maven-antrun-plugin</artifactId>\n          <version>1.3</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-assembly-plugin</artifactId>\n          <version>2.2-beta-5</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-dependency-plugin</artifactId>\n          <version>2.8</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-release-plugin</artifactId>\n          <version>2.5.3</version>\n        </plugin>\n      </plugins>\n    </pluginManagement>\n  </build>\n  <reporting>\n    <outputDirectory>${project.build.directory}/site</outputDirectory>\n  </reporting>\n  <profiles>\n    <!-- NOTE: The release profile will be removed from future versions of the super POM -->\n    <profile>\n      <id>release-profile</id>\n      <activation>\n        <property>\n          <name>performRelease</name>\n          <value>true</value>\n        </property>\n      </activation>\n      <build>\n        <plugins>\n          <plugin>\n            <inherited>true</inherited>\n            <artifactId>maven-source-plugin</artifactId>\n            <executions>\n              <execution>\n                <id>attach-sources</id>\n                <goals>\n                  <goal>jar-no-fork</goal>\n                </goals>\n              </execution>\n            </executions>\n          </plugin>\n          <plugin>\n            <inherited>true</inherited>\n            <artifactId>maven-javadoc-plugin</artifactId>\n            <executions>\n              <execution>\n                <id>attach-javadocs</id>\n                <goals>\n                  <goal>jar</goal>\n                </goals>\n              </execution>\n            </executions>\n          </plugin>\n          <plugin>\n            <inherited>true</inherited>\n            <artifactId>maven-deploy-plugin</artifactId>\n            <configuration>\n              <updateReleaseInfo>true</updateReleaseInfo>\n            </configuration>\n          </plugin>\n        </plugins>\n      </build>\n    </profile>\n  </profiles>\n</project>\n```\n\n### 配置 mvn 的 jdk 版本\n\n可统一在`settings.xml`中新增如下配置\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<settings\n    xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\">\n    <localRepository>${user.home}/.m2/repository</localRepository>\n    <profiles>\n        <profile>\n            <id>jdk</id>\n            <activation>\n                <activeByDefault>true</activeByDefault>\n                <jdk>1.8</jdk>\n            </activation>\n            <properties>\n                <maven.compiler.source>1.8</maven.compiler.source>\n                <maven.compiler.target>1.8</maven.compiler.target>\n                <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>\n            </properties>\n        </profile>\n    </profiles>\n</settings>\n\n```\n\n也在项目 pom 中增加配置\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.leaderli</groupId>\n    <artifactId>vxml-test</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n    </properties>\n    <dependencies>\n    ...\n    </dependencies>\n\n</project>\n```\n\n## 属性\n\n### 内置属性\n\n- `${basedir}`表示项目根目录，即包含`pom.xml`文件的目录;\n\n- `${version}`表示项目版本。\n\n- `${project.basedir}`同`${basedir}`;\n\n### pom 属性\n\n使用 pom 属性可以引用到 pom.xml 文件对应元素的值,继承自`Super POM`\n\n- `${project.build.sourceDirectory}`:项目的主源码目录，默认为`src/main/java/`\n- `${project.build.testSourceDirectory}`:项目的测试源码目录，默认为`/src/test/java/`\n- `${project.build.directory}`:项目构建输出目录，默认为`target/`\n- `${project.outputDirectory}`:项目主代码编译输出目录，默认为`target/classes/`\n- `${project.testOutputDirectory}`:项目测试代码编译输出目录，默认为`target/testclasses/`\n- `${project.groupId}`:项目的`groupId`\n- `${project.artifactId}`:项目的`artifactId`\n- `${project.version}`:项目的`version`,于`${version}`等价\n- `${project.build.finalName}`:项目打包输出文件的名称，默认 为`${project.artifactId}${project.version}`\n\n### 自定义属性\n\n在`pom.xml`文件的`<properties>`标签下定义的 Maven 属性,在其他地方使用`${property}`使用该属性值。\n\n### 文件属性\n\n与 pom 属性同理,用户使用以`settings`开头的属性引用`settings.xml`文件中的 XML 元素值`${settings.localRepository}`表示本地仓库的地址;\n\n### Java 系统属性\n\n所有的 Java 系统属性都可以使用 Maven 属性引用,使用`mvn help:system`命令可查看所有的 Java 系统属性;`System.getProperties()`可得到所有的 Java 属性;`${user.home}`表示用户目录;\n\n### 环境变量属性\n\n所有的环境变量都可以用以`env.`开头的 Maven 属性引用使用`mvn help:system`命令可查看所有环境变量;\\${env.JAVA_HOME}表示 JAVA_HOME 环境变量的值;\n\n## 编译资源文件\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <build>\n    ...\n    <resources>\n      <resource>\n        <targetPath>META-INF/plexus</targetPath>\n        <filtering>false</filtering>\n        <directory>${basedir}/src/main/plexus</directory>\n        <includes>\n          <include>configuration.xml</include>\n        </includes>\n        <excludes>\n          <exclude>**/*.properties</exclude>\n        </excludes>\n      </resource>\n    </resources>\n    <testResources>\n      ...\n    </testResources>\n    ...\n  </build>\n</project>\n```\n\n- `targetPath` 编译目录,默认位置为`classes`目录\n- `directory` 项目资源目录\n\n### 生命周期和阶段\n\nclean\n\n> pre-clean, clean, post-clean\n\ndefault\n\n> validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy\n\nsite\n\n> pre-site, site, post-site, site-deploy\n\n### phase\n\n执行指定阶段及该阶段的所有前置阶段的插件。\n\n### goal\n\n`mvn tomcat7:deploy`这时 goal 为`deploy`  \n`mvn clean:clean`这时 goal 为`clean`  \n`goal`可只运行指定`goal`的插件，而不会调用前置\n\n### 调试默认\n\n`mvn compile -X`  \n可以查看`compile`插件的所有细节，包括默认配置，比如日志如下\n![详细日志](./images/maven入门_1.jpg)\n\n### 插件介绍\n\n插件的`pom`会指定默认`phase`，`goal`:[插件的官方文档](https://maven.apache.org/plugins/index.html)\n\n#### clean\n\n```xml\n<build>\n    ...\n    <plugin>\n      <artifactId>maven-clean-plugin</artifactId>\n      <version>3.1.0</version>\n    </plugin>\n    ...\n</build>\n```\n\nclean 插件主要清理编译生成的文件，默认的编译目录配置在以下属性中\n\n> `project.build.directory` > `project.build.outputDirectory` > `project.build.testOutputDirectory` > `project.reporting.outputDirectory`\n\n#### compiler\n\n```xml\n <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <version>3.8.1</version>\n        <configuration>\n          <compilerVersion>1.8</compilerVersion>\n          <source>1.8</source>\n          <target>1.8</target>\n           <compilerArgs>\n            <arg>-verbose</arg>\n            <arg>-Xlint:all,-options,-path</arg>\n          </compilerArgs>\n        </configuration>\n</plugin>\n```\n\n`compilerArgs` javac 参数  \n`source` 源码 jdk 版本  \n`target` 编译 jdk 版本  \n其他详细参数介绍请查看 :[compiler:compile 参数介绍](https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html)\n\n通过 debug 模式运行 compile，可以看到 compile 编译的源目录以及目标目录\n\n```xml\n  <buildDirectory default-value=\"${project.build.directory}\"/>\n  <classpathElements default-value=\"${project.compileClasspathElements}\"/>\n  <compileSourceRoots default-value=\"${project.compileSourceRoots}\"/>\n```\n\n`${project.build.directory}` 在`Super POM`中有定义，默认值为`${project.basedir}/target`  \n`${project.compileSourceRoots}` 默认值为`${project.basedir}/${project.build.sourceDirectory}`通过查看 maven 源码:\n\n```java\npackage org.apache.maven.project;\npublic class MavenProject implements Cloneable {\n    ...\n    private List<String> compileSourceRoots = new ArrayList<>();\n    ...\n    public void addCompileSourceRoot( String path )\n    {\n        addPath( getCompileSourceRoots(), path );\n    }\n    ...\n}\n```\n\n```java\npackage org.apache.maven.project;\n@Component( role = ProjectBuilder.class )\npublic class DefaultProjectBuilder\n    implements ProjectBuilder\n{\n    ...\n        if ( project.getFile() != null )\n        {\n            Build build = project.getBuild();\n            project.addScriptSourceRoot( build.getScriptSourceDirectory() );\n            project.addCompileSourceRoot( build.getSourceDirectory() );\n            project.addTestCompileSourceRoot( build.getTestSourceDirectory() );\n        }\n    ...\n}\n```\n\n```java\npackage org.apache.maven.project;\n@Deprecated\n@Component( role = PathTranslator.class )\npublic class DefaultPathTranslator implements PathTranslator {\n    ...\n    if ( build != null )\n      {\n          build.setDirectory( alignToBaseDirectory( build.getDirectory(), basedir ) );\n          build.setSourceDirectory( alignToBaseDirectory( build.getSourceDirectory(), basedir ) );\n    ...\n}\n```\n\n```java\npackage org.apache.maven.model.interpolation;\n\npublic abstract class AbstractStringBasedModelInterpolator\n    implements ModelInterpolator\n{\n static\n    {\n        List<String> translatedPrefixes = new ArrayList<>();\n\n        // MNG-1927, MNG-2124, MNG-3355:\n        // If the build section is present and the project directory is non-null, we should make\n        // sure interpolation of the directories below uses translated paths.\n        // Afterward, we'll double back and translate any paths that weren't covered during interpolation via the\n        // code below...\n        translatedPrefixes.add( \"build.directory\" );\n        translatedPrefixes.add( \"build.outputDirectory\" );\n        translatedPrefixes.add( \"build.testOutputDirectory\" );\n        translatedPrefixes.add( \"build.sourceDirectory\" );\n        translatedPrefixes.add( \"build.testSourceDirectory\" );\n        translatedPrefixes.add( \"build.scriptSourceDirectory\" );\n        translatedPrefixes.add( \"reporting.outputDirectory\" );\n\n        TRANSLATED_PATH_EXPRESSIONS = translatedPrefixes;\n    }\n}\n...\n\nprotected List<? extends InterpolationPostProcessor> createPostProcessors( final Model model, final File projectDir, final ModelBuildingRequest config )\n    {\n        List<InterpolationPostProcessor> processors = new ArrayList<>( 2 );\n        if ( projectDir != null ){\n            processors.add( new PathTranslatingPostProcessor( PROJECT_PREFIXES, TRANSLATED_PATH_EXPRESSIONS,projectDir, pathTranslator ) );\n        }\n        processors.add( new UrlNormalizingPostProcessor( urlNormalizer ) );\n        return processors;\n    }\n...\n```\n\n#### resources\n\n编译时拷贝资源文件,不需要显式的调用插件\n\n```xml\n<build>\n  <finalName>${project.artifactId}</finalName>\n  <resources>\n    <resource>\n      <targetPath>${project.build.directory}/META-INF</targetPath>\n      <directory>${basedir}/resources</directory>\n    </resource>\n  </resources>\n</build>\n```\n\n`targetPath`编译后目录,默认是以`${project.build.outputDirectory}`为前缀的  \n`directory` 源资源目录,默认是以`${basedir}`为前缀的  \n`finalName` 打包后的项目名,默认为`${project.artifactId}-${project.version}`\n\n#### dependency\n\n解决打包依赖的 jar 包\n\n```xml\n  <plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-dependency-plugin</artifactId>\n    <version>2.10</version>\n    <executions>\n        <execution>\n            <id>copy-dependencies</id>\n            <phase>package</phase>\n            <goals>\n                <goal>copy-dependencies</goal>\n            </goals>\n            <configuration>\n                <outputDirectory>${project.build.directory}/lib</outputDirectory>\n            </configuration>\n        </execution>\n    </executions>\n</plugin>\n```\n\n`outputDirectory`表示依赖 jar 默认输出目录，默认是`${basedir}`  \n`goal`:`copy-dependencies` [相关配置详细](https://maven.apache.org/plugins/maven-dependency-plugin/copy-dependencies-mojo.html)\n\n#### antrun\n\n执行脚本\n\n```xml\n <plugin>\n        <artifactId>maven-antrun-plugin</artifactId> <!-- 拷贝插件 -->\n        <executions>\n          <execution>\n            <id>copy</id>\n            <phase>package</phase> <!-- maven生命周期 -->\n            <configuration>\n              <tasks> <!-- 其他语法自行百度maven-antrun-plugin插件的相关用法-->\n                <echo message=\"${project.build.directory}\"/>\n                <echo message=\"${output.jar.director}\"/>\n              </tasks>\n            </configuration>\n            <goals>\n              <goal>run</goal>\n            </goals>\n          </execution>\n        </executions>\n</plugin>\n```\n\n`tasks`具体语法[参考 ant 官方文档](https://ant.apache.org/manual/index.html)\n\n### 依赖冲突\n\nMaven 采用“最近获胜策略（nearest wins strategy）”的方式处理依赖冲突，即如果一个项目最终依赖于相同 artifact 的多个版本，在依赖树中离项目最近的那个版本将被使用\n\n1.当前模块直接引入合适版本的依赖\n\n2.使用 `dependency:tree -Dverbose\"`查看是否有冲突的依赖,根据输出的依赖关系图查看是否包含`conflict`，然后根据需要排除不需要引入的版本\n通过依赖排除\n\n```xml\n<dependency>\n      <groupId>jaxen</groupId>\n      <artifactId>jaxen</artifactId>\n      <version>1.2.0</version>\n      <exclusions>\n        <exclusion>\n          <groupId>xml-apis</groupId>\n          <artifactId>xml-apis</artifactId>\n        </exclusion>\n      </exclusions>\n</dependency>\n```\n\n### dependencyManagement\n\n示例说明，\n\n在父模块中：\n\n```xml\n<dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>mysql</groupId>\n                <artifactId>mysql-connector-java</artifactId>\n                <version>5.1.44</version>\n            </dependency>\n        </dependencies>\n</dependencyManagement>\n```\n\n那么在子模块中只需要`<groupId>`和`<artifactId>`即可，如：\n\n```xml\n <dependencies>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n </dependencies>\n```\n\n说明：\n使用 dependencyManagement 可以统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，不用每个模块项目都弄一个版本号，不利于管理，当需要变更版本号的时候只需要在父类容器里更新，不需要任何一个子项目的修改；如果某个子项目需要另外一个特殊的版本号时，只需要在自己的模块 dependencies 中声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号。\n\n#### 与 dependencies 区别\n\n1. Dependencies 相对于 dependencyManagement，所有生命在 dependencies 里的依赖都会自动引入，并默认被所有的子项目继承。\n2. dependencyManagement 里只是声明依赖，并不自动实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且 version 和 scope 都读取自父 pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的 jar 版本。\n\n## 模块\n\nmaven 的模块是在父类 pom 中定义聚合关系，其本质仅仅是一次性批量按顺序执行所有子模块的 mvn 命令而已\n我们已一个简单的示例来说明\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project\n    xmlns=\"http://maven.apache.org/POM/4.0.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.leaderli</groupId>\n    <artifactId>maven-parent</artifactId>\n    <version>1</version>\n    <packaging>pom</packaging>\n    <modules>\n        <module>maven-child1</module>\n        <module>maven-child2</module>\n    </modules>\n</project>\n```\n\n```xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project\n    xmlns=\"http://maven.apache.org/POM/4.0.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.leaderli</groupId>\n    <artifactId>maven-child1</artifactId>\n    <version>1</version>\n    <packaging>pom</packaging>\n    <parent>\n        <groupId>com.leaderli</groupId>\n        <artifactId>maven-parent</artifactId>\n        <version>1</version>\n    </parent>\n</project>\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project\n    xmlns=\"http://maven.apache.org/POM/4.0.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.leaderli</groupId>\n    <artifactId>maven-child2</artifactId>\n    <version>1</version>\n    <packaging>pom</packaging>\n    <parent>\n        <groupId>com.leaderli</groupId>\n        <artifactId>maven-parent</artifactId>\n        <version>1</version>\n    </parent>\n</project>\n```\n\n当我们在父类 pom 中执行打包命令`mvn install`时，其实就是依次在`maven-parent`,`maven-child1`,`maven-child2`上执行`mvn install`的过程\n\n## `SpringBoot`打包\n\n`SpringBoot`打包会生成两个文件\n\n> MyApplication-0.0.1-SNAPSHOT.war (可运行行文件)\n> MyApplication-0.0.1-SNAPSHOT.war.original(不可运行文件，用以发布在容器下)\n\n## 强制刷新本地缓存\n\n`mvn dependency:purge-local-repository`\n","categories":["java"],"tags":["maven","入门教程"]},{"title":"linux相关问题","url":"/2019/07/14/linux%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","content":"\n## root 用户无法加载 bash_profile\n\n在尝试通过使用`su root`登录到 root 用户，`/var/root/.bash_profile`的环境变量始终无法加载。\n通过查看`su`的文档\n`su`会以当前登录用户的 session 去切换用户，而`su -`会重新登录\n\n    The su command is used to become another user during a login session. Invoked without a username, su defaults to becoming the superuser. The optional argument - may be used to provide an environment similar to what the user would expect had the user logged in directly.\n\n同时\n\n    -, -l, --login\n    Provide an environment similar to what the user would expect had the user logged in directly.\n\n使用`su - root`则可正常加载环境配置\n\n下述问题也是这样的原因，可以通过上述方式去解决\n\n> autojump_add_to_database command not found\n\n## yum 安装一直超时\n\n比如有如下提示\n\n> Couldn't determine mirror, try again later 络\n\n1. 确认下是否能链接到网络\n2. 确认下 yum 的源是否失效了\n\n## make 一直循环\n\n如果系统时间比软件的发布时间要早，make 就会进入死循环。\n使用`date -s '<date>'`修改为最新的时间即可\n\n## make 缺少相关组件\n\n> cache.h:21:18: fatal error: zlib.h: No such file or directory\n\n下载`https://zlib.net/zlib-1.2.11.tar.gz`软件\n\n```shell\n#下载\n$ wget https://zlib.net/zlib-1.2.11.tar.gz\n$ tar -xvf  lib-1.2.11.tar.gz\n$ cd zlib-1.2.11\n$ ./configure\n$ make  -j4\n$ make install\n```\n","categories":["linux"],"tags":["linux","unix","problem"]},{"title":"spring tips","url":"/2019/07/10/spring-tips/","content":"\n### spring bean 多个 id\n\n```java\n@Service(\"Service-A\")\npublic class SampleService {\n    public String doSomething() { return \"Foo\"; }\n}\n\n@Configuration\npublic class SampleConfig {\n\n    @Bean(name = {\"Service-B\", \"Service-C\"})\n    public SampleService createMirroredService(@Autowired SampleService service) {\n        return service;\n    }\n}\n```\n\n### 作用域代理——proxyMode 属性\n\n将一个短生命周期作用域 bean 注入给长生命周期作用域 bean，我们期望长生命周期 bean 的属性保持与短生命周期 bean 同样。例如\n\n```java\n@Component\n@Scope(value = BeanDefinition.SCOPE_PROTOTYPE,proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class Prototype {\n}\n\n@Component\n@Scope(BeanDefinition.SCOPE_SINGLETON)\npublic class Singleton {\n  @Autowired\n  private Prototype prototype;\n}\n```\n\n保证每次`prototype`都是最新的，需要在`Prototype`类上定义`proxyMode`\n\n### 延迟加载 bean\n\n```java\n//...\nimport javax.inject.Inject;\nimport javax.inject.Provider;\n\npublic class InjectTest{\n\n    @Inject\n    Provider<InjectBean> provider;\n\n    public void test() {\n      InjectBean bean =  provider.get();\n    }\n\n}\n```\n\n使用`@Autowire`也是可以的，重要是使用了`Provider`\n\n### 基于注解的切面\n\n```java\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@Component\npublic class AnnotationAspect {\n\n  @Around(\"@annotation(Log)\")\n  public void log1(ProceedingJoinPoint point){\n    MethodSignature  s = (MethodSignature) point.getSignature();\n    Log annotation = s.getMethod().getAnnotation(Log.class);\n  }\n}\n```\n\n所有注解了`@Log`的方法都会被切\n\n### `Spring`注入文件\n\n```java\n import org.springframework.core.io.Resource;\n\n @Value(\"classpath:rootxml.js\")\n private Resource cert;\n\n @Test\n public void test() throws ScriptException, IOException {\n    System.out.println(StreamUtils.copyToString(cert.getInputStream(), StandardCharsets.UTF_8));\n }\n```\n\n### @Autowired\n\n`@Autowired(required = false)`若`Spring`容器中没有对应的`BeanDefinition`时不会注入值，可赋值一个默认值避免空指针的情况。\n\n### 定时任务\n\n`Spring`的`@Scheduled`  可使用`crontab`语法，但是不同于`unix`的标准语法，它第一位是秒\n\n```java\n@Scheduled(cron = \"1 22 22 * * *\")\npublic void log() {\n    logger.info(\"--------------------\" + index++);\n}\n```\n\n`cron`规则一定是 6 位以空白字符间隔的字符串，其中每位代表的含义如下\n\n```shell\n秒     分   小时    日    月    星期\n0-59 0-59  0-23  1-31  1-12  0-6\n\n记住几个特殊符号的含义:\n*  代表取值范围内的数字\n*/x  代表每x\nx-y  代表从x到y\n,  分开几个离散的数字\n```\n","categories":["spring"],"tags":["spring","tips"]},{"title":"maven相关","url":"/2019/07/09/maven%E7%9B%B8%E5%85%B3/","content":"\n### idea 中无法直接下载源代码\n\n可在项目目录下手动执行命令下载\n\n```bash\nmvn dependency:resolve -Dclassifier=sources\n```\n\n### maven 父类 pom\n\n定义父类`pom`\n\n```xml\n<groupId>com.li</groupId>\n  <artifactId>springboot</artifactId>\n  <version>1.0</version>\n  <name>springboot</name>\n  <packaging>pom</packaging>\n```\n\n执行`install`或`depoly`发布到仓库中\n\n其他项目引用\n\n```xml\n <parent>\n    <groupId>com.li</groupId>\n    <artifactId>springboot</artifactId>\n    <version>1.0</version>\n    <relativePath/>\n  </parent>\n```\n\n### eclipse 中 maven 项目不自动编译\n\n执行`clean`，再`compile`即可。\n","categories":["tips"],"tags":["idea","maven"]},{"title":"english","url":"/2019/07/09/english/","content":"\n## 前缀\n\n`mis`   坏，错误，否定\n\n## 后缀\n\n`less`  表示无...的、不...的\n\n`ness`  加载形容词之后，构成抽共享名词，表示性质，情况，状态\n\n## 英文标点符号\n\n句点：英国英语（BrE）：Full Stop；美国英语（AmE）：Period，“ . ”\n问号：Question Mark，“ ? ”\n感叹号：Exclamation Mark，“ ! ”\n逗号：Comma，“ , ”\n冒号：Colon，“  : ”\n省略号：Ellipsis (众数：Ellipses)，“ ... ”\n分号：Semicolon，“ ; ”\n连字符：Hyphen，“ - ”\n连接号：En Dash，“ – ”\n破折号：Em Dash，“ — ”\n括号：Parentheses，\n　　　小括号（圆括号）“ ( ) ”（parenthesis; round brackets）；\n　　　中括号“ [ ] ”（square brackets）；\n　　　大括号“ { } ”（brackets; braces）\n引号：Quotation Marks，\n　　　双引号“ \" ”（quote）；\n　　　单引号“ ' ”（single quotation marks）\n缩写及所有格符号：Apostrophe，“ ' ”\n","categories":["english"],"tags":["english prefix subfix"]},{"title":"markdown和KaTex","url":"/2019/07/08/markdown%E5%92%8CKaTex/","content":"\n## markdown 语法\n\n- 空白行 `&emsp;`\n\n- 首行缩进，通过两个空白行来实现 `&emsp;&emsp;`\n- 换行 两段之间插入一个空白行，或者上一行行尾插入一个空字符串\n- 有序列表\n\n  ```markdown\n  1. ol\n  2. ol\n  ```\n\n- 文本引用\n\n  ```markdown\n  > 这个是区块引用\n  >\n  > > 这个也是区块引用\n  > >\n  > > > 这个还是是区块引用\n  ```\n\n- 插入图片\n  md 文件同级目录会生成一个同名文件夹，图片放入其中，然后通过如下方式引入\n  `![详细日志](./images/图片名.jpg)`\n  该目录在`hexo`项目目录的`source`目录下，将图片放入其中即可，为了避免冲突\n- 链接&emsp;`[title](urls)`\n\n- 表格基本模板，其中`:`表示对齐，表格上方需要空一行，否则无法正常显示\n\n  | Table Header 1 | Table Header 2 | Table Header 3 |\n  | :------------- | :------------: | -------------: |\n  | Division 1     |   Division 2   |     Division 3 |\n  | Division 1     |   Division 2   |     Division 3 |\n  | Division 1     |   Division 2   |     Division 3 |\n\n- 文本换行可在上一段文本后追加至少两个空格\n\n- 加粗文本\n\n  ```markdown\n  **_加粗的文本_**\n  ```\n\n- 代码块\n  \\`\\`\\`language\n  \\`\\`\\`\n  支持的语言有\n  `c`, `abnf`, `accesslog`, `actionscript`, `ada`, `apache`, `applescript`, `arduino`, `armasm`, `asciidoc`, `aspectj`, `autohotkey`, `autoit`, `avrasm`, `awk`, `axapta`, `bash`, `basic`, `bnf`, `brainfuck`, `cal`, `capnproto`, `ceylon`, `clean`, `clojure`, `clojure`-`repl`, `cmake`, `coffeescript`, `coq`, `cos`, `cpp`, `crmsh`, `crystal`, `cs`, `csp`, `css`, `d`, `dart`, `delphi`, `diff`, `django`, `dns`, `dockerfile`, `dos`, `dsconfig`, `dts`, `dust`, `ebnf`, `elixir`, `elm`, `erb`, `erlang`, `erlang`-`repl`, `excel`, `fix`, `flix`, `fortran`, `fsharp`, `gams`, `gauss`, `gcode`, `gherkin`, `glsl`, `go`, `golo`, `gradle`, `groovy`, `haml`, `handlebars`, `haskell`, `haxe`, `hsp`, `htmlbars`, `http`, `hy`, `inform7`, `ini`, `irpf90`, `java`, `javascript`, `json`, `julia`, `kotlin`, `lasso`, `ldif`, `leaf`, `less`, `lisp`, `livecodeserver`, `livescript`, `llvm`, `lsl`, `lua`, `makefile`, `markdown`, `mathematica`, `matlab`, `maxima`, `mel`, `mercury`, `mipsasm`, `mizar`, `mojolicious`, `monkey`, `moonscript`, `n1ql`, `nginx`, `nimrod`, `nix`, `nsis`, `objectivec`, `ocaml`, `openscad`, `oxygene`, `parser3`, `perl`, `pf`, `php`, `pony`, `powershell`, `processing`, `profile`, `prolog`, `protobuf`, `puppet`, `purebasic`, `python`, `q`, `qml`, `r`, `rib`, `roboconf`, `rsl`, `ruby`, `ruleslanguage`, `rust`, `scala`, `scheme`, `scilab`, `scss`, `smali`, `smalltalk`, `sml`, `sqf`, `sql`, `stan`, `stata`, `step21`, `stylus`, `subunit`, `swift`, `taggerscript`, `tap`, `tcl`, `tex`, `thrift`, `tp`, `twig`, `typescript`, `vala`, `vbnet`, `vbscript`, `vbscript`-`html`, `verilog`, `vhdl`, `vim`, `x86asm`, `xl`, `xml`, `xquery`, `yaml`, `zephir`\n\n- 转义字符\\\\\n\n## KaTex\n\n[参考文档](https://katex.org/docs/supported.html)\n\n基本 KaTex 首尾需要`$`包含,例如`$X_y$`表示$X_y$\n\n常用\n| 表达式 | 示例 |\n| :----: | :----: |\n| `\\{\\}` | $\\{\\}$ |\n| `\\ge` | $\\ge$ |\n| `\\le` | $\\le$ |\n| `X_y` | $X_y$ |\n| `X^{y}` | $x^{y}$ |\n|`\\hat{\\delta}`|$\\hat{\\delta}$|\n\n块状使用`$$`包含\n\n不支持中文\n\n## hexo\n\n### 快捷方式\n\n站内引用，引用自己的博客\n{% post_link 文章文件名（不要后缀） %}\n\n使用`F8`快速定位`markdown`语法错误的地方。\n\n插入的图片上面需要有一行文字，否则生成的网页图片显示会有瑕疵\n\n### 调试\n\n运行命令时带上参数`--debug`,则会输出`console.log()`所打印的日志\n\n### 本地搜索\n\n安装插件\n\n```shell\nnpm install hexo-generator-searchdb --save\n\n```\n\n根目录`_config.yml`中开启本地搜索,`xml`对于特殊字符的处理可能存在问题，建议使用`json`\n\n```yml\n#本地搜索\nsearch:\n  # path: search.xml\n  path: search.json\n  field: post\n  content: true\n  format: html\n```\n\n同时`theme`下的配置需要开启\n\n```yml\nlocal_search:\n  enable: true\n  # If auto, trigger search by changing input.\n  # If manual, trigger search by pressing enter key or search button.\n  trigger: auto\n  # Show top n results per article, show all results by setting to -1\n  top_n_per_article: 1\n  # Unescape html strings to the readable one.\n  unescape: false\n```\n\n`hexo`开始搜索使用插件`hexo-generator-searchdb`，插件在扫描项目文件后生成`search.json`文件。\n该文件按照特定格式存储了博客的所有内容。但该插件记录的中文为`ascii`码，因此在搜索时使用中文搜索不到\n博客正文内容，因此我们需要修改生成`search.json`文件的过程。将`ascii`转码。\n\n修改项目根目录下的文件`node_modules/hexo-generator-searchdb/lib/json_generator.js`\n\n```js\n\"use strict\";\n\nmodule.exports = function (locals) {\n  var config = this.config;\n  var database = require(\"./database\")(locals, config);\n\n  // ---------------------------------------------新增修改\n  function reconvert(str) {\n    str = str.replace(/(\\\\u)(\\w{1,4})/gi, function ($0) {\n      return String.fromCharCode(\n        parseInt(escape($0).replace(/(%5Cu)(\\w{1,4})/g, \"$2\"), 16)\n      );\n    });\n    str = str.replace(/(&#x)(\\w{1,4});/gi, function ($0) {\n      return String.fromCharCode(\n        parseInt(escape($0).replace(/(%26%23x)(\\w{1,4})(%3B)/g, \"$2\"), 16)\n      );\n    });\n    str = str.replace(/(&#)(\\d{1,6});/gi, function ($0) {\n      return String.fromCharCode(\n        parseInt(escape($0).replace(/(%26%23)(\\d{1,6})(%3B)/g, \"$2\"))\n      );\n    });\n\n    return str;\n  }\n  database.forEach(function (item) {\n    item.content = reconvert(item.content);\n  });\n  // -----------------------------------------------\n  return {\n    path: config.search.path,\n    data: JSON.stringify(database),\n  };\n};\n```\n\n### vscode 中图片无法预览\n\nvscode 中的 markdown 图片仅能预览当前 md 文件下或其子文件中的图片，但是若是图片在这儿，渲染后的 html 文件中将无法查看图片。我们自定义两个插件来解决这个问题。\n\n根据[hexo api](https://hexo.io/zh-cn/api/)我们编写两个插件\n\n1. 首先我们在`source/_posts`目录下建一个专门用于存放图片的文件夹`images`，在 markdown 中我们使用`![name](./images/picture.png)`来插入图片,这样我们在 vscode 中就可以预览图片了。\n2. 编写一个插件`hexo-li-assert-image`，用于将`![name](./images/picture.png)`渲染后的`<img>`中的 src 替换为`/images/picture.png`\n3. 编写一个插件，用于在渲染完成后，将`source/_posts/images/`的所有图片拷贝到`public/images`下\n\n代码如下\n\n```js\n\"use strict\";\nvar cheerio = require(\"cheerio\");\n\nhexo.extend.filter.register(\"after_post_render\", function (data) {\n  var path = hexo.config.li.path; //_config.yml中新增配置\n  if (path.length < 1) {\n    return;\n  }\n\n  var toprocess = [\"excerpt\", \"more\", \"content\"];\n  for (var i = 0; i < toprocess.length; i++) {\n    var key = toprocess[i];\n    var $ = cheerio.load(data[key], {\n      ignoreWhitespace: false,\n      xmlMode: false,\n      lowerCaseTags: false,\n      decodeEntities: false,\n    });\n    $(\"img\").each(function () {\n      if ($(this).attr(\"src\")) {\n        var src = $(this).attr(\"src\").replace(\"\\\\\", \"/\");\n        if (src.startsWith(\"./images/\")) {\n          src = src.substring(1);\n          $(this).attr(\"src\", src);\n        }\n      }\n    });\n    data[key] = $.html();\n  }\n});\n```\n\n```js\n\"use strict\";\nvar fs = require(\"fs\");\n\nhexo.on(\"generateAfter\", function (post) {\n  var path = hexo.config.li.path;\n  if (path.length < 1) {\n    return;\n  }\n  var source_img_path = path + \"source/_posts/images/\";\n  var target_img_path = path + \"public/images/\";\n\n  if (!fs.existsSync(target_img_path)) {\n    console.log(\"mkdir \" + target_img_path);\n    fs.mkdirSync(target_img_path, { recursive: true });\n  }\n\n  let paths = fs.readdirSync(source_img_path);\n  paths.forEach(function (path) {\n    if (path.startsWith(\".\")) {\n      return;\n    }\n    var _src = source_img_path + path;\n    var _tar = target_img_path + path;\n    if (fs.existsSync(_tar)) {\n      return;\n    }\n    fs.copyFileSync(_src, _tar, fs.constants.COPYFILE_EXCL);\n  });\n});\n```\n\n### 本地搜索增加正则模式\n\n当我们开始搜索时，若以`/`开始，当输入的是有效的 js 正则表达式(`/reg/`)时，才会开始搜索所有文章，开始搜索时会将正则表达式的的最后一个`/`截掉\n\n使用 next 主题，修改其本地搜索的逻辑。拷贝｀ themes/next/layout/\\_third-party/search/localsearch.swig`为`li_localsearch.swig`。\n将其修改为\n\n```html\n{% if theme.local_search.enable %}\n<script>\n  // Popup Window;\n  var isfetched = false;\n  var isXml = true;\n  // Search DB path;\n  var search_path = \"{{ config.search.path }}\";\n  if (search_path.length === 0) {\n    search_path = \"search.xml\";\n  } else if (/json$/i.test(search_path)) {\n    isXml = false;\n  }\n  var path = \"{{ config.root }}\" + search_path;\n  // monitor main search box;\n\n  var onPopupClose = function (e) {\n    $(\".popup\").hide();\n    $(\"#local-search-input\").val(\"\");\n    $(\".search-result-list\").remove();\n    $(\"#no-result\").remove();\n    $(\".local-search-pop-overlay\").remove();\n    $(\"body\").css(\"overflow\", \"\");\n  };\n\n  function proceedsearch() {\n    $(\"body\")\n      .append(\n        '<div class=\"search-popup-overlay local-search-pop-overlay\"></div>'\n      )\n      .css(\"overflow\", \"hidden\");\n    $(\".search-popup-overlay\").click(onPopupClose);\n    $(\".popup\").toggle();\n    var $localSearchInput = $(\"#local-search-input\");\n    $localSearchInput.attr(\"autocapitalize\", \"none\");\n    $localSearchInput.attr(\"autocorrect\", \"off\");\n    $localSearchInput.focus();\n  }\n\n  // search function;\n  var searchFunc = function (path, search_id, content_id) {\n    \"use strict\";\n\n    // start loading animation\n    $(\"body\")\n      .append(\n        '<div class=\"search-popup-overlay local-search-pop-overlay\">' +\n          '<div id=\"search-loading-icon\">' +\n          '<i class=\"fa fa-spinner fa-pulse fa-5x fa-fw\"></i>' +\n          \"</div>\" +\n          \"</div>\"\n      )\n      .css(\"overflow\", \"hidden\");\n    $(\"#search-loading-icon\")\n      .css(\"margin\", \"20% auto 0 auto\")\n      .css(\"text-align\", \"center\");\n\n    $.ajax({\n      url: path,\n      dataType: isXml ? \"xml\" : \"json\",\n      async: true,\n      success: function (res) {\n        // get the contents from search data\n        isfetched = true;\n        $(\".popup\").detach().appendTo(\".header-inner\");\n        var datas = isXml\n          ? $(\"entry\", res)\n              .map(function () {\n                return {\n                  title: $(\"title\", this).text(),\n                  content: $(\"content\", this).text(),\n                  url: $(\"url\", this).text(),\n                };\n              })\n              .get()\n          : res;\n        var input = document.getElementById(search_id);\n        var resultContent = document.getElementById(content_id);\n        var inputEventFunction = function () {\n          var searchText = input.value.toLowerCase();\n          if (searchText.length < 1) {\n            return;\n          }\n          var keywords = [];\n          var first_keyword;\n          if (searchText.charAt(0) === \"/\") {\n            if (searchText.indexOf(\"/\", 1) == 1) {\n              keywords.push(searchText.substring(1));\n            } else if (\n              searchText.length > 2 &&\n              searchText.charAt(searchText.length - 1) === \"/\"\n            ) {\n              keywords.push(\"$$\");\n              try {\n                eval(\"first_keyword = \" + searchText + \"g\");\n              } catch (err) {\n                console.error(err);\n                return;\n              }\n              input.value = searchText.substring(0, searchText.length - 1);\n            } else {\n              return;\n            }\n          } else {\n            keywords.push(searchText);\n          }\n          var resultItems = [];\n          // perform local searching\n          datas.forEach(function (data) {\n            var isMatch = false;\n            var hitCount = 0;\n            var searchTextCount = 0;\n            var title = data.title.trim();\n            var titleInLowerCase = title.toLowerCase();\n            var content = data.content.trim();\n            var contentInLowerCase = content.toLowerCase();\n            var articleUrl = decodeURIComponent(data.url).replace(\n              /\\/{2,}/g,\n              \"/\"\n            );\n            var indexOfTitle = [];\n            var indexOfContent = [];\n            // only match articles with not empty titles\n            if (title != \"\") {\n              if (first_keyword) {\n                keywords = contentInLowerCase.match(first_keyword);\n              }\n              if (!keywords) {\n                keywords = [];\n              }\n              keywords.forEach(function (keyword) {\n                if (\n                  keyword === \"test\" &&\n                  titleInLowerCase.indexOf(\"bash\") > -1\n                ) {\n                  console.log(contentInLowerCase);\n                }\n                function getIndexByWord(word, text, caseSensitive) {\n                  var wordLen = word.length;\n                  if (wordLen === 0) {\n                    return [];\n                  }\n                  var startPosition = 0,\n                    position = [],\n                    index = [];\n                  if (!caseSensitive) {\n                    text = text.toLowerCase();\n                    word = word.toLowerCase();\n                  }\n                  while ((position = text.indexOf(word, startPosition)) > -1) {\n                    index.push({ position: position, word: word });\n                    startPosition = position + wordLen;\n                  }\n                  return index;\n                }\n\n                indexOfTitle = indexOfTitle.concat(\n                  getIndexByWord(keyword, titleInLowerCase, false)\n                );\n                indexOfContent = indexOfContent.concat(\n                  getIndexByWord(keyword, contentInLowerCase, false)\n                );\n              });\n              if (indexOfTitle.length > 0 || indexOfContent.length > 0) {\n                isMatch = true;\n                hitCount = indexOfTitle.length + indexOfContent.length;\n              }\n            }\n\n            // show search results\n\n            if (isMatch) {\n              // sort index by position of keyword\n\n              [indexOfTitle, indexOfContent].forEach(function (index) {\n                index.sort(function (itemLeft, itemRight) {\n                  if (itemRight.position !== itemLeft.position) {\n                    return itemRight.position - itemLeft.position;\n                  } else {\n                    return itemLeft.word.length - itemRight.word.length;\n                  }\n                });\n              });\n\n              // merge hits into slices\n\n              function mergeIntoSlice(text, start, end, index) {\n                var item = index[index.length - 1];\n                var position = item.position;\n                var word = item.word;\n                var hits = [];\n                var searchTextCountInSlice = 0;\n                while (position + word.length <= end && index.length != 0) {\n                  if (word === searchText) {\n                    searchTextCountInSlice++;\n                  }\n                  hits.push({ position: position, length: word.length });\n                  var wordEnd = position + word.length;\n\n                  // move to next position of hit\n\n                  index.pop();\n                  while (index.length != 0) {\n                    item = index[index.length - 1];\n                    position = item.position;\n                    word = item.word;\n                    if (wordEnd > position) {\n                      index.pop();\n                    } else {\n                      break;\n                    }\n                  }\n                }\n                searchTextCount += searchTextCountInSlice;\n                return {\n                  hits: hits,\n                  start: start,\n                  end: end,\n                  searchTextCount: searchTextCountInSlice,\n                };\n              }\n\n              var slicesOfTitle = [];\n              if (indexOfTitle.length != 0) {\n                slicesOfTitle.push(\n                  mergeIntoSlice(title, 0, title.length, indexOfTitle)\n                );\n              }\n\n              var slicesOfContent = [];\n              while (indexOfContent.length != 0) {\n                var item = indexOfContent[indexOfContent.length - 1];\n                var position = item.position;\n                var word = item.word;\n                // cut out 100 characters\n                var start = position - 20;\n                var end = position + 80;\n                if (start < 0) {\n                  start = 0;\n                }\n                if (end < position + word.length) {\n                  end = position + word.length;\n                }\n                if (end > content.length) {\n                  end = content.length;\n                }\n                slicesOfContent.push(\n                  mergeIntoSlice(content, start, end, indexOfContent)\n                );\n              }\n\n              // sort slices in content by search text's count and hits' count\n\n              slicesOfContent.sort(function (sliceLeft, sliceRight) {\n                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {\n                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;\n                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {\n                  return sliceRight.hits.length - sliceLeft.hits.length;\n                } else {\n                  return sliceLeft.start - sliceRight.start;\n                }\n              });\n\n              // select top N slices in content\n\n              var upperBound = parseInt(\n                \"{{ theme.local_search.top_n_per_article }}\"\n              );\n              if (upperBound >= 0) {\n                slicesOfContent = slicesOfContent.slice(0, upperBound);\n              }\n\n              // highlight title and content\n\n              function highlightKeyword(text, slice) {\n                var result = \"\";\n                var prevEnd = slice.start;\n                slice.hits.forEach(function (hit) {\n                  result += text.substring(prevEnd, hit.position);\n                  var end = hit.position + hit.length;\n                  result +=\n                    '<b class=\"search-keyword\">' +\n                    text.substring(hit.position, end) +\n                    \"</b>\";\n                  prevEnd = end;\n                });\n                result += text.substring(prevEnd, slice.end);\n                return result;\n              }\n\n              var resultItem = \"\";\n\n              if (slicesOfTitle.length != 0) {\n                resultItem +=\n                  \"<li><a href='\" +\n                  articleUrl +\n                  \"' class='search-result-title'>\" +\n                  highlightKeyword(title, slicesOfTitle[0]) +\n                  \"</a>\";\n              } else {\n                resultItem +=\n                  \"<li><a href='\" +\n                  articleUrl +\n                  \"' class='search-result-title'>\" +\n                  title +\n                  \"</a>\";\n              }\n\n              slicesOfContent.forEach(function (slice) {\n                resultItem +=\n                  \"<a href='\" +\n                  articleUrl +\n                  \"'>\" +\n                  '<p class=\"search-result\">' +\n                  highlightKeyword(content, slice) +\n                  \"...</p>\" +\n                  \"</a>\";\n              });\n\n              resultItem += \"</li>\";\n              resultItems.push({\n                item: resultItem,\n                searchTextCount: searchTextCount,\n                hitCount: hitCount,\n                id: resultItems.length,\n              });\n            }\n          });\n          if (keywords.length === 1 && keywords[0] === \"\") {\n            resultContent.innerHTML =\n              '<div id=\"no-result\"><i class=\"fa fa-search fa-5x\"></i></div>';\n          } else if (resultItems.length === 0) {\n            resultContent.innerHTML =\n              '<div id=\"no-result\"><i class=\"fa fa-frown-o fa-5x\"></i></div>';\n          } else {\n            resultItems.sort(function (resultLeft, resultRight) {\n              if (resultLeft.searchTextCount !== resultRight.searchTextCount) {\n                return resultRight.searchTextCount - resultLeft.searchTextCount;\n              } else if (resultLeft.hitCount !== resultRight.hitCount) {\n                return resultRight.hitCount - resultLeft.hitCount;\n              } else {\n                return resultRight.id - resultLeft.id;\n              }\n            });\n            var searchResultList = '<ul class=\"search-result-list\">';\n            resultItems.forEach(function (result) {\n              searchResultList += result.item;\n            });\n            searchResultList += \"</ul>\";\n            resultContent.innerHTML = searchResultList;\n          }\n        };\n\n        if (\"auto\" === \"{{ theme.local_search.trigger }}\") {\n          input.addEventListener(\"input\", inputEventFunction);\n        } else {\n          $(\".search-icon\").click(inputEventFunction);\n          input.addEventListener(\"keypress\", function (event) {\n            if (event.keyCode === 13) {\n              inputEventFunction();\n            }\n          });\n        }\n\n        // remove loading animation\n        $(\".local-search-pop-overlay\").remove();\n        $(\"body\").css(\"overflow\", \"\");\n\n        proceedsearch();\n      },\n    });\n  };\n\n  // handle and trigger popup window;\n  $(\".popup-trigger\").click(function (e) {\n    e.stopPropagation();\n    if (isfetched === false) {\n      searchFunc(path, \"local-search-input\", \"local-search-result\");\n    } else {\n      proceedsearch();\n    }\n  });\n\n  $(\".popup-btn-close\").click(onPopupClose);\n  $(\".popup\").click(function (e) {\n    e.stopPropagation();\n  });\n  $(document).on(\"keyup\", function (event) {\n    var shouldDismissSearchPopup =\n      event.which === 27 && $(\".search-popup\").is(\":visible\");\n    if (shouldDismissSearchPopup) {\n      onPopupClose();\n    }\n  });\n</script>\n{% endif %}\n```\n\n修改同目录下的`index.swig`\n\n```html\n{% include 'algolia-search.swig' %} {% if theme.local_search.li%} {% include\n'li_localsearch.swig' %} {% else %} {% include 'localsearch.swig' %} {% endif %}\n```\n\n在主题配置文件中,增加\n\n```yml\nlocal_search:\n  enable: true\n  # If auto, trigger search by changing input.\n  # If manual, trigger search by pressing enter key or search button.\n  trigger: auto\n  # Show top n results per article, show all results by setting to -1\n  top_n_per_article: 1\n  # Unescape html strings to the readable one.\n  unescape: false\n  li: true\n```\n\n### 后台进程启动 hexo server\n\n在博客根目录下面创建一个 hexo_run.js\n\n```javascript\nconst { exec } = require(\"child_process\");\nexec(\"hexo server\", (error, stdout, stderr) => {\n  if (error) {\n    console.log(\"exec error: ${error}\");\n    return;\n  }\n  console.log(\"stdout: ${stdout}\");\n  console.log(\"stderr: ${stderr}\");\n});\n```\n\n```shell\n#全局安装\n$ npm  install -g pm2\n#在根目录下运行\n$ pm2 start hexo_run.js\n```\n\n### hexo 错误解决\n\n> Error: expected end of comment, got end of file\n\n![markdown和KaTex_注释.png](./images/markdown和KaTex_注释.png)\n","categories":["hexo"],"tags":["markdown","katex","latex","ascii"]},{"title":"背包问题","url":"/2019/07/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","content":"## 动态规划\n\n&emsp;&emsp;通过把原问题分解为相对简单的子问题的方式来解决复杂问题的方法，动态规划常常适用于有重叠子问题和最优子结构的问题。动态规划背后的基本思想非常简单，大致上，若要解决一个给定问题，我们需要解决不同部分(子问题)，再根据子问题的解得出原问题的解。\n\n&emsp;&emsp;通常许多子问题非常相似，为此动态规划试图仅仅解决一次子问题，从而减少计算量，一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下一次需要同一个子问题解之时直接查表。\n\n## 最大子序列和\n\n对于给定序列$\\{A_1,A_2,...,A_i\\}$,求解最大子序列和\n\n状态转移方程：\n\n- $dp(1) = A1$\n- $dp(i) = max\\{A_i,A_i+dp(i-1)\\}$\n\n```java\npublic int maxSubArray(int... nums) {\n    int ans = nums[0];\n    if (nums.length == 1) {\n      return ans;\n    }\n    for (int i = 1; i < nums.length; i++) {\n      ans = Math.max(nums[i], ans + nums[i]);\n    }\n    return ans;\n  }\n```\n\n## 简单背包问题\n\n一个容量为V的背包，N种不同质量$N_v$的物品，为求解将哪些物品装入背包可使总和最大，不同质量的物品不限数量\n\n状态转移方程：\n\n- $F(0) = 0$\n- $F(V) = max\\{F(V-1),N_v+F(V-N_v)|N_v \\le V\\}$\n\n总重量为0，那么物品数量也为0\n\n总重量为V时有两种情况，\n\n- 第一种是该重量无法填满，这对应表达式$F(V-1)$的解。\n\n- 第二种情况是刚好填满，这对应一系列刚好填满的可能性的集合，其中的可能性是指最后放入包中的物品恰好是重量为$N_v$的物品，而这时候我们只需要解出$F(V-N_v)$的值即可。\n\n```java\n\n  public static int max(int[] nums, int V, Integer[] map) {\n    if (map == null) {\n      map = new Integer[V + 1];\n    }\n    if (map[V] != null) {\n      return map[V];\n    }\n    int max = V == 0 ? 0 : max(nums, V - 1, map);\n    for (int Nv : nums) {\n      if (Nv <= V) {\n        max = Math.max(Nv + max(nums, V - Nv, map), max);\n      }\n    }\n    map[V] = max;\n    return max;\n  }\n```\n\n## 参考链接\n\n[维基百科-背包问题](https://zh.wikipedia.org/wiki/背包问题)  \n[维基百科-动态规划](https://zh.wikipedia.org/wiki/动态规划)\n","categories":["算法"],"tags":["动态规划","算法","状态转移方程"]},{"title":"正则表达式.md","url":"/2019/07/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"\n## 占有字符和零宽度\n\n正则表达式匹配过程中，如果子表达式匹配到东西，儿并非一个位置，并保存到匹配结果中，这样的就称为占有字符，而只匹配到一个位置，或者匹配的内容并不保存到最终匹配结果中，这样的就称为零宽度。占有字符是互斥的，而零宽度不是互斥的。\n\n## 控制权和传动\n\n正则表达式从左到右依次进行匹配，通常情况下有一个表达式取得控制权，从字符串的摸个位置开始匹配，一个表达式开始匹配的位置是由前一个子表达匹配成功的结束位置开始的。如果表达式是零宽度，那后一个表达式的匹配位置就是零宽度匹配的位置。\n\n## 分组\n\n使用小括号包含的子表达式，可以使用回溯引用`\\n`来引用某个子表达式\n\n```javascript\n<(h[1-6])>\\w*?<\\/\\1>\n```\n\n匹配结果: `<h1>xxx</h1>`\n\n## 零宽度断言\n\n`(?=exp)`\n匹配 exp 前面的位置，但不匹配 exp。表达式前面要加其它表达式配合使用\n\n> ab(?=123) `ab`123ab234\n\n`(?!exp)**`\n匹配不是 exp 前面的位置，但不匹配 exp。表达式前面要加其它表达式配合使用\n\n> ab(?=123) ab123`ab`234\n\n`(?<=exp)`\n匹配 exp 后面的位置，但不匹配 exp。表达式后面加其它表达式配合使用\n\n> (?<=123)ab ab123`ab`234\n\n`(?<!exp)`\n匹配不是 exp 后面的位置，但不匹配 exp。表达式前面要加其它表达式配合使用\n\n> ab(?<!123) ab123`ab`234`ab`\n\n## 贪婪与非贪婪\n\n限定符 `*` `+` `？` `{n}` `{n,}` `{n,m}`\n非贪婪 限定符后加 `?`\n","categories":["计算机基础"],"tags":["regex"]},{"title":"oracle练习","url":"/2019/07/04/oracle%E7%BB%83%E4%B9%A0/","content":"\n### 建表语句和数据插入\n\n```sql\ncreate table STUDENT\n(\nSNO VARCHAR2(20) not null\nprimary key,\nSNAME VARCHAR2(20) not null,\nSSEX VARCHAR2(20) not null,\nSBIRTHDAY DATE,\nCLASS VARCHAR2(20)\n);\n\ncreate table TEACHER\n(\nTNO VARCHAR2(20) not null\nprimary key,\nTNAME VARCHAR2(20) not null,\nTSEX VARCHAR2(20) not null,\nTBIRTHDAY DATE,\nPROF VARCHAR2(20),\nDEPART VARCHAR2(20) not null\n);\n\ncreate table COURSE\n(\nCNO VARCHAR2(20) not null\nprimary key,\nCNAME VARCHAR2(20) not null,\nTNO VARCHAR2(20) not null\nreferences TEACHER\n);\n\ncreate table SCORE\n(\nSNO VARCHAR2(20) not null\nreferences STUDENT,\nCNO VARCHAR2(20) not null\nreferences COURSE,\nDEGREE NUMBER\n);\n\n--添加学生信息\nINSERT INTO student VALUES ('108', '曾华', '男', to_date('1977-09-01','yyyy-mm-dd'), '95033');\nINSERT INTO student VALUES ('105', '匡明', '男', to_date('1975-10-02','yyyy-mm-dd'), '95031');\nINSERT INTO student VALUES ('107', '王丽', '女', to_date('1976-01-23','yyyy-mm-dd'), '95033');\nINSERT INTO student VALUES ('101', '李军', '男', to_date('1976-02-20','yyyy-mm-dd'), '95033');\nINSERT INTO student VALUES ('109', '王芳', '女', to_date('1975-02-10','yyyy-mm-dd'), '95031');\nINSERT INTO student VALUES ('103', '陆君', '男', to_date('1974-06-03','yyyy-mm-dd'), '95031');\n\n--添加教师表\nINSERT INTO teacher VALUES ('804', '李诚', '男', to_date('1958-12-02','yyyy-mm-dd'), '副教授', '计算机系');\nINSERT INTO teacher VALUES ('856', '张旭', '男', to_date('1969-03-12','yyyy-mm-dd'), '讲师', '电子工程系');\nINSERT INTO teacher VALUES ('825', '王萍', '女', to_date('1972-05-05','yyyy-mm-dd'), '助教', '计算机系');\nINSERT INTO teacher VALUES ('831', '刘冰', '女', to_date('1977-08-14','yyyy-mm-dd'), '助教', '电子工程系');\n\n--添加课程表\nINSERT INTO course VALUES ('3-105', '计算机导论', '825');\nINSERT INTO course VALUES ('3-245', '操作系统', '804');\nINSERT INTO course VALUES ('6-166', '数字电路', '856');\nINSERT INTO course VALUES ('9-888', '高等数学', '831');\n\n--添加成绩表\nINSERT INTO score VALUES ('103', '3-245', '86');\nINSERT INTO score VALUES ('105', '3-245', '75');\nINSERT INTO score VALUES ('109', '3-245', '68');\nINSERT INTO score VALUES ('103', '3-105', '92');\nINSERT INTO score VALUES ('105', '3-105', '88');\nINSERT INTO score VALUES ('109', '3-105', '76');\nINSERT INTO score VALUES ('103', '3-105', '64');\nINSERT INTO score VALUES ('105', '3-105', '91');\nINSERT INTO score VALUES ('109', '3-105', '78');\nINSERT INTO score VALUES ('103', '6-166', '85');\nINSERT INTO score VALUES ('105', '6-166', '79');\nINSERT INTO score VALUES ('109', '6-166', '81');\n```\n\n## 习题\n\n```sql\n--查询教师所有的单位即不重复的Depart列。\n--查询Score表中成绩在60到80之间的所有记录。\n--查询Score表中成绩为85，86或88的记录。\n--查询Student表中“95031”班或性别为“女”的同学记录。\n--以Class降序查询Student表的所有记录。\n--以Cno升序、Degree降序查询Score表的所有记录\n--查询“95031”班的学生人数\n--查询Score表中的最高分的学生学号和课程号\n--查询每门课的平均成绩\n--查询Score表中至少有5名学生选修的并以3开头的课程的平均分数。\n--查询所有学生的Sname、Cno和Degree列\n--查询“张旭“教师任课的学生成绩。\n--查询选修某课程的同学人数多于5人的教师姓名\n--查询存在有85分以上成绩的课程Cno.\n--查询出“计算机系“教师所教课程的成绩表\n--查询“计算 机系”与“电子工程系“不同职称的教师的Tname和Prof\n--查询选修编号为“3-105“课程且成绩至少高于选修编号为“3-245”的同学的Cno、Sno和Degree,并按Degree从高到低次序排序。\n--查询选修编号为“3-105”且成绩高于选修编号为“3-245”课程的同学的Cno、Sno和Degree.all:代表括号中的所有成绩\n--查询所有“女”教师和“女”同学的name、sex和birthday\n--查询成绩比该课程平均成绩低的同学的成绩表\n--查询所有未讲课的教师的Tname和Depart.\n--查询至少有2名男生的班号\n--查询Student表中不姓“王”的同学记录\n--查询Student表中每个学生的姓名和年龄\n```\n\n## 答案\n\n```sql\n--查询教师所有的单位即不重复的Depart列。\nSELECT DISTINCT depart\nFROM teacher;\n--查询Score表中成绩在60到80之间的所有记录。\nSELECT *\nFROM SCORE\nWHERE DEGREE >= 60 AND DEGREE <= 80;\nSELECT *\nFROM SCORE\nWHERE DEGREE BETWEEN 60 AND 80;\n--查询Score表中成绩为85，86或88的记录。\nSELECT *\nFROM SCORE\nWHERE DEGREE IN (85, 86, 88);\n--查询Student表中“95031”班或性别为“女”的同学记录。\nSELECT *\nFROM STUDENT\nWHERE CLASS = '95031' AND SSEX = '女';\n--以Class降序查询Student表的所有记录。\nSELECT *\nFROM STUDENT\nORDER BY CLASS DESC;\n--以Cno升序、Degree降序查询Score表的所有记录\nSELECT *\nFROM SCORE\nORDER BY CNO ASC, DEGREE DESC;\n--查询“95031”班的学生人数\nSELECT count(1)\nFROM STUDENT\nWHERE CLASS = '95031';\n-- 查询Score表中的最高分的学生学号和课程号\nSELECT *\nFROM SCORE\nWHERE DEGREE = (SELECT max(DEGREE)\n                FROM SCORE);\n--查询每门课的平均成绩\nSELECT *\nFROM SCORE;\nSELECT\n  CNO,\n  round(avg(DEGREE), 2)\nFROM SCORE\nGROUP BY CNO;\n--查询Score表中至少有5名学生选修的并以3开头的课程的平均分数。\nSELECT\n  CNO,\n  round(avg(DEGREE), 2)\nFROM SCORE\nWHERE CNO IN (SELECT CNO\n              FROM (SELECT\n                      CNO,\n                      count(1) AS ccno\n                    FROM SCORE\n                    GROUP BY CNO) a\n              WHERE a.ccno > 5)\nGROUP BY CNO;\n--查询所有学生的Sname、Cno和Degree列\nSELECT\n  SNAME,\n  CNO,\n  DEGREE\nFROM STUDENT st, SCORE sc\nWHERE st.SNO = sc.SNO;\n--查询“张旭“教师任课的学生成绩。\nSELECT *\nFROM TEACHER;\nSELECT *\nFROM COURSE c, TEACHER t\nWHERE c.TNO = t.TNO;\nSELECT *\nFROM SCORE\nWHERE CNO IN (SELECT CNO\n              FROM COURSE\n              WHERE TNO IN (SELECT TNO\n                            FROM TEACHER\n                            WHERE TNAME = '张旭'));\n\n--查询选修某课程的同学人数多于5人的教师姓名\nSELECT *\nFROM TEACHER\nWHERE TNO IN (SELECT TNO\n              FROM COURSE\n              WHERE CNO IN (SELECT CNO\n                            FROM (SELECT\n                                    CNO,\n                                    count(1) AS CCNO\n                                  FROM SCORE\n                                  GROUP BY CNO) t\n                            WHERE t.CCNO > 5));\n--查询存在有85分以上成绩的课程Cno.\nSELECT DISTINCT CNO\nFROM SCORE\nWHERE DEGREE > 85;\n--查询出“计算机系“教师所教课程的成绩表\nSELECT *\nFROM SCORE\nWHERE CNO IN (SELECT CNO\n              FROM COURSE\n              WHERE TNO IN (SELECT TNO\n                            FROM TEACHER\n                            WHERE DEPART = '计算机系'));\n--查询“计算 机系”与“电子工程系“不同职称的教师的Tname和Prof\nSELECT\n  TNAME,\n  PROF\nFROM TEACHER\nWHERE PROF NOT IN (\n\n  SELECT PROF\n  FROM TEACHER\n  WHERE DEPART = '计算机系' INTERSECT\n  SELECT PROF\n  FROM TEACHER\n  WHERE DEPART = '电子工程系');\n--查询选修编号为“3-105“课程且成绩至少高于选修编号为“3-245”的同学的Cno、Sno和Degree,并按Degree从高到低次序排序。\nSELECT *\nFROM SCORE\nWHERE CNO = '3-105' AND DEGREE > (SELECT max(DEGREE)\n                                  FROM SCORE\n                                  WHERE CNO = '3-245')\nORDER BY DEGREE DESC;\n--查询选修编号为“3-105”且成绩高于选修编号为“3-245”课程的同学的Cno、Sno和Degree.all:代表括号中的所有成绩\nSELECT sum(DEGREE)\nFROM SCORE\nWHERE CNO = '3-105' AND DEGREE > (SELECT max(DEGREE)\n                                  FROM SCORE\n                                  WHERE CNO = '3-245')\nORDER BY DEGREE DESC;\n--查询所有“女”教师和“女”同学的name、sex和birthday\nSELECT\n  TNAME,\n  TSEX,\n  TBIRTHDAY\nFROM TEACHER\nWHERE TSEX = '女'\nUNION SELECT\n        SNAME,\n        SSEX,\n        SBIRTHDAY\n      FROM STUDENT\n      WHERE SSEX = '女';\n--查询成绩比该课程平均成绩低的同学的成绩表\nSELECT *\nFROM SCORE\nWHERE DEGREE < (SELECT avg(DEGREE)\n                FROM SCORE);\n-- 查询所有未讲课的教师的Tname和Depart.\nSELECT\n  TNAME,\n  DEPART\nFROM TEACHER\nWHERE TNO IN (SELECT TNO\n              FROM COURSE\n              WHERE CNO NOT IN (SELECT CNO\n                                FROM SCORE));\n--查询至少有2名男生的班号\nSELECT CLASS\nFROM (SELECT\n        CLASS,\n        count(1) c\n      FROM STUDENT\n      GROUP BY CLASS) t\nWHERE t.c >= 2;\n--查询Student表中不姓“王”的同学记录\nSELECT *\nFROM STUDENT\nWHERE SNAME NOT LIKE '王%';\n\n--查询Student表中每个学生的姓名和年龄\nSELECT\n  SNAME,\n  TRUNC(months_between(sysdate, SBIRTHDAY) / 12)\nFROM STUDENT;\n\nSELECT\n  SNAME,\n  trunc((to_char(sysdate, 'yyyymmdd') - to_char(SBIRTHDAY, 'yyyymmdd')) / 10000)\nFROM STUDENT;\n\n\n```\n\n## 行列转换\n\n```sql\nCREATE TABLE kecheng\n(\n  id     NUMBER,\n  name   VARCHAR2(20),\n  course VARCHAR2(20),\n  score  NUMBER\n);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (1, '张三', '语文', 67);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (1, '张三', '数学', 76);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (1, '张三', '英语', 43);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (1, '张三', '历史', 56);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (1, '张三', '化学', 11);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (2, '李四', '语文', 54);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (2, '李四', '数学', 81);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (2, '李四', '英语', 64);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (2, '李四', '历史', 93);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (2, '李四', '化学', 27);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (3, '王五', '语文', 24);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (3, '王五', '数学', 25);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (3, '王五', '英语', 8);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (3, '王五', '历史', 45);\nINSERT INTO kecheng (id, name, course, score)\nVALUES (3, '王五', '化学', 1);\nCOMMIT;\n```\n\n## 行列转换答案\n\n```sql\nSELECT\n  ID,\n  NAME,\n  SUM(DECODE(course, '语文', score, 0)) 语文,\n  --这里使用max,min都可以\n  SUM(DECODE(course, '数学', score, 0)) 数学,\n  SUM(DECODE(course, '英语', score, 0)) 英语,\n  SUM(DECODE(course, '历史', score, 0)) 历史,\n  SUM(DECODE(course, '化学', score, 0)) 化学\nFROM kecheng\nGROUP BY ID, NAME;\n\n\nSELECT\n  ID,\n  NAME ,\n  SUM(CASE WHEN course  = '语文' THEN score ELSE 0 END ) 语文,\n  SUM(CASE WHEN course  = '数学' THEN score ELSE 0 END ) 数学,\n  SUM(CASE WHEN course  = '英语' THEN score ELSE 0 END ) 英语,\n  SUM(CASE WHEN course  = '历史' THEN score ELSE 0 END ) 历史,\n  SUM(CASE WHEN course  = '化学' THEN score ELSE 0 END ) 化学\nFROM kecheng\nGROUP BY ID,NAME;\n```\n\n## `decode`\n\n将查询结果转换为另一个值，可以设定默认值\n\n```sql\nSELECT DECODE(course,'语文‘,'yuwen','数学','shuxue','qitar') pingying FROM kecheng\n```\n","categories":["db"],"tags":["sql","oracle"]},{"title":"linux","url":"/2019/07/04/linux/","content":"\nshell 是系统内核和用户沟通的桥梁，它作为系统的命令解释器为用户提供解释命令的功能。linux 系统上存在多种 shell。可通过\n\n```shell\n#查看系统支持的 shell 软件\ncat /etc/shells\n#查看用户登录后默认使用的shell(当前用户时li)\ncat /etc/passwd|grep ^li:\n```\n\nlinux 的用户分为以下几类\n\n1. root 用户，拥有系统的最高权限，任何文件的权限对 root 用户都是无效的。\n2. 普通用户，指可以登录系统，拥有自己的主目录并且能够在主目录创建目录和操作文件的用户\n3. 系统用户，又称虚拟用户和伪用户，其不具备登录系统的能力。这些用户用于特定的系统目的，如用来执行特定子系统完成服务所需要的进程等。系统用户的账号不属于任何人，是在系统安装或软件安装过程中默认创建的。\n4. 当使用`sudo`还是无法运行命令时，需要将当前用户写入到`/ect/sudoers`配置中，在\n   `root ALL=(ALL) ALL`下新增一行`[user] ALL = (ALL) ALL`\n\n在 linux 系统下创建的用户的信息都被写在`/etc/passwd`这个文件中永久性保存，用户的密码经过 MD5 加密后存放在称为影子文件的`/etc/shadow`中\n\n- w 查看当前登录用户\n\n1. {% post_link linux环境变量 %}\n2. {% post_link linux进程管理 %}\n3. {% post_link linux查看 %}\n4. {% post_link linux搜索 %}\n5. {% post_link linux常用命令 %}\n6. {% post_link linux文件系统 %}\n","categories":["linux"],"tags":["tips","linux"]}]